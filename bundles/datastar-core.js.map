{
  "version": 3,
  "sources": ["../library/src/utils/text.ts", "../library/src/engine/consts.ts", "../library/src/engine/errors.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/nestedSignals.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/plugins/official/core/macros/signals.ts", "../library/src/utils/dom.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["export const isBoolString = (str: string) => str.trim() === \"true\";\n\nexport const kebabize = (str: string) =>\n    str.replace(\n        /[A-Z]+(?![a-z])|[A-Z]/g,\n        ($, ofs) => (ofs ? \"-\" : \"\") + $.toLowerCase(),\n    );\n", "// This is auto-generated by Datastar. DO NOT EDIT.\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\nexport const VERSION = \"0.20.1\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during merges. Allows for CSS transitions to complete.\nexport const DefaultSettleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import { kebabize } from \"../utils/text\";\nimport { DATASTAR } from \"./consts\";\n\nconst url = `https://data-star.dev/docs/errors`;\n\nexport const hasValNonExpr = /([\\w0-9.]+)\\.value/gm;\n\nexport const dsErr = (code: string, args?: any) => {\n    const e = new Error();\n    e.name = `${DATASTAR}${code}`;\n    const fullURL = `${url}/${kebabize(code)}?${new URLSearchParams(args)}`;\n    e.message = `${DATASTAR}${code}, for more info see ${fullURL}`;\n    return e;\n};\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n\nimport { dsErr } from \"../engine/errors\";\nimport { OnRemovalFn } from \"../engine/types\";\n\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n    // A source whose value the target depends on.\n    _source: Signal;\n    _prevSource?: Node;\n    _nextSource?: Node;\n\n    // A target that depends on the source and should be notified when the source changes.\n    _target: Computed | Effect;\n    _prevTarget?: Node;\n    _nextTarget?: Node;\n\n    // The version number of the source that target has last seen. We use version numbers\n    // instead of storing the source value, because source values can take arbitrary amount\n    // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n    // Use the special value -1 to mark potentially unused but recyclable nodes.\n    _version: number;\n\n    // Used to remember & roll back the source's previous `._node` value when entering &\n    // exiting a new evaluation context.\n    _rollbackNode?: Node;\n};\n\nfunction startBatch() {\n    batchDepth++;\n}\n\nfunction endBatch() {\n    if (batchDepth > 1) {\n        batchDepth--;\n        return;\n    }\n\n    let error: unknown;\n    let hasError = false;\n\n    while (batchedEffect !== undefined) {\n        let effect: Effect | undefined = batchedEffect;\n        batchedEffect = undefined;\n\n        batchIteration++;\n\n        while (effect !== undefined) {\n            const next: Effect | undefined = effect._nextBatchedEffect;\n            effect._nextBatchedEffect = undefined;\n            effect._flags &= ~NOTIFIED;\n\n            if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n                try {\n                    effect._callback();\n                } catch (err) {\n                    if (!hasError) {\n                        error = err;\n                        hasError = true;\n                    }\n                }\n            }\n            effect = next;\n        }\n    }\n    batchIteration = 0;\n    batchDepth--;\n\n    if (hasError) {\n        throw dsErr(\"HadError\", error);\n    }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n    if (batchDepth > 0) {\n        return fn();\n    }\n    /*@__INLINE__**/ startBatch();\n    try {\n        return fn();\n    } finally {\n        endBatch();\n    }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n        return fn();\n    } finally {\n        evalContext = prevContext;\n    }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n    if (evalContext === undefined) {\n        return undefined;\n    }\n\n    let node = signal._node;\n    if (node === undefined || node._target !== evalContext) {\n        /**\n         * `signal` is a new dependency. Create a new dependency node, and set it\n         * as the tail of the current context's dependency list. e.g:\n         *\n         * { A <-> B       }\n         *         \u2191     \u2191\n         *        tail  node (new)\n         *               \u2193\n         * { A <-> B <-> C }\n         *               \u2191\n         *              tail (evalContext._sources)\n         */\n        node = {\n            _version: 0,\n            _source: signal,\n            _prevSource: evalContext._sources,\n            _nextSource: undefined,\n            _target: evalContext,\n            _prevTarget: undefined,\n            _nextTarget: undefined,\n            _rollbackNode: node,\n        };\n\n        if (evalContext._sources !== undefined) {\n            evalContext._sources._nextSource = node;\n        }\n        evalContext._sources = node;\n        signal._node = node;\n\n        // Subscribe to change notifications from this dependency if we're in an effect\n        // OR evaluating a computed signal that in turn has subscribers.\n        if (evalContext._flags & TRACKING) {\n            signal._subscribe(node);\n        }\n        return node;\n    } else if (node._version === -1) {\n        // `signal` is an existing dependency from a previous evaluation. Reuse it.\n        node._version = 0;\n\n        /**\n         * If `node` is not already the current tail of the dependency list (i.e.\n         * there is a next node in the list), then make the `node` the new tail. e.g:\n         *\n         * { A <-> B <-> C <-> D }\n         *         \u2191           \u2191\n         *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n         *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n         *               \u2193     \u2193\n         * { A <-> C <-> D <-> B }\n         *                     \u2191\n         *                    tail (evalContext._sources)\n         */\n        if (node._nextSource !== undefined) {\n            node._nextSource._prevSource = node._prevSource;\n\n            if (node._prevSource !== undefined) {\n                node._prevSource._nextSource = node._nextSource;\n            }\n\n            node._prevSource = evalContext._sources;\n            node._nextSource = undefined;\n\n            evalContext._sources!._nextSource = node;\n            evalContext._sources = node;\n        }\n\n        // We can assume that the currently evaluated effect / computed signal is already\n        // subscribed to change notifications from `signal` if needed.\n        return node;\n    }\n    return undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n    /** @internal */\n    _value: unknown;\n\n    /**\n     * @internal\n     * Version numbers should always be >= 0, because the special value -1 is used\n     * by Nodes to signify potentially unused but recyclable nodes.\n     */\n    _version: number;\n\n    /** @internal */\n    _node?: Node;\n\n    /** @internal */\n    _targets?: Node;\n\n    constructor(value?: T);\n\n    /** @internal */\n    _refresh(): boolean;\n\n    /** @internal */\n    _subscribe(node: Node): void;\n\n    /** @internal */\n    _unsubscribe(node: Node): void;\n\n    subscribe(fn: (value: T) => void): () => void;\n\n    valueOf(): T;\n\n    toString(): string;\n\n    toJSON(): T;\n\n    peek(): T;\n\n    brand: typeof BRAND_SYMBOL;\n\n    get value(): T;\n    set value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n    this._value = value;\n    this._version = 0;\n    this._node = undefined;\n    this._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n    return true;\n};\n\nSignal.prototype._subscribe = function (node) {\n    if (this._targets !== node && node._prevTarget === undefined) {\n        node._nextTarget = this._targets;\n        if (this._targets !== undefined) {\n            this._targets._prevTarget = node;\n        }\n        this._targets = node;\n    }\n};\n\nSignal.prototype._unsubscribe = function (node) {\n    // Only run the unsubscribe step if the signal has any subscribers to begin with.\n    if (this._targets !== undefined) {\n        const prev = node._prevTarget;\n        const next = node._nextTarget;\n        if (prev !== undefined) {\n            prev._nextTarget = next;\n            node._prevTarget = undefined;\n        }\n        if (next !== undefined) {\n            next._prevTarget = prev;\n            node._nextTarget = undefined;\n        }\n        if (node === this._targets) {\n            this._targets = next;\n        }\n    }\n};\n\nSignal.prototype.subscribe = function (fn) {\n    return effect(() => {\n        const value = this.value;\n\n        const prevContext = evalContext;\n        evalContext = undefined;\n        try {\n            fn(value);\n        } finally {\n            evalContext = prevContext;\n        }\n    });\n};\n\nSignal.prototype.valueOf = function () {\n    return this.value;\n};\n\nSignal.prototype.toString = function () {\n    return this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n    return this.value;\n};\n\nSignal.prototype.peek = function () {\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n        return this.value;\n    } finally {\n        evalContext = prevContext;\n    }\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n    get(this: Signal) {\n        const node = addDependency(this);\n        if (node !== undefined) {\n            node._version = this._version;\n        }\n        return this._value;\n    },\n    set(this: Signal, value) {\n        if (value !== this._value) {\n            if (batchIteration > 100) {\n                throw dsErr(\"Signal cycle detected\");\n            }\n\n            this._value = value;\n            this._version++;\n            globalVersion++;\n\n            /**@__INLINE__*/ startBatch();\n            try {\n                for (\n                    let node = this._targets;\n                    node !== undefined;\n                    node = node._nextTarget\n                ) {\n                    node._target._notify();\n                }\n            } finally {\n                endBatch();\n            }\n        }\n    },\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n    return new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n    // Check the dependencies for changed values. The dependency list is already\n    // in order of use. Therefore if multiple dependencies have changed values, only\n    // the first used dependency is re-evaluated at this point.\n    for (\n        let node = target._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        // If there's a new version of the dependency before or after refreshing,\n        // or the dependency has something blocking it from refreshing at all (e.g. a\n        // dependency cycle), then we need to recompute.\n        if (\n            node._source._version !== node._version ||\n            !node._source._refresh() ||\n            node._source._version !== node._version\n        ) {\n            return true;\n        }\n    }\n    // If none of the dependencies have changed values since last recompute then\n    // there's no need to recompute.\n    return false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n    /**\n     * 1. Mark all current sources as re-usable nodes (version: -1)\n     * 2. Set a rollback node if the current node is being used in a different context\n     * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n     *\n     *    { undefined <- A <-> B <-> C -> undefined }\n     *                   \u2191           \u2191\n     *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     * target._sources = A; (node is head)  \u2502\n     *                   \u2193                  \u2502\n     * target._sources = C; (node is tail) \u2500\u2518\n     */\n    for (\n        let node = target._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        const rollbackNode = node._source._node;\n        if (rollbackNode !== undefined) {\n            node._rollbackNode = rollbackNode;\n        }\n        node._source._node = node;\n        node._version = -1;\n\n        if (node._nextSource === undefined) {\n            target._sources = node;\n            break;\n        }\n    }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n    let node = target._sources;\n    let head: Node | undefined = undefined;\n\n    /**\n     * At this point 'target._sources' points to the tail of the doubly-linked list.\n     * It contains all existing sources + new sources in order of use.\n     * Iterate backwards until we find the head node while dropping old dependencies.\n     */\n    while (node !== undefined) {\n        const prev = node._prevSource;\n\n        /**\n         * The node was not re-used, unsubscribe from its change notifications and remove itself\n         * from the doubly-linked list. e.g:\n         *\n         * { A <-> B <-> C }\n         *         \u2193\n         *    { A <-> C }\n         */\n        if (node._version === -1) {\n            node._source._unsubscribe(node);\n\n            if (prev !== undefined) {\n                prev._nextSource = node._nextSource;\n            }\n            if (node._nextSource !== undefined) {\n                node._nextSource._prevSource = prev;\n            }\n        } else {\n            /**\n             * The new head is the last node seen which wasn't removed/unsubscribed\n             * from the doubly-linked list. e.g:\n             *\n             * { A <-> B <-> C }\n             *   \u2191     \u2191     \u2191\n             *   \u2502     \u2502     \u2514 head = node\n             *   \u2502     \u2514 head = node\n             *   \u2514 head = node\n             */\n            head = node;\n        }\n\n        node._source._node = node._rollbackNode;\n        if (node._rollbackNode !== undefined) {\n            node._rollbackNode = undefined;\n        }\n\n        node = prev;\n    }\n\n    target._sources = head;\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n    _fn: () => T;\n    _sources?: Node;\n    _globalVersion: number;\n    _flags: number;\n\n    constructor(fn: () => T);\n\n    _notify(): void;\n    get value(): T;\n}\n\nexport function Computed(this: Computed, fn: () => unknown) {\n    Signal.call(this, undefined);\n\n    this._fn = fn;\n    this._sources = undefined;\n    this._globalVersion = globalVersion - 1;\n    this._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n    this._flags &= ~NOTIFIED;\n\n    if (this._flags & RUNNING) {\n        return false;\n    }\n\n    // If this computed signal has subscribed to updates from its dependencies\n    // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n    // flag not set), then the computed value can't have changed.\n    if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n        return true;\n    }\n    this._flags &= ~OUTDATED;\n\n    if (this._globalVersion === globalVersion) {\n        return true;\n    }\n    this._globalVersion = globalVersion;\n\n    // Mark this computed signal running before checking the dependencies for value\n    // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n    this._flags |= RUNNING;\n    if (this._version > 0 && !needsToRecompute(this)) {\n        this._flags &= ~RUNNING;\n        return true;\n    }\n\n    const prevContext = evalContext;\n    try {\n        prepareSources(this);\n        evalContext = this;\n        const value = this._fn();\n        if (\n            this._flags & HAS_ERROR ||\n            this._value !== value ||\n            this._version === 0\n        ) {\n            this._value = value;\n            this._flags &= ~HAS_ERROR;\n            this._version++;\n        }\n    } catch (err) {\n        this._value = err;\n        this._flags |= HAS_ERROR;\n        this._version++;\n    }\n    evalContext = prevContext;\n    cleanupSources(this);\n    this._flags &= ~RUNNING;\n    return true;\n};\n\nComputed.prototype._subscribe = function (node) {\n    if (this._targets === undefined) {\n        this._flags |= OUTDATED | TRACKING;\n\n        // A computed signal subscribes lazily to its dependencies when it\n        // gets its first subscriber.\n        for (\n            let node = this._sources;\n            node !== undefined;\n            node = node._nextSource\n        ) {\n            node._source._subscribe(node);\n        }\n    }\n    Signal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n    // Only run the unsubscribe step if the computed signal has any subscribers.\n    if (this._targets !== undefined) {\n        Signal.prototype._unsubscribe.call(this, node);\n\n        // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n        // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n        if (this._targets === undefined) {\n            this._flags &= ~TRACKING;\n\n            for (\n                let node = this._sources;\n                node !== undefined;\n                node = node._nextSource\n            ) {\n                node._source._unsubscribe(node);\n            }\n        }\n    }\n};\n\nComputed.prototype._notify = function () {\n    if (!(this._flags & NOTIFIED)) {\n        this._flags |= OUTDATED | NOTIFIED;\n\n        for (\n            let node = this._targets;\n            node !== undefined;\n            node = node._nextTarget\n        ) {\n            node._target._notify();\n        }\n    }\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n    get(this: Computed) {\n        if (this._flags & RUNNING) {\n            // Cycle detected\n            throw dsErr(\"Signal cycle detected\");\n        }\n        const node = addDependency(this);\n        this._refresh();\n        if (node !== undefined) {\n            node._version = this._version;\n        }\n        if (this._flags & HAS_ERROR) {\n            throw this._value;\n        }\n        return this._value;\n    },\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n    readonly value: T;\n    peek(): T;\n\n    subscribe(fn: (value: T) => void): () => void;\n    valueOf(): T;\n    toString(): string;\n    toJSON(): T;\n    brand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n    return new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n    const cleanup = effect._cleanup;\n    effect._cleanup = undefined;\n\n    if (typeof cleanup === \"function\") {\n        /*@__INLINE__**/ startBatch();\n\n        // Run cleanup functions always outside of any context.\n        const prevContext = evalContext;\n        evalContext = undefined;\n        try {\n            cleanup!();\n        } catch (err) {\n            effect._flags &= ~RUNNING;\n            effect._flags |= DISPOSED;\n            disposeEffect(effect);\n            throw err;\n        } finally {\n            evalContext = prevContext;\n            endBatch();\n        }\n    }\n}\n\nfunction disposeEffect(effect: Effect) {\n    for (\n        let node = effect._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        node._source._unsubscribe(node);\n    }\n    effect._fn = undefined;\n    effect._sources = undefined;\n\n    cleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n    if (evalContext !== this) {\n        throw dsErr(\"Effect out of order\");\n    }\n    cleanupSources(this);\n    evalContext = prevContext;\n\n    this._flags &= ~RUNNING;\n    if (this._flags & DISPOSED) {\n        disposeEffect(this);\n    }\n    endBatch();\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>;\n\ndeclare class Effect {\n    _fn?: EffectFn;\n    _cleanup?: () => void;\n    _sources?: Node;\n    _nextBatchedEffect?: Effect;\n    _flags: number;\n\n    constructor(fn: EffectFn);\n\n    _callback(): void;\n    _start(): () => void;\n    _notify(): void;\n    _dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n    this._fn = fn;\n    this._cleanup = undefined;\n    this._sources = undefined;\n    this._nextBatchedEffect = undefined;\n    this._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n    const finish = this._start();\n    try {\n        if (this._flags & DISPOSED) return;\n        if (this._fn === undefined) return;\n\n        const cleanup = this._fn();\n        if (typeof cleanup === \"function\") {\n            this._cleanup = cleanup!;\n        }\n    } finally {\n        finish();\n    }\n};\n\nEffect.prototype._start = function () {\n    if (this._flags & RUNNING) {\n        throw dsErr(\"Signal cycle detected\");\n    }\n    this._flags |= RUNNING;\n    this._flags &= ~DISPOSED;\n    cleanupEffect(this);\n    prepareSources(this);\n\n    /*@__INLINE__**/ startBatch();\n    const prevContext = evalContext;\n    evalContext = this;\n    return endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n    if (!(this._flags & NOTIFIED)) {\n        this._flags |= NOTIFIED;\n        this._nextBatchedEffect = batchedEffect;\n        batchedEffect = this;\n    }\n};\n\nEffect.prototype._dispose = function () {\n    this._flags |= DISPOSED;\n\n    if (!(this._flags & RUNNING)) {\n        disposeEffect(this);\n    }\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n    const effect = new Effect(fn);\n    try {\n        effect._callback();\n    } catch (err) {\n        effect._dispose();\n        throw err;\n    }\n    // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n    // because bound functions seem to be just as fast and take up a lot less memory.\n    return effect._dispose.bind(effect);\n}\n\nexport { batch, computed, effect, Signal, untracked };\nexport type { ReadonlySignal };\n", "import { Computed, computed, Signal } from \"../vendored/preact-core\";\nimport { NestedSignal, NestedValues } from \"./types\";\n\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n    signal: NestedSignal,\n    onlyPublic = false,\n): Record<string, any> {\n    const kv: Record<string, any> = {};\n    for (const key in signal) {\n        if (signal.hasOwnProperty(key)) {\n            const value = signal[key];\n            if (value instanceof Signal) {\n                if (onlyPublic && key.startsWith(\"_\")) {\n                    continue;\n                }\n                kv[key] = value.value;\n            } else {\n                kv[key] = nestedValues(value);\n            }\n        }\n    }\n    return kv;\n}\n\nfunction mergeNested(\n    target: NestedValues,\n    values: NestedValues,\n    onlyIfMissing = false,\n): void {\n    for (const key in values) {\n        if (values.hasOwnProperty(key)) {\n            const value = values[key];\n            if (value instanceof Object && !Array.isArray(value)) {\n                if (!target[key]) {\n                    target[key] = {};\n                }\n                mergeNested(\n                    target[key] as NestedValues,\n                    value as NestedValues,\n                    onlyIfMissing,\n                );\n            } else {\n                if (onlyIfMissing && target[key]) {\n                    continue;\n                }\n                target[key] = new Signal(value);\n            }\n        }\n    }\n}\n\nfunction walkNestedSignal(\n    signal: NestedSignal,\n    cb: (dotDeliminatedB: string, signal: Signal<any>) => void,\n): void {\n    for (const key in signal) {\n        if (signal.hasOwnProperty(key)) {\n            const value = signal[key];\n            if (value instanceof Signal) {\n                cb(key, value);\n            } else {\n                walkNestedSignal(value as NestedSignal, cb);\n            }\n        }\n    }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n    const subset: NestedValues = {};\n    for (const key of keys) {\n        const parts = key.split(\".\");\n        let subOriginal = original;\n        let subSubset = subset;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subOriginal[part]) {\n                return {};\n            }\n            if (!subSubset[part]) {\n                subSubset[part] = {};\n            }\n            subOriginal = subOriginal[part] as NestedValues;\n            subSubset = subSubset[part] as NestedValues;\n        }\n        const last = parts[parts.length - 1];\n        subSubset[last] = subOriginal[last];\n    }\n    return subset;\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n    nv: NestedValues,\n    cb: (path: string, value: any) => void,\n) {\n    for (const key in nv) {\n        if (nv.hasOwnProperty(key)) {\n            const value = nv[key];\n            if (value instanceof Object && !Array.isArray(value)) {\n                walkNestedValues(value, (path, value) => {\n                    cb(`${key}.${path}`, value);\n                });\n            } else {\n                cb(key, value);\n            }\n        }\n    }\n}\n\nexport class SignalsRoot {\n    private _signals: NestedSignal = {};\n\n    constructor() {}\n\n    exists(dotDelimitedPath: string): boolean {\n        return !!this.signal(dotDelimitedPath);\n    }\n\n    signal(dotDelimitedPath: string): Signal<any> | null {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                return null;\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n        return subSignals[last] as Signal<any>;\n    }\n\n    setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                subSignals[part] = {};\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n        subSignals[last] = signal;\n    }\n\n    setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n        const signal = computed(() => fn()) as Computed;\n        this.setSignal(dotDelimitedPath, signal);\n    }\n\n    value<T>(dotDelimitedPath: string): T {\n        const signal = this.signal(dotDelimitedPath);\n        return signal?.value;\n    }\n\n    setValue<T>(dotDelimitedPath: string, value: T) {\n        const s = this.upsert(dotDelimitedPath, value);\n        s.value = value;\n    }\n\n    upsert<T>(dotDelimitedPath: string, value: T) {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                subSignals[part] = {};\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n\n        const current = subSignals[last];\n        if (!!current) return current as Signal<T>;\n\n        const signal = new Signal(value);\n        subSignals[last] = signal;\n\n        return signal;\n    }\n\n    remove(...dotDelimitedPaths: string[]) {\n        for (const path of dotDelimitedPaths) {\n            const parts = path.split(\".\");\n            let subSignals = this._signals;\n            for (let i = 0; i < parts.length - 1; i++) {\n                const part = parts[i];\n                if (!subSignals[part]) {\n                    return;\n                }\n                subSignals = subSignals[part] as NestedSignal;\n            }\n            const last = parts[parts.length - 1];\n            delete subSignals[last];\n        }\n    }\n\n    merge(other: NestedValues, onlyIfMissing = false) {\n        mergeNested(this._signals, other, onlyIfMissing);\n    }\n\n    subset(...keys: string[]): NestedValues {\n        return nestedSubset(this.values(), ...keys);\n    }\n\n    walk(cb: (name: string, signal: Signal<any>) => void) {\n        walkNestedSignal(this._signals, cb);\n    }\n\n    values(onlyPublic = false): NestedValues {\n        return nestedValues(this._signals, onlyPublic);\n    }\n\n    JSON(shouldIndent = true, onlyPublic = false) {\n        const values = this.values(onlyPublic);\n        if (!shouldIndent) {\n            return JSON.stringify(values);\n        }\n        return JSON.stringify(values, null, 2);\n    }\n\n    public toString() {\n        return this.JSON();\n    }\n}\n", "import { walkNestedValues } from \"../../../../engine/nestedSignals\";\nimport {\n    AttributePlugin,\n    NestedValues,\n    PluginType,\n} from \"../../../../engine/types\";\nimport { computed } from \"../../../../vendored/preact-core\";\n\nconst name = \"computed\";\nexport const Computed: AttributePlugin = {\n    type: PluginType.Attribute,\n    name,\n    purge: true,\n    onLoad: ({ key, signals, genRX }) => {\n        const rx = genRX();\n        if (key.length) {\n            signals.setComputed(key, rx);\n        } else {\n            computed(() => {\n                const vals = rx<NestedValues>();\n                walkNestedValues(vals, (path, value) => {\n                    signals.setComputed(path, () => value);\n                });\n            });\n        }\n    },\n};\n", "import {\n    AttributePlugin,\n    NestedValues,\n    PluginType,\n} from \"../../../../engine/types\";\n\nexport const Signals: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"signals\",\n    purge: true,\n    onLoad: ({ key, signals, genRX }) => {\n        const rx = genRX();\n        const toMerge = rx<NestedValues>();\n        if (key) {\n            signals.setValue(key, toMerge);\n        } else {\n            signals.merge(toMerge);\n        }\n    },\n};\n", "import { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nexport const Star: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"star\",\n    onLoad: () => {\n        alert(\"YOU ARE PROBABLY OVERCOMPLICATING IT\");\n    },\n};\n", "import { MacroPlugin, PluginType } from \"../../../../engine/types\";\n\nexport const SignalValueMacro: MacroPlugin = {\n    name: \"signalValue\",\n    type: PluginType.Macro,\n    fn: (original: string) => {\n        const validJS = /(?<path>[\\w0-9.]*)(.value)/gm;\n        const sub = `ctx.signals.signal('$1').value`;\n        return original.replaceAll(validJS, sub);\n    },\n};\n", "import { DATASTAR } from \"../engine/consts\";\nimport { dsErr } from \"../engine/errors\";\n\nexport function elUniqId(el: Element) {\n    if (el.id) return el.id;\n    let hash = 0;\n    const hashUpdate = (n: number) => {\n        hash = ((hash << 5) - hash) + n;\n        return hash & hash;\n    };\n    const hashUpdateFromStr = (str: string) =>\n        str.split(\"\").forEach((c) => hashUpdate(c.charCodeAt(0)));\n\n    while (el.parentNode) {\n        if (el.id) {\n            hashUpdateFromStr(`${el.id}`);\n            break;\n        } else {\n            if (el === el.ownerDocument.documentElement) {\n                hashUpdateFromStr(el.tagName);\n            } else {\n                for (\n                    let i = 1, e = el;\n                    e.previousElementSibling;\n                    e = e.previousElementSibling, i++\n                ) {\n                    hashUpdate(i);\n                }\n                el = el.parentNode as Element;\n            }\n        }\n        el = el.parentNode as Element;\n    }\n    return DATASTAR + hash;\n}\n\nexport function scrollIntoView(\n    el: HTMLElement | SVGElement,\n    opts: ScrollIntoViewOptions,\n    shouldFocus = true,\n) {\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        throw dsErr(\"NotHTMLElement\", el);\n    }\n    if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n\n    el.scrollIntoView(opts);\n    if (shouldFocus) el.focus();\n}\n", "import { elUniqId } from \"../utils/dom\";\nimport { effect } from \"../vendored/preact-core\";\nimport { VERSION } from \"./consts\";\nimport { dsErr } from \"./errors\";\nimport { SignalsRoot } from \"./nestedSignals\";\nimport {\n    ActionPlugin,\n    ActionPlugins,\n    AttributePlugin,\n    DatastarPlugin,\n    HTMLorSVGElement,\n    InitContext,\n    MacroPlugin,\n    Modifiers,\n    OnRemovalFn,\n    PluginType,\n    RuntimeContext,\n    RuntimeExpressionFunction,\n    WatcherPlugin,\n} from \"./types\";\n\nconst isMacroPlugin = (p: DatastarPlugin): p is MacroPlugin =>\n    p.type === PluginType.Macro;\nconst isWatcherPlugin = (p: DatastarPlugin): p is WatcherPlugin =>\n    p.type === PluginType.Watcher;\nconst isAttributePlugin = (p: DatastarPlugin): p is AttributePlugin =>\n    p.type === PluginType.Attribute;\nconst isActionPlugin = (p: DatastarPlugin): p is ActionPlugin =>\n    p.type === PluginType.Action;\n\nexport class Engine {\n    private _signals = new SignalsRoot();\n    private plugins: AttributePlugin[] = [];\n    private macros: MacroPlugin[] = [];\n    private actions: ActionPlugins = {};\n    private watchers: WatcherPlugin[] = [];\n    private removals = new Map<\n        Element,\n        { id: string; set: Set<OnRemovalFn> }\n    >();\n\n    get version() {\n        return VERSION;\n    }\n\n    public load(...pluginsToLoad: DatastarPlugin[]) {\n        const allLoadedPlugins = new Set<DatastarPlugin>(this.plugins);\n\n        pluginsToLoad.forEach((plugin) => {\n            if (!!plugin.requires?.size) {\n                for (const requiredPluginType of plugin?.requires) {\n                    if (!allLoadedPlugins.has(requiredPluginType)) {\n                        // requires other plugin to be loaded\n                        throw dsErr(\"Plugin dependency not met\");\n                    }\n                }\n            }\n\n            let globalInitializer: ((ctx: InitContext) => void) | undefined;\n            if (isMacroPlugin(plugin)) {\n                if (this.macros.includes(plugin)) {\n                    throw dsErr(\"Plugin already exists\");\n                }\n                this.macros.push(plugin);\n            } else if (isWatcherPlugin(plugin)) {\n                if (this.watchers.includes(plugin)) {\n                    throw dsErr(\"Plugin already exists\");\n                }\n                this.watchers.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else if (isActionPlugin(plugin)) {\n                if (!!this.actions[plugin.name]) {\n                    throw dsErr(\"Plugin already exists\");\n                }\n                this.actions[plugin.name] = plugin;\n            } else if (isAttributePlugin(plugin)) {\n                if (this.plugins.includes(plugin)) {\n                    throw dsErr(\"Plugin already exists\");\n                }\n                this.plugins.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else {\n                throw dsErr(\"Plugin already exists\");\n            }\n\n            if (globalInitializer) {\n                const that = this; // I hate javascript\n                globalInitializer({\n                    get signals() {\n                        return that._signals;\n                    },\n                    effect: (cb: () => void): OnRemovalFn => effect(cb),\n                    actions: this.actions,\n                    apply: this.apply.bind(this),\n                    cleanup: this.cleanup.bind(this),\n                });\n            }\n\n            allLoadedPlugins.add(plugin);\n        });\n\n        this.apply(document.body);\n    }\n\n    private cleanup(element: Element) {\n        const removalSet = this.removals.get(element);\n        if (removalSet) {\n            for (const removal of removalSet.set) {\n                removal();\n            }\n            this.removals.delete(element);\n        }\n    }\n\n    private apply(rootElement: Element) {\n        const appliedMacros = new Set<MacroPlugin>();\n        this.plugins.forEach((p, pi) => {\n            this.walkDownDOM(rootElement, (el) => {\n                if (!pi) this.cleanup(el);\n\n                for (const rawKey in el.dataset) {\n                    const rawValue = `${el.dataset[rawKey]}` || \"\";\n                    let value = rawValue;\n\n                    if (!rawKey.startsWith(p.name)) continue;\n\n                    if (!el.id.length) {\n                        el.id = elUniqId(el);\n                    }\n\n                    appliedMacros.clear();\n\n                    const keyRaw = rawKey.slice(p.name.length);\n                    let [key, ...modifiersWithArgsArr] = keyRaw.split(\".\");\n                    if (key.length) {\n                        key = key[0].toLowerCase() + key.slice(1);\n                    }\n                    const mods: Modifiers = new Map<string, Set<string>>();\n                    modifiersWithArgsArr.forEach((m) => {\n                        const [label, ...args] = m.split(\"_\");\n                        mods.set(label, new Set(args));\n                    });\n\n                    const macros = [\n                        ...(p.macros?.pre || []),\n                        ...this.macros,\n                        ...(p.macros?.post || []),\n                    ];\n                    for (const macro of macros) {\n                        if (appliedMacros.has(macro)) continue;\n                        appliedMacros.add(macro);\n                        value = macro.fn(value);\n                    }\n\n                    const {\n                        actions,\n                        apply,\n                        cleanup,\n                    } = this;\n                    const that = this; // I hate javascript\n                    const ctx: RuntimeContext = {\n                        get signals() {\n                            return that._signals;\n                        },\n                        effect: (cb: () => void): OnRemovalFn => effect(cb),\n                        apply: apply.bind(this),\n                        cleanup: cleanup.bind(this),\n                        actions,\n                        genRX: () => {\n                            throw dsErr(\"NotImplemented\");\n                        },\n                        el,\n                        rawKey,\n                        rawValue,\n                        key,\n                        value,\n                        mods,\n                    };\n                    ctx.genRX = () => {\n                        return this.generateReactiveExpression(\n                            ctx,\n                            ...p.argNames || [],\n                        );\n                    };\n\n                    const removal = p.onLoad(ctx);\n\n                    if (removal) {\n                        if (!this.removals.has(el)) {\n                            this.removals.set(el, {\n                                id: el.id,\n                                set: new Set(),\n                            });\n                        }\n                        this.removals.get(el)!.set.add(removal);\n                    }\n\n                    if (!!p?.purge) {\n                        delete el.dataset[rawKey];\n                    }\n                }\n            });\n        });\n    }\n\n    private generateReactiveExpression(\n        ctx: RuntimeContext,\n        ...argNames: string[]\n    ): RuntimeExpressionFunction {\n        const statements = ctx.value\n            .split(/;|\\n/)\n            .map((s) => s.trim())\n            .filter((s) => s.length);\n        const lastIdx = statements.length - 1;\n        const RETURN = \"return\";\n        const last = statements[lastIdx];\n        if (!last.startsWith(RETURN)) {\n            statements[lastIdx] = `${RETURN} ${statements[lastIdx]};`;\n        }\n        const userExpression = statements.join(\";\\n\");\n\n        const fnCall = /(\\w*)\\(/gm;\n        const matches = userExpression.matchAll(fnCall);\n        const methodsCalled = new Set<string>();\n        for (const match of matches) {\n            methodsCalled.add(match[1]);\n        }\n        // Action names\n        const an = Object.keys(this.actions).filter((i) =>\n            methodsCalled.has(i)\n        );\n        // Action lines\n        const al = an.map((a) => `const ${a} = ctx.actions.${a}.fn;`);\n        const fnContent = `${al.join(\"\\n\")}\\n${userExpression}`;\n\n        // Add ctx to action calls\n        let fnContentWithCtx = fnContent;\n        an.forEach((a) => {\n            fnContentWithCtx = fnContentWithCtx.replaceAll(\n                a + \"(\",\n                a + \"(ctx,\",\n            );\n        });\n\n        try {\n            const argumentNames = argNames || [];\n            const fn = new Function(\"ctx\", ...argumentNames, fnContentWithCtx);\n            return (...args: any[]) => fn(ctx, ...args);\n        } catch (err) {\n            throw dsErr(\"ExpressionGeneration\", { err, fnContent });\n        }\n    }\n\n    private walkDownDOM(\n        element: Element | null,\n        callback: (el: HTMLorSVGElement) => void,\n    ) {\n        if (\n            !element ||\n            !(element instanceof HTMLElement || element instanceof SVGElement)\n        ) {\n            return null;\n        }\n\n        callback(element);\n\n        element = element.firstElementChild;\n        while (element) {\n            this.walkDownDOM(element, callback);\n            element = element.nextElementSibling;\n        }\n    }\n}\n", "import { Computed } from \"../plugins/official/core/attributes/computed\";\nimport { Signals } from \"../plugins/official/core/attributes/signals\";\nimport { Star } from \"../plugins/official/core/attributes/star\";\nimport { SignalValueMacro } from \"../plugins/official/core/macros/signals\";\nimport { Engine } from \"./engine\";\n\nconst ds = new Engine();\nds.load(\n    Star,\n    SignalValueMacro,\n    Signals,\n    Computed,\n);\nexport const Datastar = ds;\n", "import { Datastar } from \"../engine\";\n\nDatastar.load();\n"],
  "mappings": "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",
  "names": ["kebabize", "str", "$", "ofs", "DATASTAR", "VERSION", "FragmentMergeModes", "DefaultFragmentMergeMode", "url", "dsErr", "code", "args", "e", "DATASTAR", "fullURL", "url", "kebabize", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "dsErr", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "dsErr", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "dsErr", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "walkNestedSignal", "cb", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "walkNestedValues", "nv", "path", "SignalsRoot", "dotDelimitedPath", "subSignals", "fn", "computed", "s", "current", "dotDelimitedPaths", "other", "shouldIndent", "name", "Computed", "key", "signals", "genRX", "rx", "computed", "vals", "walkNestedValues", "path", "value", "Signals", "key", "signals", "genRX", "toMerge", "Star", "SignalValueMacro", "original", "validJS", "elUniqId", "el", "hash", "hashUpdate", "n", "hashUpdateFromStr", "str", "c", "e", "DATASTAR", "isMacroPlugin", "p", "isWatcherPlugin", "isAttributePlugin", "isActionPlugin", "Engine", "SignalsRoot", "VERSION", "pluginsToLoad", "allLoadedPlugins", "plugin", "requiredPluginType", "dsErr", "globalInitializer", "that", "cb", "effect", "element", "removalSet", "removal", "rootElement", "appliedMacros", "pi", "el", "rawKey", "rawValue", "value", "elUniqId", "keyRaw", "key", "modifiersWithArgsArr", "mods", "m", "label", "args", "macros", "macro", "actions", "apply", "cleanup", "ctx", "argNames", "statements", "s", "lastIdx", "RETURN", "userExpression", "fnCall", "matches", "methodsCalled", "match", "an", "i", "fnContent", "a", "fnContentWithCtx", "argumentNames", "fn", "err", "callback", "ds", "Engine", "Star", "SignalValueMacro", "Signals", "Computed", "Datastar", "Datastar"]
}
