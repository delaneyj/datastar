{
  "version": 3,
  "sources": ["../library/src/plugins/official/core/attributes/computed.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/plugins/official/core/macros/signals.ts", "../library/src/engine/consts.ts", "../library/src/utils/dom.ts", "../library/src/engine/errors.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/nestedSignals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["import { AttributePlugin, PluginType, Requirement } from '~/engine/types'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, signals, genRX }) => {\n    const rx = genRX()\n    signals.setComputed(key, rx)\n  },\n}\n", "export const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebabize = (str: string) =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? '-' : '') + $.toLowerCase(),\n  )\n\nexport const camelize = (str: string) =>\n  str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (word, index) {\n      return index == 0 ? word.toLowerCase() : word.toUpperCase()\n    })\n    .replace(/\\s+/g, '')\n\nexport const jsStrToObject = (raw: string) => {\n  return new Function(`return Object.assign({}, ${raw})`)()\n}\n", "import {\n  AttributePlugin,\n  NestedValues,\n  PluginType,\n  Requirement,\n} from '~/engine/types'\nimport { jsStrToObject } from '~/utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  valReq: Requirement.Must,\n  removeOnLoad: true,\n  onLoad: (ctx) => {\n    const { key, genRX, signals } = ctx\n    if (key != '') {\n      signals.setValue(key, genRX()())\n    } else {\n      const obj = jsStrToObject(ctx.value)\n      ctx.value = JSON.stringify(obj)\n      signals.merge(genRX()<NestedValues>())\n    }\n  },\n}\n", "import { AttributePlugin, PluginType, Requirement } from '~/engine/types'\n\nexport const Star: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'star',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: () => {\n    alert('YOU ARE PROBABLY OVERCOMPLICATING IT')\n  },\n}\n", "import { MacroPlugin, PluginType } from '~/engine/types'\n\nexport const SignalValueMacro: MacroPlugin = {\n  name: 'signalValue',\n  type: PluginType.Macro,\n  fn: (original: string) => {\n    const validJS = /(?<path>[\\w0-9.]*)((\\.value))/gm\n    const sub = `ctx.signals.signal('$1').value`\n    return original.replaceAll(validJS, sub)\n  },\n}\n", "// This is auto-generated by Datastar. DO NOT EDIT.\n\nexport const DATASTAR = 'datastar'\nexport const DATASTAR_EVENT = 'datastar-event'\nexport const DATASTAR_REQUEST = 'Datastar-Request'\nexport const VERSION = '0.21.2'\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during fragment merges. Allows for CSS transitions to complete.\nexport const DefaultFragmentsSettleDurationMs = 300\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000\n\n// #endregion\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = 'type module'\n\n// #endregion\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true\n\n// #endregion\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n  // Morphs the fragment into the existing element using idiomorph.\n  Morph: 'morph',\n  // Replaces the inner HTML of the existing element.\n  Inner: 'inner',\n  // Replaces the outer HTML of the existing element.\n  Outer: 'outer',\n  // Prepends the fragment to the existing element.\n  Prepend: 'prepend',\n  // Appends the fragment to the existing element.\n  Append: 'append',\n  // Inserts the fragment before the existing element.\n  Before: 'before',\n  // Inserts the fragment after the existing element.\n  After: 'after',\n  // Upserts the attributes of the existing element.\n  UpsertAttributes: 'upsertAttributes',\n} as const\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n  // An event for merging HTML fragments into the DOM.\n  MergeFragments: 'datastar-merge-fragments',\n  // An event for merging signals.\n  MergeSignals: 'datastar-merge-signals',\n  // An event for removing HTML fragments from the DOM.\n  RemoveFragments: 'datastar-remove-fragments',\n  // An event for removing signals.\n  RemoveSignals: 'datastar-remove-signals',\n  // An event for executing <script/> elements in the browser.\n  ExecuteScript: 'datastar-execute-script',\n} as const\n// #endregion\n\n// #endregion\n", "import { DATASTAR } from '~/engine/consts'\n\nexport function elUniqId(el: Element) {\n  if (el.id) return el.id\n  let hash = 0\n  const hashUpdate = (n: number) => {\n    hash = (hash << 5) - hash + n\n    return hash & hash\n  }\n  const hashUpdateFromStr = (str: string) =>\n    str.split('').forEach((c) => hashUpdate(c.charCodeAt(0)))\n\n  while (el.parentNode) {\n    if (el.id) {\n      hashUpdateFromStr(`${el.id}`)\n      break\n    } else {\n      if (el === el.ownerDocument.documentElement) {\n        hashUpdateFromStr(el.tagName)\n      } else {\n        for (\n          let i = 1, e = el;\n          e.previousElementSibling;\n          e = e.previousElementSibling, i++\n        ) {\n          hashUpdate(i)\n        }\n        el = el.parentNode as Element\n      }\n    }\n    el = el.parentNode as Element\n  }\n  return DATASTAR + hash\n}\n\nexport function onElementRemoved(element: Element, callback: () => void) {\n  const observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      for (const removedNode of mutation.removedNodes) {\n        if (removedNode === element) {\n          observer.disconnect()\n          callback()\n          return\n        }\n      }\n    }\n  })\n  observer.observe(element.parentNode as Node, { childList: true })\n}\n", "const url = `https://data-star.dev/errors`\n\nexport const hasValNonExpr = /([\\w0-9.]+)\\.value/gm\n\nexport const dsErr = (code: string, args?: any) => {\n  const e = new Error()\n  code = code.charAt(0).toUpperCase() + code.slice(1)\n  e.name = `error ${code}`\n  const fullURL = `${url}/${code}?${new URLSearchParams(args)}`\n  e.message = `for more info see ${fullURL}`\n  return e\n}\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n\nimport { dsErr } from '~/engine/errors'\nimport { OnRemovalFn } from '~/engine/types'\n\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) {\n    throw dsErr('BatchError, error', { error })\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return fn()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return fn()\n  } finally {\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof BRAND_SYMBOL\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = BRAND_SYMBOL\n\nSignal.prototype._refresh = function () {\n  return true\n}\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value\n\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      fn(value)\n    } finally {\n      evalContext = prevContext\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return this.value + ''\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return this.value\n  } finally {\n    evalContext = prevContext\n  }\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get(this: Signal) {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        throw dsErr('SignalCycleDetected')\n      }\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n    }\n  },\n})\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>\nexport function signal<T = undefined>(): Signal<T | undefined>\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head: Node | undefined = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n  _fn: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(fn: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\nexport function Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._fn = fn\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._fn()\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify()\n    }\n  }\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw dsErr('SignalCycleDetected')\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw dsErr('GetComputedError', { value: this._value })\n    }\n    return this._value\n  },\n})\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T\n  peek(): T\n\n  subscribe(fn: (value: T) => void): () => void\n  valueOf(): T\n  toString(): string\n  toJSON(): T\n  brand: typeof BRAND_SYMBOL\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup!()\n    } catch (error) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw dsErr('CleanupEffectError', { error })\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node)\n  }\n  effect._fn = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw dsErr('EndEffectError')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>\n\ndeclare class Effect {\n  _fn?: EffectFn\n  _cleanup?: () => void\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(fn: EffectFn)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._fn === undefined) return\n\n    const cleanup = this._fn()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup!\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    throw dsErr('SignalCycleDetected')\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn)\n  try {\n    effect._callback()\n  } catch (error) {\n    effect._dispose()\n    throw dsErr('EffectError', { error })\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { batch, computed, effect, Signal, untracked }\nexport type { ReadonlySignal }\n", "import { Computed, computed, Signal } from '~/vendored/preact-core'\nimport { dsErr } from './errors'\nimport { NestedSignal, NestedValues } from './types'\n\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedSignal,\n  onlyPublic = false,\n): Record<string, any> {\n  const kv: Record<string, any> = {}\n  for (const key in signal) {\n    if (signal.hasOwnProperty(key)) {\n      const value = signal[key]\n      if (value instanceof Signal) {\n        if (onlyPublic && key.startsWith('_')) {\n          continue\n        }\n        kv[key] = value.value\n      } else {\n        kv[key] = nestedValues(value)\n      }\n    }\n  }\n  return kv\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  onlyIfMissing = false,\n): void {\n  for (const key in values) {\n    if (values.hasOwnProperty(key)) {\n      if (key.match(/\\_\\_+/)) {\n        throw dsErr('InvalidSignalKey', { key })\n      }\n\n      const value = values[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {}\n        }\n        mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          onlyIfMissing,\n        )\n      } else {\n        if (onlyIfMissing && target[key]) {\n          continue\n        }\n        target[key] = new Signal(value)\n      }\n    }\n  }\n}\n\nfunction walkNestedSignal(\n  signal: NestedSignal,\n  cb: (dotDeliminatedPath: string, signal: Signal<any>) => void,\n): void {\n  for (const key in signal) {\n    if (signal.hasOwnProperty(key)) {\n      const value = signal[key]\n      if (value instanceof Signal) {\n        cb(key, value)\n      } else {\n        walkNestedSignal(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {}\n  for (const key of keys) {\n    const parts = key.split('.')\n    let subOriginal = original\n    let subSubset = subset\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subOriginal[part]) {\n        return {}\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {}\n      }\n      subOriginal = subOriginal[part] as NestedValues\n      subSubset = subSubset[part] as NestedValues\n    }\n    const last = parts[parts.length - 1]\n    subSubset[last] = subOriginal[last]\n  }\n  return subset\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n  nv: NestedValues,\n  cb: (path: string, value: any) => void,\n) {\n  for (const key in nv) {\n    if (nv.hasOwnProperty(key)) {\n      const value = nv[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        walkNestedValues(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      } else {\n        cb(key, value)\n      }\n    }\n  }\n}\n\nexport class SignalsRoot {\n  private _signals: NestedSignal = {}\n\n  constructor() {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath)\n  }\n\n  signal<T>(dotDelimitedPath: string): Signal<T> | null {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this._signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        return null\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    const signal = subSignals[last]\n    if (!signal) throw dsErr('SignalNotFound', { path: dotDelimitedPath })\n    return signal as Signal<T>\n  }\n\n  setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this._signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    subSignals[last] = signal\n  }\n\n  setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n    const signal = computed(() => fn()) as Computed\n    this.setSignal(dotDelimitedPath, signal)\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath) as Signal<T>\n    return signal?.value\n  }\n\n  setValue<T>(dotDelimitedPath: string, value: T) {\n    const s = this.upsert(dotDelimitedPath, value)\n    s.value = value\n  }\n\n  upsert<T>(dotDelimitedPath: string, value: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this._signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n\n    const current = subSignals[last]\n    if (!!current) {\n      if (current.value === null || current.value === undefined) {\n        current.value = value\n      }\n      return current as Signal<T>\n    }\n\n    const signal = new Signal(value)\n    subSignals[last] = signal\n\n    return signal\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split('.')\n      let subSignals = this._signals\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!subSignals[part]) {\n          return\n        }\n        subSignals = subSignals[part] as NestedSignal\n      }\n      const last = parts[parts.length - 1]\n      delete subSignals[last]\n    }\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    mergeNested(this._signals, other, onlyIfMissing)\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys)\n  }\n\n  walk(cb: (name: string, signal: Signal<any>) => void) {\n    walkNestedSignal(this._signals, cb)\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this._signals, onlyPublic)\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic)\n    if (!shouldIndent) {\n      return JSON.stringify(values)\n    }\n    return JSON.stringify(values, null, 2)\n  }\n\n  public toString() {\n    return this.JSON()\n  }\n}\n", "import { elUniqId } from '~/utils/dom'\nimport { camelize } from '~/utils/text'\nimport { effect } from '~/vendored/preact-core'\nimport { VERSION } from './consts'\nimport { dsErr } from './errors'\nimport { SignalsRoot } from './nestedSignals'\nimport {\n  ActionPlugin,\n  ActionPlugins,\n  AttributePlugin,\n  DatastarPlugin,\n  GlobalInitializer,\n  HTMLorSVGElement,\n  MacroPlugin,\n  Modifiers,\n  OnRemovalFn,\n  PluginType,\n  RemovalEntry,\n  Requirement,\n  RuntimeContext,\n  RuntimeExpressionFunction,\n  WatcherPlugin,\n} from './types'\n\nexport class Engine {\n  private _signals = new SignalsRoot()\n  private plugins: AttributePlugin[] = []\n  private macros: MacroPlugin[] = []\n  private actions: ActionPlugins = {}\n  private watchers: WatcherPlugin[] = []\n  private removals = new Map<Element, RemovalEntry>()\n\n  get version() {\n    return VERSION\n  }\n\n  public load(...pluginsToLoad: DatastarPlugin[]) {\n    pluginsToLoad.forEach((plugin) => {\n      let globalInitializer: GlobalInitializer | undefined\n      switch (plugin.type) {\n        case PluginType.Macro:\n          this.macros.push(plugin as MacroPlugin)\n          break\n        case PluginType.Watcher:\n          const wp = plugin as WatcherPlugin\n          this.watchers.push(wp)\n          globalInitializer = wp.onGlobalInit\n          break\n        case PluginType.Action:\n          this.actions[plugin.name] = plugin as ActionPlugin\n          break\n        case PluginType.Attribute:\n          const ap = plugin as AttributePlugin\n          this.plugins.push(ap)\n          globalInitializer = ap.onGlobalInit\n          break\n        default:\n          throw dsErr('InvalidPluginType', {\n            name: plugin.name,\n            type: plugin.type,\n          })\n      }\n      if (globalInitializer) {\n        const that = this // I hate javascript\n        globalInitializer({\n          get signals() {\n            return that._signals\n          },\n          effect: (cb: () => void): OnRemovalFn => effect(cb),\n          actions: this.actions,\n          apply: this.apply.bind(this),\n          cleanup: this.cleanup.bind(this),\n        })\n      }\n    })\n    this.apply(document.body)\n  }\n\n  // Clenup all plugins associated with the element\n  private cleanup(element: Element) {\n    const removalSet = this.removals.get(element)\n    if (removalSet) {\n      for (const removal of removalSet.set) {\n        removal()\n      }\n      this.removals.delete(element)\n    }\n  }\n\n  // Apply all plugins to the element and its children\n  public apply(rootElement: Element) {\n    const appliedMacros = new Set<MacroPlugin>()\n    this.plugins.forEach((p, pi) => {\n      this.walkDownDOM(rootElement, (el) => {\n        // Cleanup if not first plugin\n        if (!pi) this.cleanup(el)\n\n        for (const rawKey in el.dataset) {\n          // Check if the key is relevant to the plugin\n          if (!rawKey.startsWith(p.name)) continue\n\n          // Extract the key and value from the dataset\n          const keyRaw = rawKey.slice(p.name.length)\n          let [key, ...rawModifiers] = keyRaw.split(/\\_\\_+/)\n\n          const hasKey = key.length > 0\n          if (hasKey) {\n            key = key[0].toLowerCase() + key.slice(1)\n          }\n          const rawValue = `${el.dataset[rawKey]}` || ''\n          let value = rawValue\n          const hasValue = value.length > 0\n\n          // Check the requirements\n          const keyReq = p.keyReq || Requirement.Allowed\n          if (hasKey) {\n            if (keyReq === Requirement.Denied) {\n              throw dsErr(p.name + 'KeyNotAllowed', { key })\n            }\n          } else if (keyReq === Requirement.Must) {\n            throw dsErr(p.name + 'KeyRequired')\n          }\n          const valReq = p.valReq || Requirement.Allowed\n          if (hasValue) {\n            if (valReq === Requirement.Denied) {\n              throw dsErr(p.name + 'ValueNotAllowed', { value })\n            }\n          } else if (valReq === Requirement.Must) {\n            throw dsErr(p.name + 'ValueRequired')\n          }\n\n          // Check for exclusive requirements\n          if (\n            keyReq === Requirement.Exclusive ||\n            valReq === Requirement.Exclusive\n          ) {\n            if (hasKey && hasValue) {\n              throw dsErr(p.name + 'KeyAndValueProvided')\n            } else if (!hasKey && !hasValue) {\n              throw dsErr(p.name + 'KeyOrValueRequired')\n            }\n          }\n\n          // Ensure the element has an id\n          if (!el.id.length) el.id = elUniqId(el)\n\n          // Apply the macros\n          appliedMacros.clear()\n          const mods: Modifiers = new Map<string, Set<string>>()\n          rawModifiers.forEach((m) => {\n            const [label, ...args] = m.split('.')\n            mods.set(camelize(label), new Set(args))\n          })\n          const macros = [\n            ...(p.macros?.pre || []),\n            ...this.macros,\n            ...(p.macros?.post || []),\n          ]\n          for (const macro of macros) {\n            if (appliedMacros.has(macro)) continue\n            appliedMacros.add(macro)\n            value = macro.fn(value)\n          }\n\n          // Create the runtime context\n          const { actions, apply, cleanup } = this\n          const that = this // I hate javascript\n          let ctx: RuntimeContext\n          ctx = {\n            get signals() {\n              return that._signals\n            },\n            effect: (cb: () => void): OnRemovalFn => effect(cb),\n            apply: apply.bind(this),\n            cleanup: cleanup.bind(this),\n            actions,\n            genRX: () => this.genRX(ctx, ...(p.argNames || [])),\n            el,\n            rawKey,\n            rawValue,\n            key,\n            value,\n            mods,\n          }\n\n          // Load the plugin and store any cleanup functions\n          const removal = p.onLoad(ctx)\n          if (removal) {\n            if (!this.removals.has(el)) {\n              this.removals.set(el, {\n                id: el.id,\n                set: new Set(),\n              })\n            }\n            this.removals.get(el)!.set.add(removal)\n          }\n\n          // Remove the attribute if required\n          if (!!p?.removeOnLoad) delete el.dataset[rawKey]\n        }\n      })\n    })\n  }\n\n  private genRX(\n    ctx: RuntimeContext,\n    ...argNames: string[]\n  ): RuntimeExpressionFunction {\n    const stmts = ctx.value\n      .split(/;|\\n/)\n      .map((s) => s.trim())\n      .filter((s) => s != '')\n    const lastIdx = stmts.length - 1\n    const last = stmts[lastIdx]\n    if (!last.startsWith('return')) {\n      stmts[lastIdx] = `return (${stmts[lastIdx]});`\n    }\n    const userExpression = stmts.join('\\n')\n\n    const fnCall = /(\\w*)\\(/gm\n    const matches = userExpression.matchAll(fnCall)\n    const methodsCalled = new Set<string>()\n    for (const match of matches) {\n      methodsCalled.add(match[1])\n    }\n    // Action names\n    const an = Object.keys(this.actions).filter((i) => methodsCalled.has(i))\n    // Action lines\n    const al = an.map((a) => `const ${a} = ctx.actions.${a}.fn;`)\n    const fnContent = `${al.join('\\n')}return (()=> {${userExpression}})()`\n\n    // Add ctx to action calls\n    let fnWithCtx = fnContent.trim()\n    an.forEach((a) => {\n      fnWithCtx = fnWithCtx.replaceAll(a + '(', a + '(ctx,')\n    })\n\n    try {\n      const argumentNames = argNames || []\n      const fn = new Function('ctx', ...argumentNames, fnWithCtx)\n      return (...args: any[]) => fn(ctx, ...args)\n    } catch (error) {\n      throw dsErr('GeneratingExpressionFailed', {\n        error,\n        fnContent,\n      })\n    }\n  }\n\n  private walkDownDOM(\n    element: Element | null,\n    callback: (el: HTMLorSVGElement) => void,\n  ) {\n    if (\n      !element ||\n      !(element instanceof HTMLElement || element instanceof SVGElement)\n    )\n      return null\n    callback(element)\n    element = element.firstElementChild\n    while (element) {\n      this.walkDownDOM(element, callback)\n      element = element.nextElementSibling\n    }\n  }\n}\n", "import { Computed } from '~/plugins/official/core/attributes/computed'\nimport { Signals } from '~/plugins/official/core/attributes/signals'\nimport { Star } from '~/plugins/official/core/attributes/star'\nimport { SignalValueMacro } from '~/plugins/official/core/macros/signals'\nimport { Engine } from './engine'\n\nconst ds = new Engine()\nds.load(Star, SignalValueMacro, Signals, Computed)\nexport const Datastar = ds\n", "import { Datastar as DS } from '~/engine'\n\nexport const Datastar = DS\n"],
  "mappings": "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",
  "names": ["name", "Computed", "key", "signals", "genRX", "rx", "camelize", "str", "word", "index", "jsStrToObject", "raw", "Signals", "ctx", "key", "genRX", "signals", "obj", "jsStrToObject", "Star", "SignalValueMacro", "original", "validJS", "DATASTAR", "VERSION", "FragmentMergeModes", "DefaultFragmentMergeMode", "elUniqId", "el", "hash", "hashUpdate", "n", "hashUpdateFromStr", "str", "c", "i", "e", "DATASTAR", "url", "dsErr", "code", "args", "e", "fullURL", "url", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "dsErr", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "dsErr", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "dsErr", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "error", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "dsErr", "walkNestedSignal", "cb", "path", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "dotDelimitedPath", "parts", "subSignals", "i", "part", "last", "signal", "dsErr", "fn", "computed", "value", "current", "Signal", "dotDelimitedPaths", "path", "other", "onlyIfMissing", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "onlyPublic", "nestedValues", "shouldIndent", "values", "Engine", "SignalsRoot", "VERSION", "pluginsToLoad", "plugin", "globalInitializer", "wp", "ap", "dsErr", "that", "cb", "effect", "element", "removalSet", "removal", "rootElement", "appliedMacros", "p", "pi", "el", "rawKey", "keyRaw", "key", "rawModifiers", "hasKey", "rawValue", "value", "hasValue", "keyReq", "valReq", "elUniqId", "mods", "m", "label", "args", "camelize", "macros", "macro", "actions", "apply", "cleanup", "ctx", "argNames", "stmts", "s", "lastIdx", "userExpression", "fnCall", "matches", "methodsCalled", "match", "an", "i", "fnContent", "a", "fnWithCtx", "argumentNames", "fn", "error", "callback", "ds", "Engine", "Star", "SignalValueMacro", "Signals", "Computed", "Datastar", "Datastar"]
}
