{
  "version": 3,
  "sources": ["../library/src/plugins/official/core/attributes/computed.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/plugins/official/core/macros/signals.ts", "../library/src/engine/consts.ts", "../library/src/utils/dom.ts", "../library/src/engine/errors.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/nestedSignals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["import {\n    AttributePlugin,\n    PluginType,\n    Requirement,\n} from \"../../../../engine/types\";\n\nconst name = \"computed\";\nexport const Computed: AttributePlugin = {\n    type: PluginType.Attribute,\n    name,\n    keyReq: Requirement.Must,\n    valReq: Requirement.Must,\n    onLoad: ({ key, signals, genRX }) => {\n        const rx = genRX();\n        signals.setComputed(key, rx);\n    },\n};\n", "export const isBoolString = (str: string) => str.trim() === \"true\";\n\nexport const kebabize = (str: string) =>\n    str.replace(\n        /[A-Z]+(?![a-z])|[A-Z]/g,\n        ($, ofs) => (ofs ? \"-\" : \"\") + $.toLowerCase(),\n    );\n\nexport const camelize = (str: string) =>\n    str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (word, index) {\n        return index == 0 ? word.toLowerCase() : word.toUpperCase();\n    }).replace(/\\s+/g, \"\");\n\nexport const jsStrToObject = (raw: string) => {\n    return (new Function(`return Object.assign({}, ${raw})`))();\n};\n", "import {\n    AttributePlugin,\n    NestedValues,\n    PluginType,\n    Requirement,\n} from \"../../../../engine/types\";\nimport { jsStrToObject } from \"../../../../utils/text\";\n\nexport const Signals: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"signals\",\n    valReq: Requirement.Must,\n    removeOnLoad: true,\n    onLoad: (ctx) => {\n        const { key, genRX, signals } = ctx;\n        if (key != \"\") {\n            signals.setValue(key, genRX()());\n        } else {\n            const obj = jsStrToObject(ctx.value);\n            ctx.value = JSON.stringify(obj);\n            signals.merge(genRX()<NestedValues>());\n        }\n    },\n};\n", "import {\n    AttributePlugin,\n    PluginType,\n    Requirement,\n} from \"../../../../engine/types\";\n\nexport const Star: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"star\",\n    keyReq: Requirement.Denied,\n    valReq: Requirement.Denied,\n    onLoad: () => {\n        alert(\"YOU ARE PROBABLY OVERCOMPLICATING IT\");\n    },\n};\n", "import { MacroPlugin, PluginType } from \"../../../../engine/types\";\n\nexport const SignalValueMacro: MacroPlugin = {\n    name: \"signalValue\",\n    type: PluginType.Macro,\n    fn: (original: string) => {\n        const validJS = /(?<path>[\\w0-9.]*)((\\.value))/gm;\n        const sub = `ctx.signals.signal('$1').value`;\n        return original.replaceAll(validJS, sub);\n    },\n};\n", "// This is auto-generated by Datastar. DO NOT EDIT.\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\nexport const VERSION = \"0.21.0-beta2\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during merges. Allows for CSS transitions to complete.\nexport const DefaultSettleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import { DATASTAR } from \"../engine/consts\";\n\nexport function elUniqId(el: Element) {\n    if (el.id) return el.id;\n    let hash = 0;\n    const hashUpdate = (n: number) => {\n        hash = ((hash << 5) - hash) + n;\n        return hash & hash;\n    };\n    const hashUpdateFromStr = (str: string) =>\n        str.split(\"\").forEach((c) => hashUpdate(c.charCodeAt(0)));\n\n    while (el.parentNode) {\n        if (el.id) {\n            hashUpdateFromStr(`${el.id}`);\n            break;\n        } else {\n            if (el === el.ownerDocument.documentElement) {\n                hashUpdateFromStr(el.tagName);\n            } else {\n                for (\n                    let i = 1, e = el;\n                    e.previousElementSibling;\n                    e = e.previousElementSibling, i++\n                ) {\n                    hashUpdate(i);\n                }\n                el = el.parentNode as Element;\n            }\n        }\n        el = el.parentNode as Element;\n    }\n    return DATASTAR + hash;\n}", "const url = `https://data-star.dev/errors`;\n\nexport const hasValNonExpr = /([\\w0-9.]+)\\.value/gm;\n\nexport const dsErr = (code: string, args?: any) => {\n    const e = new Error();\n    e.name = `error ${code}`;\n    const fullURL = `${url}/${code}?${new URLSearchParams(args)}`;\n    e.message = `for more info see ${fullURL}`;\n    return e;\n};\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n\nimport { dsErr } from \"../engine/errors\";\nimport { OnRemovalFn } from \"../engine/types\";\n\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n    // A source whose value the target depends on.\n    _source: Signal;\n    _prevSource?: Node;\n    _nextSource?: Node;\n\n    // A target that depends on the source and should be notified when the source changes.\n    _target: Computed | Effect;\n    _prevTarget?: Node;\n    _nextTarget?: Node;\n\n    // The version number of the source that target has last seen. We use version numbers\n    // instead of storing the source value, because source values can take arbitrary amount\n    // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n    // Use the special value -1 to mark potentially unused but recyclable nodes.\n    _version: number;\n\n    // Used to remember & roll back the source's previous `._node` value when entering &\n    // exiting a new evaluation context.\n    _rollbackNode?: Node;\n};\n\nfunction startBatch() {\n    batchDepth++;\n}\n\nfunction endBatch() {\n    if (batchDepth > 1) {\n        batchDepth--;\n        return;\n    }\n\n    let error: unknown;\n    let hasError = false;\n\n    while (batchedEffect !== undefined) {\n        let effect: Effect | undefined = batchedEffect;\n        batchedEffect = undefined;\n\n        batchIteration++;\n\n        while (effect !== undefined) {\n            const next: Effect | undefined = effect._nextBatchedEffect;\n            effect._nextBatchedEffect = undefined;\n            effect._flags &= ~NOTIFIED;\n\n            if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n                try {\n                    effect._callback();\n                } catch (err) {\n                    if (!hasError) {\n                        error = err;\n                        hasError = true;\n                    }\n                }\n            }\n            effect = next;\n        }\n    }\n    batchIteration = 0;\n    batchDepth--;\n\n    if (hasError) {\n        throw dsErr(\"BatchError, error\", { error });\n    }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n    if (batchDepth > 0) {\n        return fn();\n    }\n    /*@__INLINE__**/ startBatch();\n    try {\n        return fn();\n    } finally {\n        endBatch();\n    }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n        return fn();\n    } finally {\n        evalContext = prevContext;\n    }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n    if (evalContext === undefined) {\n        return undefined;\n    }\n\n    let node = signal._node;\n    if (node === undefined || node._target !== evalContext) {\n        /**\n         * `signal` is a new dependency. Create a new dependency node, and set it\n         * as the tail of the current context's dependency list. e.g:\n         *\n         * { A <-> B       }\n         *         \u2191     \u2191\n         *        tail  node (new)\n         *               \u2193\n         * { A <-> B <-> C }\n         *               \u2191\n         *              tail (evalContext._sources)\n         */\n        node = {\n            _version: 0,\n            _source: signal,\n            _prevSource: evalContext._sources,\n            _nextSource: undefined,\n            _target: evalContext,\n            _prevTarget: undefined,\n            _nextTarget: undefined,\n            _rollbackNode: node,\n        };\n\n        if (evalContext._sources !== undefined) {\n            evalContext._sources._nextSource = node;\n        }\n        evalContext._sources = node;\n        signal._node = node;\n\n        // Subscribe to change notifications from this dependency if we're in an effect\n        // OR evaluating a computed signal that in turn has subscribers.\n        if (evalContext._flags & TRACKING) {\n            signal._subscribe(node);\n        }\n        return node;\n    } else if (node._version === -1) {\n        // `signal` is an existing dependency from a previous evaluation. Reuse it.\n        node._version = 0;\n\n        /**\n         * If `node` is not already the current tail of the dependency list (i.e.\n         * there is a next node in the list), then make the `node` the new tail. e.g:\n         *\n         * { A <-> B <-> C <-> D }\n         *         \u2191           \u2191\n         *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n         *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n         *               \u2193     \u2193\n         * { A <-> C <-> D <-> B }\n         *                     \u2191\n         *                    tail (evalContext._sources)\n         */\n        if (node._nextSource !== undefined) {\n            node._nextSource._prevSource = node._prevSource;\n\n            if (node._prevSource !== undefined) {\n                node._prevSource._nextSource = node._nextSource;\n            }\n\n            node._prevSource = evalContext._sources;\n            node._nextSource = undefined;\n\n            evalContext._sources!._nextSource = node;\n            evalContext._sources = node;\n        }\n\n        // We can assume that the currently evaluated effect / computed signal is already\n        // subscribed to change notifications from `signal` if needed.\n        return node;\n    }\n    return undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n    /** @internal */\n    _value: unknown;\n\n    /**\n     * @internal\n     * Version numbers should always be >= 0, because the special value -1 is used\n     * by Nodes to signify potentially unused but recyclable nodes.\n     */\n    _version: number;\n\n    /** @internal */\n    _node?: Node;\n\n    /** @internal */\n    _targets?: Node;\n\n    constructor(value?: T);\n\n    /** @internal */\n    _refresh(): boolean;\n\n    /** @internal */\n    _subscribe(node: Node): void;\n\n    /** @internal */\n    _unsubscribe(node: Node): void;\n\n    subscribe(fn: (value: T) => void): () => void;\n\n    valueOf(): T;\n\n    toString(): string;\n\n    toJSON(): T;\n\n    peek(): T;\n\n    brand: typeof BRAND_SYMBOL;\n\n    get value(): T;\n    set value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n    this._value = value;\n    this._version = 0;\n    this._node = undefined;\n    this._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n    return true;\n};\n\nSignal.prototype._subscribe = function (node) {\n    if (this._targets !== node && node._prevTarget === undefined) {\n        node._nextTarget = this._targets;\n        if (this._targets !== undefined) {\n            this._targets._prevTarget = node;\n        }\n        this._targets = node;\n    }\n};\n\nSignal.prototype._unsubscribe = function (node) {\n    // Only run the unsubscribe step if the signal has any subscribers to begin with.\n    if (this._targets !== undefined) {\n        const prev = node._prevTarget;\n        const next = node._nextTarget;\n        if (prev !== undefined) {\n            prev._nextTarget = next;\n            node._prevTarget = undefined;\n        }\n        if (next !== undefined) {\n            next._prevTarget = prev;\n            node._nextTarget = undefined;\n        }\n        if (node === this._targets) {\n            this._targets = next;\n        }\n    }\n};\n\nSignal.prototype.subscribe = function (fn) {\n    return effect(() => {\n        const value = this.value;\n\n        const prevContext = evalContext;\n        evalContext = undefined;\n        try {\n            fn(value);\n        } finally {\n            evalContext = prevContext;\n        }\n    });\n};\n\nSignal.prototype.valueOf = function () {\n    return this.value;\n};\n\nSignal.prototype.toString = function () {\n    return this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n    return this.value;\n};\n\nSignal.prototype.peek = function () {\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n        return this.value;\n    } finally {\n        evalContext = prevContext;\n    }\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n    get(this: Signal) {\n        const node = addDependency(this);\n        if (node !== undefined) {\n            node._version = this._version;\n        }\n        return this._value;\n    },\n    set(this: Signal, value) {\n        if (value !== this._value) {\n            if (batchIteration > 100) {\n                throw dsErr(\"SignalCycleDetected\");\n            }\n\n            this._value = value;\n            this._version++;\n            globalVersion++;\n\n            /**@__INLINE__*/ startBatch();\n            try {\n                for (\n                    let node = this._targets;\n                    node !== undefined;\n                    node = node._nextTarget\n                ) {\n                    node._target._notify();\n                }\n            } finally {\n                endBatch();\n            }\n        }\n    },\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n    return new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n    // Check the dependencies for changed values. The dependency list is already\n    // in order of use. Therefore if multiple dependencies have changed values, only\n    // the first used dependency is re-evaluated at this point.\n    for (\n        let node = target._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        // If there's a new version of the dependency before or after refreshing,\n        // or the dependency has something blocking it from refreshing at all (e.g. a\n        // dependency cycle), then we need to recompute.\n        if (\n            node._source._version !== node._version ||\n            !node._source._refresh() ||\n            node._source._version !== node._version\n        ) {\n            return true;\n        }\n    }\n    // If none of the dependencies have changed values since last recompute then\n    // there's no need to recompute.\n    return false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n    /**\n     * 1. Mark all current sources as re-usable nodes (version: -1)\n     * 2. Set a rollback node if the current node is being used in a different context\n     * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n     *\n     *    { undefined <- A <-> B <-> C -> undefined }\n     *                   \u2191           \u2191\n     *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     * target._sources = A; (node is head)  \u2502\n     *                   \u2193                  \u2502\n     * target._sources = C; (node is tail) \u2500\u2518\n     */\n    for (\n        let node = target._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        const rollbackNode = node._source._node;\n        if (rollbackNode !== undefined) {\n            node._rollbackNode = rollbackNode;\n        }\n        node._source._node = node;\n        node._version = -1;\n\n        if (node._nextSource === undefined) {\n            target._sources = node;\n            break;\n        }\n    }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n    let node = target._sources;\n    let head: Node | undefined = undefined;\n\n    /**\n     * At this point 'target._sources' points to the tail of the doubly-linked list.\n     * It contains all existing sources + new sources in order of use.\n     * Iterate backwards until we find the head node while dropping old dependencies.\n     */\n    while (node !== undefined) {\n        const prev = node._prevSource;\n\n        /**\n         * The node was not re-used, unsubscribe from its change notifications and remove itself\n         * from the doubly-linked list. e.g:\n         *\n         * { A <-> B <-> C }\n         *         \u2193\n         *    { A <-> C }\n         */\n        if (node._version === -1) {\n            node._source._unsubscribe(node);\n\n            if (prev !== undefined) {\n                prev._nextSource = node._nextSource;\n            }\n            if (node._nextSource !== undefined) {\n                node._nextSource._prevSource = prev;\n            }\n        } else {\n            /**\n             * The new head is the last node seen which wasn't removed/unsubscribed\n             * from the doubly-linked list. e.g:\n             *\n             * { A <-> B <-> C }\n             *   \u2191     \u2191     \u2191\n             *   \u2502     \u2502     \u2514 head = node\n             *   \u2502     \u2514 head = node\n             *   \u2514 head = node\n             */\n            head = node;\n        }\n\n        node._source._node = node._rollbackNode;\n        if (node._rollbackNode !== undefined) {\n            node._rollbackNode = undefined;\n        }\n\n        node = prev;\n    }\n\n    target._sources = head;\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n    _fn: () => T;\n    _sources?: Node;\n    _globalVersion: number;\n    _flags: number;\n\n    constructor(fn: () => T);\n\n    _notify(): void;\n    get value(): T;\n}\n\nexport function Computed(this: Computed, fn: () => unknown) {\n    Signal.call(this, undefined);\n\n    this._fn = fn;\n    this._sources = undefined;\n    this._globalVersion = globalVersion - 1;\n    this._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n    this._flags &= ~NOTIFIED;\n\n    if (this._flags & RUNNING) {\n        return false;\n    }\n\n    // If this computed signal has subscribed to updates from its dependencies\n    // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n    // flag not set), then the computed value can't have changed.\n    if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n        return true;\n    }\n    this._flags &= ~OUTDATED;\n\n    if (this._globalVersion === globalVersion) {\n        return true;\n    }\n    this._globalVersion = globalVersion;\n\n    // Mark this computed signal running before checking the dependencies for value\n    // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n    this._flags |= RUNNING;\n    if (this._version > 0 && !needsToRecompute(this)) {\n        this._flags &= ~RUNNING;\n        return true;\n    }\n\n    const prevContext = evalContext;\n    try {\n        prepareSources(this);\n        evalContext = this;\n        const value = this._fn();\n        if (\n            this._flags & HAS_ERROR ||\n            this._value !== value ||\n            this._version === 0\n        ) {\n            this._value = value;\n            this._flags &= ~HAS_ERROR;\n            this._version++;\n        }\n    } catch (err) {\n        this._value = err;\n        this._flags |= HAS_ERROR;\n        this._version++;\n    }\n    evalContext = prevContext;\n    cleanupSources(this);\n    this._flags &= ~RUNNING;\n    return true;\n};\n\nComputed.prototype._subscribe = function (node) {\n    if (this._targets === undefined) {\n        this._flags |= OUTDATED | TRACKING;\n\n        // A computed signal subscribes lazily to its dependencies when it\n        // gets its first subscriber.\n        for (\n            let node = this._sources;\n            node !== undefined;\n            node = node._nextSource\n        ) {\n            node._source._subscribe(node);\n        }\n    }\n    Signal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n    // Only run the unsubscribe step if the computed signal has any subscribers.\n    if (this._targets !== undefined) {\n        Signal.prototype._unsubscribe.call(this, node);\n\n        // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n        // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n        if (this._targets === undefined) {\n            this._flags &= ~TRACKING;\n\n            for (\n                let node = this._sources;\n                node !== undefined;\n                node = node._nextSource\n            ) {\n                node._source._unsubscribe(node);\n            }\n        }\n    }\n};\n\nComputed.prototype._notify = function () {\n    if (!(this._flags & NOTIFIED)) {\n        this._flags |= OUTDATED | NOTIFIED;\n\n        for (\n            let node = this._targets;\n            node !== undefined;\n            node = node._nextTarget\n        ) {\n            node._target._notify();\n        }\n    }\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n    get(this: Computed) {\n        if (this._flags & RUNNING) {\n            // Cycle detected\n            throw dsErr(\"SignalCycleDetected\");\n        }\n        const node = addDependency(this);\n        this._refresh();\n        if (node !== undefined) {\n            node._version = this._version;\n        }\n        if (this._flags & HAS_ERROR) {\n            throw dsErr(\"GetComputedError\", { value: this._value });\n        }\n        return this._value;\n    },\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n    readonly value: T;\n    peek(): T;\n\n    subscribe(fn: (value: T) => void): () => void;\n    valueOf(): T;\n    toString(): string;\n    toJSON(): T;\n    brand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n    return new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n    const cleanup = effect._cleanup;\n    effect._cleanup = undefined;\n\n    if (typeof cleanup === \"function\") {\n        /*@__INLINE__**/ startBatch();\n\n        // Run cleanup functions always outside of any context.\n        const prevContext = evalContext;\n        evalContext = undefined;\n        try {\n            cleanup!();\n        } catch (error) {\n            effect._flags &= ~RUNNING;\n            effect._flags |= DISPOSED;\n            disposeEffect(effect);\n            throw dsErr(\"CleanupEffectError\", { error });\n        } finally {\n            evalContext = prevContext;\n            endBatch();\n        }\n    }\n}\n\nfunction disposeEffect(effect: Effect) {\n    for (\n        let node = effect._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        node._source._unsubscribe(node);\n    }\n    effect._fn = undefined;\n    effect._sources = undefined;\n\n    cleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n    if (evalContext !== this) {\n        throw dsErr(\"EndEffectError\");\n    }\n    cleanupSources(this);\n    evalContext = prevContext;\n\n    this._flags &= ~RUNNING;\n    if (this._flags & DISPOSED) {\n        disposeEffect(this);\n    }\n    endBatch();\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>;\n\ndeclare class Effect {\n    _fn?: EffectFn;\n    _cleanup?: () => void;\n    _sources?: Node;\n    _nextBatchedEffect?: Effect;\n    _flags: number;\n\n    constructor(fn: EffectFn);\n\n    _callback(): void;\n    _start(): () => void;\n    _notify(): void;\n    _dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n    this._fn = fn;\n    this._cleanup = undefined;\n    this._sources = undefined;\n    this._nextBatchedEffect = undefined;\n    this._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n    const finish = this._start();\n    try {\n        if (this._flags & DISPOSED) return;\n        if (this._fn === undefined) return;\n\n        const cleanup = this._fn();\n        if (typeof cleanup === \"function\") {\n            this._cleanup = cleanup!;\n        }\n    } finally {\n        finish();\n    }\n};\n\nEffect.prototype._start = function () {\n    if (this._flags & RUNNING) {\n        throw dsErr(\"SignalCycleDetected\");\n    }\n    this._flags |= RUNNING;\n    this._flags &= ~DISPOSED;\n    cleanupEffect(this);\n    prepareSources(this);\n\n    /*@__INLINE__**/ startBatch();\n    const prevContext = evalContext;\n    evalContext = this;\n    return endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n    if (!(this._flags & NOTIFIED)) {\n        this._flags |= NOTIFIED;\n        this._nextBatchedEffect = batchedEffect;\n        batchedEffect = this;\n    }\n};\n\nEffect.prototype._dispose = function () {\n    this._flags |= DISPOSED;\n\n    if (!(this._flags & RUNNING)) {\n        disposeEffect(this);\n    }\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n    const effect = new Effect(fn);\n    try {\n        effect._callback();\n    } catch (error) {\n        effect._dispose();\n        throw dsErr(\"EffectError\", { error });\n    }\n    // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n    // because bound functions seem to be just as fast and take up a lot less memory.\n    return effect._dispose.bind(effect);\n}\n\nexport { batch, computed, effect, Signal, untracked };\nexport type { ReadonlySignal };\n", "import { Computed, computed, Signal } from \"../vendored/preact-core\";\nimport { dsErr } from \"./errors\";\nimport { NestedSignal, NestedValues } from \"./types\";\n\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n    signal: NestedSignal,\n    onlyPublic = false,\n): Record<string, any> {\n    const kv: Record<string, any> = {};\n    for (const key in signal) {\n        if (signal.hasOwnProperty(key)) {\n            const value = signal[key];\n            if (value instanceof Signal) {\n                if (onlyPublic && key.startsWith(\"_\")) {\n                    continue;\n                }\n                kv[key] = value.value;\n            } else {\n                kv[key] = nestedValues(value);\n            }\n        }\n    }\n    return kv;\n}\n\nfunction mergeNested(\n    target: NestedValues,\n    values: NestedValues,\n    onlyIfMissing = false,\n): void {\n    for (const key in values) {\n        if (values.hasOwnProperty(key)) {\n            const value = values[key];\n            if (value instanceof Object && !Array.isArray(value)) {\n                if (!target[key]) {\n                    target[key] = {};\n                }\n                mergeNested(\n                    target[key] as NestedValues,\n                    value as NestedValues,\n                    onlyIfMissing,\n                );\n            } else {\n                if (onlyIfMissing && target[key]) {\n                    continue;\n                }\n                target[key] = new Signal(value);\n            }\n        }\n    }\n}\n\nfunction walkNestedSignal(\n    signal: NestedSignal,\n    cb: (dotDeliminatedB: string, signal: Signal<any>) => void,\n): void {\n    for (const key in signal) {\n        if (signal.hasOwnProperty(key)) {\n            const value = signal[key];\n            if (value instanceof Signal) {\n                cb(key, value);\n            } else {\n                walkNestedSignal(value as NestedSignal, cb);\n            }\n        }\n    }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n    const subset: NestedValues = {};\n    for (const key of keys) {\n        const parts = key.split(\".\");\n        let subOriginal = original;\n        let subSubset = subset;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subOriginal[part]) {\n                return {};\n            }\n            if (!subSubset[part]) {\n                subSubset[part] = {};\n            }\n            subOriginal = subOriginal[part] as NestedValues;\n            subSubset = subSubset[part] as NestedValues;\n        }\n        const last = parts[parts.length - 1];\n        subSubset[last] = subOriginal[last];\n    }\n    return subset;\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n    nv: NestedValues,\n    cb: (path: string, value: any) => void,\n) {\n    for (const key in nv) {\n        if (nv.hasOwnProperty(key)) {\n            const value = nv[key];\n            if (value instanceof Object && !Array.isArray(value)) {\n                walkNestedValues(value, (path, value) => {\n                    cb(`${key}.${path}`, value);\n                });\n            } else {\n                cb(key, value);\n            }\n        }\n    }\n}\n\nexport class SignalsRoot {\n    private _signals: NestedSignal = {};\n\n    constructor() {}\n\n    exists(dotDelimitedPath: string): boolean {\n        return !!this.signal(dotDelimitedPath);\n    }\n\n    signal<T>(dotDelimitedPath: string): Signal<T> | null {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                return null;\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n        const signal = subSignals[last];\n        if (!signal) throw dsErr(\"SignalNotFound\", { path: dotDelimitedPath });\n        return signal as Signal<T>;\n    }\n\n    setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                subSignals[part] = {};\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n        subSignals[last] = signal;\n    }\n\n    setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n        const signal = computed(() => fn()) as Computed;\n        this.setSignal(dotDelimitedPath, signal);\n    }\n\n    value<T>(dotDelimitedPath: string): T {\n        const signal = this.signal(dotDelimitedPath) as Signal<T>;\n        return signal?.value;\n    }\n\n    setValue<T>(dotDelimitedPath: string, value: T) {\n        const s = this.upsert(dotDelimitedPath, value);\n        s.value = value;\n    }\n\n    upsert<T>(dotDelimitedPath: string, value: T) {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                subSignals[part] = {};\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n\n        const current = subSignals[last];\n        if (!!current) {\n            if (current.value === null || current.value === undefined) {\n                current.value = value;\n            }\n            return current as Signal<T>;\n        }\n\n        const signal = new Signal(value);\n        subSignals[last] = signal;\n\n        return signal;\n    }\n\n    remove(...dotDelimitedPaths: string[]) {\n        for (const path of dotDelimitedPaths) {\n            const parts = path.split(\".\");\n            let subSignals = this._signals;\n            for (let i = 0; i < parts.length - 1; i++) {\n                const part = parts[i];\n                if (!subSignals[part]) {\n                    return;\n                }\n                subSignals = subSignals[part] as NestedSignal;\n            }\n            const last = parts[parts.length - 1];\n            delete subSignals[last];\n        }\n    }\n\n    merge(other: NestedValues, onlyIfMissing = false) {\n        mergeNested(this._signals, other, onlyIfMissing);\n    }\n\n    subset(...keys: string[]): NestedValues {\n        return nestedSubset(this.values(), ...keys);\n    }\n\n    walk(cb: (name: string, signal: Signal<any>) => void) {\n        walkNestedSignal(this._signals, cb);\n    }\n\n    values(onlyPublic = false): NestedValues {\n        return nestedValues(this._signals, onlyPublic);\n    }\n\n    JSON(shouldIndent = true, onlyPublic = false) {\n        const values = this.values(onlyPublic);\n        if (!shouldIndent) {\n            return JSON.stringify(values);\n        }\n        return JSON.stringify(values, null, 2);\n    }\n\n    public toString() {\n        return this.JSON();\n    }\n}\n", "import { elUniqId } from \"../utils/dom\";\nimport { camelize } from \"../utils/text\";\nimport { effect } from \"../vendored/preact-core\";\nimport { VERSION } from \"./consts\";\nimport { dsErr } from \"./errors\";\nimport { SignalsRoot } from \"./nestedSignals\";\nimport {\n    ActionPlugin,\n    ActionPlugins,\n    AttributePlugin,\n    DatastarPlugin,\n    GlobalInitializer,\n    HTMLorSVGElement,\n    MacroPlugin,\n    Modifiers,\n    OnRemovalFn,\n    PluginType,\n    RemovalEntry,\n    Requirement,\n    RuntimeContext,\n    RuntimeExpressionFunction,\n    WatcherPlugin,\n} from \"./types\";\n\nexport class Engine {\n    private _signals = new SignalsRoot();\n    private plugins: AttributePlugin[] = [];\n    private macros: MacroPlugin[] = [];\n    private actions: ActionPlugins = {};\n    private watchers: WatcherPlugin[] = [];\n    private removals = new Map<Element, RemovalEntry>();\n\n    get version() {\n        return VERSION;\n    }\n\n    public load(...pluginsToLoad: DatastarPlugin[]) {\n        pluginsToLoad.forEach((plugin) => {\n            let globalInitializer: GlobalInitializer | undefined;\n            switch (plugin.type) {\n                case PluginType.Macro:\n                    this.macros.push(plugin as MacroPlugin);\n                    break;\n                case PluginType.Watcher:\n                    const wp = plugin as WatcherPlugin;\n                    this.watchers.push(wp);\n                    globalInitializer = wp.onGlobalInit;\n                    break;\n                case PluginType.Action:\n                    this.actions[plugin.name] = plugin as ActionPlugin;\n                    break;\n                case PluginType.Attribute:\n                    const ap = plugin as AttributePlugin;\n                    this.plugins.push(ap);\n                    globalInitializer = ap.onGlobalInit;\n                    break;\n                default:\n                    throw dsErr(\"InvalidPluginType\", {\n                        name: plugin.name,\n                        type: plugin.type,\n                    });\n            }\n            if (globalInitializer) {\n                const that = this; // I hate javascript\n                globalInitializer({\n                    get signals() {\n                        return that._signals;\n                    },\n                    effect: (cb: () => void): OnRemovalFn => effect(cb),\n                    actions: this.actions,\n                    apply: this.apply.bind(this),\n                    cleanup: this.cleanup.bind(this),\n                });\n            }\n        });\n        this.apply(document.body);\n    }\n\n    // Clenup all plugins associated with the element\n    private cleanup(element: Element) {\n        const removalSet = this.removals.get(element);\n        if (removalSet) {\n            for (const removal of removalSet.set) {\n                removal();\n            }\n            this.removals.delete(element);\n        }\n    }\n\n    // Apply all plugins to the element and its children\n    public apply(rootElement: Element) {\n        const appliedMacros = new Set<MacroPlugin>();\n        this.plugins.forEach((p, pi) => {\n            this.walkDownDOM(rootElement, (el) => {\n                // Cleanup if not first plugin\n                if (!pi) this.cleanup(el);\n\n                for (const rawKey in el.dataset) {\n                    // Check if the key is relevant to the plugin\n                    if (!rawKey.startsWith(p.name)) continue;\n\n                    // Extract the key and value from the dataset\n                    const keyRaw = rawKey.slice(p.name.length);\n                    let [key, ...rawModifiers] = keyRaw.split(\":\");\n\n                    const hasKey = key.length > 0;\n                    if (hasKey) {\n                        key = key[0].toLowerCase() + key.slice(1);\n                    }\n                    const rawValue = `${el.dataset[rawKey]}` || \"\";\n                    let value = rawValue;\n                    const hasValue = value.length > 0;\n\n                    // Check the requirements\n                    const keyReq = p.keyReq || Requirement.Allowed;\n                    if (hasKey) {\n                        if (keyReq === Requirement.Denied) {\n                            throw dsErr(p.name + \"KeyNotAllowed\");\n                        }\n                    } else if (keyReq === Requirement.Must) {\n                        throw dsErr(p.name + \"KeyRequired\");\n                    }\n                    const valReq = p.valReq || Requirement.Allowed;\n                    if (hasValue) {\n                        if (valReq === Requirement.Denied) {\n                            throw dsErr(p.name + \"ValueNotAllowed\");\n                        }\n                    } else if (valReq === Requirement.Must) {\n                        throw dsErr(p.name + \"ValueRequired\");\n                    }\n\n                    // Check for exclusive requirements\n                    if (\n                        keyReq === Requirement.Exclusive ||\n                        valReq === Requirement.Exclusive\n                    ) {\n                        if (hasKey && hasValue) {\n                            throw dsErr(p.name + \"KeyAndValueProvided\");\n                        } else if (!hasKey && !hasValue) {\n                            throw dsErr(p.name + \"KeyOrValueRequired\");\n                        }\n                    }\n\n                    // Ensure the element has an id\n                    if (!el.id.length) el.id = elUniqId(el);\n\n                    // Apply the macros\n                    appliedMacros.clear();\n                    const mods: Modifiers = new Map<string, Set<string>>();\n                    rawModifiers.forEach((m) => {\n                        const [label, ...args] = m.split(\"_\");\n                        mods.set(camelize(label), new Set(args));\n                    });\n                    const macros = [\n                        ...(p.macros?.pre || []),\n                        ...this.macros,\n                        ...(p.macros?.post || []),\n                    ];\n                    for (const macro of macros) {\n                        if (appliedMacros.has(macro)) continue;\n                        appliedMacros.add(macro);\n                        value = macro.fn(value);\n                    }\n\n                    // Create the runtime context\n                    const { actions, apply, cleanup } = this;\n                    const that = this; // I hate javascript\n                    let ctx: RuntimeContext;\n                    ctx = {\n                        get signals() {\n                            return that._signals;\n                        },\n                        effect: (cb: () => void): OnRemovalFn => effect(cb),\n                        apply: apply.bind(this),\n                        cleanup: cleanup.bind(this),\n                        actions,\n                        genRX: () => this.genRX(ctx, ...p.argNames || []),\n                        el,\n                        rawKey,\n                        rawValue,\n                        key,\n                        value,\n                        mods,\n                    };\n\n                    // Load the plugin and store any cleanup functions\n                    const removal = p.onLoad(ctx);\n                    if (removal) {\n                        if (!this.removals.has(el)) {\n                            this.removals.set(el, {\n                                id: el.id,\n                                set: new Set(),\n                            });\n                        }\n                        this.removals.get(el)!.set.add(removal);\n                    }\n\n                    // Remove the attribute if required\n                    if (!!p?.removeOnLoad) delete el.dataset[rawKey];\n                }\n            });\n        });\n    }\n\n    private genRX(\n        ctx: RuntimeContext,\n        ...argNames: string[]\n    ): RuntimeExpressionFunction {\n        const stmts = ctx.value.split(/;|\\n/).map((s) => s.trim()).filter((s) =>\n            s != \"\"\n        );\n        const lastIdx = stmts.length - 1;\n        const last = stmts[lastIdx];\n        if (!last.startsWith(\"return\")) {\n            stmts[lastIdx] = `return (${stmts[lastIdx]});`;\n        }\n        const userExpression = stmts.join(\"\\n\");\n\n        const fnCall = /(\\w*)\\(/gm;\n        const matches = userExpression.matchAll(fnCall);\n        const methodsCalled = new Set<string>();\n        for (const match of matches) {\n            methodsCalled.add(match[1]);\n        }\n        // Action names\n        const an = Object.keys(this.actions).filter((i) =>\n            methodsCalled.has(i)\n        );\n        // Action lines\n        const al = an.map((a) => `const ${a} = ctx.actions.${a}.fn;`);\n        const fnContent = `${al.join(\"\\n\")}return (()=> {${userExpression}})()`;\n\n        // Add ctx to action calls\n        let fnWithCtx = fnContent.trim();\n        an.forEach((a) => {\n            fnWithCtx = fnWithCtx.replaceAll(a + \"(\", a + \"(ctx,\");\n        });\n\n        try {\n            const argumentNames = argNames || [];\n            const fn = new Function(\"ctx\", ...argumentNames, fnWithCtx);\n            return (...args: any[]) => fn(ctx, ...args);\n        } catch (error) {\n            throw dsErr(\"GeneratingExpressionFailed\", {\n                error,\n                fnContent,\n            });\n        }\n    }\n\n    private walkDownDOM(\n        element: Element | null,\n        callback: (el: HTMLorSVGElement) => void,\n    ) {\n        if (\n            !element ||\n            !(element instanceof HTMLElement || element instanceof SVGElement)\n        ) return null;\n        callback(element);\n        element = element.firstElementChild;\n        while (element) {\n            this.walkDownDOM(element, callback);\n            element = element.nextElementSibling;\n        }\n    }\n}\n", "import { Computed } from \"../plugins/official/core/attributes/computed\";\nimport { Signals } from \"../plugins/official/core/attributes/signals\";\nimport { Star } from \"../plugins/official/core/attributes/star\";\nimport { SignalValueMacro } from \"../plugins/official/core/macros/signals\";\nimport { Engine } from \"./engine\";\n\nconst ds = new Engine();\nds.load(\n    Star,\n    SignalValueMacro,\n    Signals,\n    Computed,\n);\nexport const Datastar = ds;\n", "import { Datastar } from \"../engine\";\n\nDatastar.load();\n"],
  "mappings": "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",
  "names": ["name", "Computed", "key", "signals", "genRX", "rx", "camelize", "str", "word", "index", "jsStrToObject", "raw", "Signals", "ctx", "key", "genRX", "signals", "obj", "jsStrToObject", "Star", "SignalValueMacro", "original", "validJS", "DATASTAR", "VERSION", "FragmentMergeModes", "DefaultFragmentMergeMode", "elUniqId", "el", "hash", "hashUpdate", "n", "hashUpdateFromStr", "str", "c", "i", "e", "DATASTAR", "url", "dsErr", "code", "args", "e", "fullURL", "url", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "dsErr", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "dsErr", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "dsErr", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "error", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "walkNestedSignal", "cb", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "dotDelimitedPath", "parts", "subSignals", "i", "part", "last", "signal", "dsErr", "fn", "computed", "value", "current", "Signal", "dotDelimitedPaths", "path", "other", "onlyIfMissing", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "onlyPublic", "nestedValues", "shouldIndent", "values", "Engine", "SignalsRoot", "VERSION", "pluginsToLoad", "plugin", "globalInitializer", "wp", "ap", "dsErr", "that", "cb", "effect", "element", "removalSet", "removal", "rootElement", "appliedMacros", "p", "pi", "el", "rawKey", "keyRaw", "key", "rawModifiers", "hasKey", "rawValue", "value", "hasValue", "keyReq", "valReq", "elUniqId", "mods", "m", "label", "args", "camelize", "macros", "macro", "actions", "apply", "cleanup", "ctx", "argNames", "stmts", "s", "lastIdx", "userExpression", "fnCall", "matches", "methodsCalled", "match", "an", "i", "fnContent", "a", "fnWithCtx", "argumentNames", "fn", "error", "callback", "ds", "Engine", "Star", "SignalValueMacro", "Signals", "Computed", "Datastar", "Datastar"]
}
