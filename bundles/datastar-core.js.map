{
  "version": 3,
  "sources": ["../code/ts/library/src/engine/consts.ts", "../code/ts/library/src/engine/errors.ts", "../code/ts/library/src/vendored/fetch-event-source/parse.ts", "../code/ts/library/src/vendored/fetch-event-source/fetch.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseShared.ts", "../code/ts/library/src/plugins/official/actions/backend/sseShared.ts", "../code/ts/library/src/plugins/official/actions/backend/sseDelete.ts", "../code/ts/library/src/plugins/official/actions/backend/sseGet.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePatch.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePost.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePut.ts", "../code/ts/library/src/plugins/official/actions/dom/clipboard.ts", "../code/ts/library/src/plugins/official/actions/logic/increment.ts", "../code/ts/library/src/plugins/official/actions/logic/setAll.ts", "../code/ts/library/src/plugins/official/actions/logic/toggleAll.ts", "../code/ts/library/src/plugins/official/actions/math/clampFit.ts", "../code/ts/library/src/plugins/official/actions/math/clampFitInt.ts", "../code/ts/library/src/plugins/official/actions/math/fit.ts", "../code/ts/library/src/plugins/official/actions/math/fitInt.ts", "../code/ts/library/src/plugins/official/attributes/backend/indicator.ts", "../code/ts/library/src/plugins/official/attributes/core/computed.ts", "../code/ts/library/src/plugins/official/attributes/core/mergeSignals.ts", "../code/ts/library/src/plugins/official/attributes/core/star.ts", "../code/ts/library/src/utils/text.ts", "../code/ts/library/src/plugins/official/attributes/dom/bind.ts", "../code/ts/library/src/plugins/official/attributes/dom/class.ts", "../code/ts/library/src/utils/arguments.ts", "../code/ts/library/src/utils/timing.ts", "../code/ts/library/src/plugins/official/attributes/dom/on.ts", "../code/ts/library/src/plugins/official/attributes/dom/ref.ts", "../code/ts/library/src/plugins/official/attributes/dom/text.ts", "../code/ts/library/src/plugins/official/attributes/storage/persist.ts", "../code/ts/library/src/plugins/official/attributes/url/replaceUrl.ts", "../code/ts/library/src/plugins/official/attributes/visibility/intersects.ts", "../code/ts/library/src/utils/dom.ts", "../code/ts/library/src/plugins/official/attributes/visibility/scrollIntoView.ts", "../code/ts/library/src/plugins/official/attributes/visibility/show.ts", "../code/ts/library/src/utils/view-transitions.ts", "../code/ts/library/src/plugins/official/attributes/visibility/viewTransition.ts", "../code/ts/library/src/plugins/official/macros/core/index.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseExecuteScript.ts", "../code/ts/library/src/vendored/idiomorph.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseMergeFragment.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseMergeSignals.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseRemoveFragments.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseRemoveSignals.ts", "../code/ts/library/src/vendored/preact-core.ts", "../code/ts/library/src/engine/nestedSignals.ts", "../code/ts/library/src/engine/version.ts", "../code/ts/library/src/engine/engine.ts", "../code/ts/library/src/engine/index.ts", "../code/ts/library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\nexport const VERSION = \"0.20.1\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during merges. Allows for CSS transitions to complete.\nexport const settleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const sseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of of key-value pairs delimited by a newline \\\\n character.\nexport const executeScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const fragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const mergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const executeScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const fragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import { DATASTAR } from \"./consts\";\n\nconst err = (code: number) => {\n    const e = new Error();\n    e.name = `${DATASTAR}${code}`;\n    return e;\n};\n\nexport const ERR_BAD_ARGS = err(400);\nexport const ERR_ALREADY_EXISTS = err(409);\nexport const ERR_NOT_FOUND = err(404);\nexport const ERR_NOT_ALLOWED = err(403);\nexport const ERR_METHOD_NOT_ALLOWED = err(405);\nexport const ERR_SERVICE_UNAVAILABLE = err(503);\n", "/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n    /** The event ID to set the EventSource object's last event ID value. */\n    id: string;\n    /** A string identifying the type of event described. */\n    event: string;\n    /** The event data */\n    data: string;\n    /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n    retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n    stream: ReadableStream<Uint8Array>,\n    onChunk: (arr: Uint8Array) => void,\n) {\n    const reader = stream.getReader();\n    let result: ReadableStreamReadResult<Uint8Array>;\n    while (!(result = await reader.read()).done) {\n        onChunk(result.value);\n    }\n}\n\nconst enum ControlChars {\n    NewLine = 10,\n    CarriageReturn = 13,\n    Space = 32,\n    Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n    onLine: (line: Uint8Array, fieldLength: number) => void,\n) {\n    let buffer: Uint8Array | undefined;\n    let position: number; // current read position\n    let fieldLength: number; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr: Uint8Array) {\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        } else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === ControlChars.NewLine) {\n                    lineStart = ++position; // skip to next char\n                }\n\n                discardTrailingNewline = false;\n            }\n\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case ControlChars.Colon:\n                        if (fieldLength === -1) { // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case ControlChars.CarriageReturn:\n                        discardTrailingNewline = true;\n                    case ControlChars.NewLine:\n                        lineEnd = position;\n                        break;\n                }\n            }\n\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        } else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n    onId: (id: string) => void,\n    onRetry: (retry: number) => void,\n    onMessage?: (msg: EventSourceMessage) => void,\n) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n\n    // return a function that can process each incoming line buffer:\n    return function onLine(line: Uint8Array, fieldLength: number) {\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        } else if (fieldLength > 0) { // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength +\n                (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data\n                        ? message.data + \"\\n\" + value\n                        : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId(message.id = value);\n                    break;\n                case \"retry\":\n                    const retry = parseInt(value, 10);\n                    if (!isNaN(retry)) { // per spec, ignore non-integers\n                        onRetry(message.retry = retry);\n                    }\n                    break;\n            }\n        }\n    };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\n", "import { ERR_SERVICE_UNAVAILABLE } from \"../../engine/errors\";\nimport { EventSourceMessage, getBytes, getLines, getMessages } from \"./parse\";\n\nexport const EventStreamContentType = \"text/event-stream\";\n\nconst DefaultRetryInterval = 1000;\nconst LastEventId = \"last-event-id\";\n\nexport interface FetchEventSourceInit extends RequestInit {\n    /**\n     * The request headers. FetchEventSource only supports the Record<string,string> format.\n     */\n    headers?: Record<string, string>;\n\n    /**\n     * Called when a response is received. Use this to validate that the response\n     * actually matches what you expect (and throw if it doesn't.) If not provided,\n     * will default to a basic validation to ensure the content-type is text/event-stream.\n     */\n    onopen?: (response: Response) => Promise<void>;\n\n    /**\n     * Called when a message is received. NOTE: Unlike the default browser\n     * EventSource.onmessage, this callback is called for _all_ events,\n     * even ones with a custom `event` field.\n     */\n    onmessage?: (ev: EventSourceMessage) => void;\n\n    /**\n     * Called when a response finishes. If you don't expect the server to kill\n     * the connection, you can throw an exception here and retry using onerror.\n     */\n    onclose?: () => void;\n\n    /**\n     * Called when there is any error making the request / processing messages /\n     * handling callbacks etc. Use this to control the retry strategy: if the\n     * error is fatal, rethrow the error inside the callback to stop the entire\n     * operation. Otherwise, you can return an interval (in milliseconds) after\n     * which the request will automatically retry (with the last-event-id).\n     * If this callback is not specified, or it returns undefined, fetchEventSource\n     * will treat every error as retriable and will try again after 1 second.\n     */\n    onerror?: (err: any) => number | null | undefined | void;\n\n    /**\n     * If true, will keep the request open even if the document is hidden.\n     * By default, fetchEventSource will close the request and reopen it\n     * automatically when the document becomes visible again.\n     */\n    openWhenHidden?: boolean;\n\n    /** The Fetch function to use. Defaults to window.fetch */\n    fetch?: typeof fetch;\n\n    /** The scaler for the retry interval. Defaults to 2 */\n    retryScaler?: number;\n\n    /** The maximum retry interval in milliseconds. Defaults to 30_000 */\n    retryMaxWaitMs?: number;\n\n    /** The maximum number of retries before giving up. Defaults to 10 */\n    retryMaxCount?: number;\n}\n\nexport function fetchEventSource(input: RequestInfo, {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    ...rest\n}: FetchEventSourceInit) {\n    return new Promise<void>((resolve, reject) => {\n        let retries = 0;\n\n        // make a copy of the input headers since we may modify it below:\n        const headers = { ...inputHeaders };\n        if (!headers.accept) {\n            headers.accept = EventStreamContentType;\n        }\n\n        let curRequestController: AbortController;\n        function onVisibilityChange() {\n            curRequestController.abort(); // close existing request on every visibility change\n            if (!document.hidden) {\n                create(); // page is now visible again, recreate request.\n            }\n        }\n\n        if (!openWhenHidden) {\n            document.addEventListener(\"visibilitychange\", onVisibilityChange);\n        }\n\n        let retryInterval = DefaultRetryInterval;\n        let retryTimer = 0;\n        function dispose() {\n            document.removeEventListener(\n                \"visibilitychange\",\n                onVisibilityChange,\n            );\n            window.clearTimeout(retryTimer);\n            curRequestController.abort();\n        }\n\n        // if the incoming signal aborts, dispose resources and resolve:\n        inputSignal?.addEventListener(\"abort\", () => {\n            dispose();\n            resolve(); // don't waste time constructing/logging errors\n        });\n\n        const fetch = inputFetch ?? window.fetch;\n        const onopen = inputOnOpen ??\n            function defaultOnOpen(\n                // response: Response\n            ) {};\n\n        async function create() {\n            curRequestController = new AbortController();\n            try {\n                const response = await fetch(input, {\n                    ...rest,\n                    headers,\n                    signal: curRequestController.signal,\n                });\n\n                await onopen(response);\n\n                await getBytes(\n                    response.body!,\n                    getLines(getMessages((id) => {\n                        if (id) {\n                            // signals the id and send it back on the next retry:\n                            headers[LastEventId] = id;\n                        } else {\n                            // don't send the last-event-id header anymore:\n                            delete headers[LastEventId];\n                        }\n                    }, (retry) => {\n                        retryInterval = retry;\n                    }, onmessage)),\n                );\n\n                onclose?.();\n                dispose();\n                resolve();\n            } catch (err) {\n                if (!curRequestController.signal.aborted) {\n                    // if we haven't aborted the request ourselves:\n                    try {\n                        // check if we need to retry:\n                        const interval: any = onerror?.(err) ?? retryInterval;\n                        window.clearTimeout(retryTimer);\n                        retryTimer = window.setTimeout(create, interval);\n                        retryInterval *= retryScaler; // exponential backoff\n                        retryInterval = Math.min(retryInterval, retryMaxWaitMs);\n                        retries++;\n                        if (retries >= retryMaxCount) {\n                            // we should not retry anymore:\n                            dispose();\n                            // Max retries hit, check your server or network connection\n                            reject(ERR_SERVICE_UNAVAILABLE);\n                        } else {\n                            console.error(\n                                `Datastar failed to reach ${rest.method}:${input.toString()} retry in ${interval}ms`,\n                            );\n                        }\n                    } catch (innerErr) {\n                        // we should not retry anymore:\n                        dispose();\n                        reject(innerErr);\n                    }\n                }\n            }\n        }\n\n        create();\n    });\n}\n", "import { DATASTAR } from \"../../../../engine/consts\";\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`;\nexport const SETTLING_CLASS = `${DATASTAR}-settling`;\nexport const SWAPPING_CLASS = `${DATASTAR}-swapping`;\nexport const STARTED = \"started\";\nexport const FINISHED = \"finished\";\n\nexport interface DatastarSSEEvent {\n    type: string;\n    argsRaw: Record<string, string>;\n}\n\nexport interface CustomEventMap {\n    \"datastar-sse\": CustomEvent<DatastarSSEEvent>;\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n    this: Document,\n    ev: CustomEventMap[K],\n) => void;\n\ndeclare global {\n    interface Document { //adds definition to Document, but you can do the same with HTMLElement\n        addEventListener<K extends keyof CustomEventMap>(\n            type: K,\n            listener: WatcherFn<K>,\n        ): void;\n        removeEventListener<K extends keyof CustomEventMap>(\n            type: K,\n            listener: WatcherFn<K>,\n        ): void;\n        dispatchEvent<K extends keyof CustomEventMap>(\n            ev: CustomEventMap[K],\n        ): void;\n    }\n}\n\nexport function datastarSSEEventWatcher(\n    // ctx: InitContext,\n    eventType: string,\n    fn: (argsRaw: Record<string, string>) => void,\n) {\n    document.addEventListener(\n        DATASTAR_SSE_EVENT,\n        (event: CustomEvent<DatastarSSEEvent>) => {\n            if (event.detail.type != eventType) return;\n            const { argsRaw } = event.detail;\n            fn(argsRaw);\n        },\n    );\n}\n", "import { ActionMethod } from \"../../../../engine\";\nimport { DATASTAR, DATASTAR_REQUEST } from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport {\n  fetchEventSource,\n  FetchEventSourceInit,\n} from \"../../../../vendored/fetch-event-source\";\nimport {\n  DATASTAR_SSE_EVENT,\n  DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from \"../../watchers/backend/sseShared\";\n\nexport type IndicatorReference = { el: HTMLElement; count: number };\n\nconst isWrongContent = (err: any) => `${err}`.includes(`text/event-stream`);\n\nexport type SSERequestArgs = {\n  onlyRemoteSignals?: boolean;\n  headers?: Record<string, string>;\n};\n\nfunction dispatchSSE(type: string, argsRaw: Record<string, string>) {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, argsRaw },\n    }),\n  );\n}\n\nexport function sendSSERequest(method: string): ActionMethod {\n  return async (ctx, url, args?: SSERequestArgs) => {\n    if (!!!url?.length) throw ERR_BAD_ARGS;\n\n    const onlyRemoteSignals = args?.onlyRemoteSignals ?? true;\n    const headers = Object.assign(\n      {\n        \"Content-Type\": \"application/json\",\n        [DATASTAR_REQUEST]: true,\n      },\n      args?.headers,\n    );\n    const { signals, el: { id: elID } } = ctx;\n    const signalsJSON = signals.JSON(false, onlyRemoteSignals);\n\n    dispatchSSE(STARTED, { elID });\n\n    const urlInstance = new URL(url, window.location.origin);\n\n    // https://fetch.spec.whatwg.org/#concept-method-normalize\n    method = method.toUpperCase();\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) {\n          return;\n        }\n        const type = evt.event;\n        const argsRawLines: Record<string, string[]> = {};\n\n        const lines = evt.data.split(\"\\n\");\n        for (const line of lines) {\n          const colonIndex = line.indexOf(\" \");\n          const key = line.slice(0, colonIndex);\n          let argLines = argsRawLines[key];\n          if (!argLines) {\n            argLines = [];\n            argsRawLines[key] = argLines;\n          }\n          const value = line.slice(colonIndex + 1).trim();\n          argLines.push(value);\n        }\n\n        const argsRaw: Record<string, string> = {};\n        for (const [key, lines] of Object.entries(argsRawLines)) {\n          argsRaw[key] = lines.join(\"\\n\");\n        }\n\n        // if you aren't seeing your event you can debug by using this line in the console\n        // document.addEventListener(\"datastar-sse\",(e) => console.log(e));\n        dispatchSSE(type, argsRaw);\n      },\n      onerror: (err) => {\n        if (isWrongContent(err)) {\n          // don't retry if the content-type is wrong\n          throw err;\n        }\n        // do nothing and it will retry\n        if (err) {\n          console.error(err.message);\n        }\n      },\n      onclose: () => {\n        dispatchSSE(FINISHED, { elID });\n      },\n    };\n\n    if (method === \"GET\") {\n      const queryParams = new URLSearchParams(urlInstance.search);\n      queryParams.append(DATASTAR, signalsJSON);\n      urlInstance.search = queryParams.toString();\n    } else {\n      req.body = signalsJSON;\n    }\n\n    try {\n      const revisedURL = urlInstance.toString();\n      await fetchEventSource(revisedURL, req);\n    } catch (err) {\n      if (!isWrongContent(err)) {\n        throw err;\n      }\n\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven't\n      // set the content-type to text/event-stream\n    }\n  };\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:delete\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const DeleteSSE: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"delete\",\n  fn: sendSSERequest(\"delete\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const GetSSE: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"get\",\n  fn: sendSSERequest(\"get\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:bandage\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PatchSSE: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"patch\",\n  fn: sendSSERequest(\"patch\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:add\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PostSSE: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"post\",\n  fn: sendSSERequest(\"post\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:find-replace\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PutSSE: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"put\",\n  fn: sendSSERequest(\"put\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:clipboard\n// Slug: Copy text to the clipboard\n// Description: This action copies text to the clipboard using the Clipboard API.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { ERR_NOT_ALLOWED } from \"../../../../engine/errors\";\n\nexport const Clipboard: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"clipboard\",\n  fn: (_, text) => {\n    if (!navigator.clipboard) {\n      // Clipboard API not available\n      throw ERR_NOT_ALLOWED;\n    }\n    navigator.clipboard.writeText(text);\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const Increment: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"increment\",\n  fn: (ctx, singalKeyPath, delta) => {\n    const signal = ctx.signals.upsert(singalKeyPath, 0);\n    signal.value += delta;\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const SetAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"setAll\",\n  fn: (ctx, regexp, newValue) => {\n    const re = new RegExp(regexp);\n    ctx.signals.walk(\n      (name, signal) => re.test(name) && (signal.value = newValue)\n    );\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const ToggleAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"toggleAll\",\n  fn: (ctx, regexp) => {\n    const re = new RegExp(regexp);\n    ctx.signals.walk(\n      (name, signal) => re.test(name) && (signal.value = !signal.value)\n    );\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen-outline\n// Slug: Clamp a value to a new range\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const ClampFit: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"clampFit\",\n  fn: (\n    _: AttributeContext,\n    v: number,\n    oldMin: number,\n    oldMax: number,\n    newMin: number,\n    newMax: number\n  ) => {\n    return Math.max(\n      newMin,\n      Math.min(\n        newMax,\n        ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin\n      )\n    );\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen\n// Slug: Clamp a value to a new range and round to the nearest integer\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range. The result is then rounded to the nearest integer.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const ClampFitInt: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"clampFitInt\",\n  fn: (\n    _: AttributeContext,\n    v: number,\n    oldMin: number,\n    oldMax: number,\n    newMin: number,\n    newMax: number\n  ) => {\n    return Math.round(\n      Math.max(\n        newMin,\n        Math.min(\n          newMax,\n          ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin\n        )\n      )\n    );\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols-light:fit-width\n// Slug: Linearly fit a value to a new range\n// Description: This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const Fit: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"fit\",\n  fn: (\n    _: AttributeContext,\n    v: number,\n    oldMin: number,\n    oldMax: number,\n    newMin: number,\n    newMax: number\n  ) => {\n    return ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin;\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-width\n// Slug: Linearly fit a value to a new range and round to the nearest integer\n// Description: This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const FitInt: ActionPlugin = {\n  type: PluginType.Action,\n  name: \"fitInt\",\n  fn: (\n    _: AttributeContext,\n    v: number,\n    oldMin: number,\n    oldMax: number,\n    newMin: number,\n    newMax: number\n  ) => {\n    return Math.round(\n      ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin\n    );\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { DATASTAR } from \"../../../../engine/consts\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport {\n  DATASTAR_SSE_EVENT,\n  DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from \"../../watchers/backend/sseShared\";\n\nexport const INDICATOR_CLASS = `${DATASTAR}-indicator`;\nexport const INDICATOR_LOADING_CLASS = `${INDICATOR_CLASS}-loading`;\n\nexport const Indicator: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"indicator\",\n  noKey: true,\n  onLoad: (ctx) => {\n    const { value, signals, el } = ctx;\n    const signal = signals.upsert(value, false);\n\n    const watcher = (event: CustomEvent<DatastarSSEEvent>) => {\n      const {\n        type,\n        argsRaw: { elID },\n      } = event.detail;\n      if (elID !== el.id) return;\n      switch (type) {\n        case STARTED:\n          signal.value = true;\n          break;\n        case FINISHED:\n          signal.value = false;\n          break;\n      }\n    };\n\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher);\n\n    return () => {\n      document.removeEventListener(DATASTAR_SSE_EVENT, watcher);\n    };\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: fluent:draw-text-24-filled\n// Slug: Create a computed signal\n// Description: This attribute creates a computed signal that updates when its dependencies change.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { Computed as ComputedType } from \"../../../../vendored\";\n\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"computed\",\n  mustKey: true,\n  onLoad: (ctx) => {\n    const {\n      signals,\n      key,\n      expr,\n      reactivity: { computed },\n    } = ctx;\n\n    const c = computed(() => {\n      return expr(ctx);\n    }) as ComputedType;\n    signals.add(key, c);\n\n    return () => {\n      signals.remove(key);\n    };\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:home-storage\n// Slug: Merge signals into a singleton per page\n// Description: This action signalss signals into a singleton per page. This is useful for storing signals that are used across multiple components.\n\nimport {\n  AttributeContext,\n  AttributePlugin,\n  NestedValues,\n} from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nconst IF_MISSING = \"ifmissing\";\n\n// Merge into singleton signals\nexport const MergeSignals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"mergeSignals\",\n  onlyMods: new Set([IF_MISSING]),\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expr, mods } = ctx;\n    const possibleMergeValues: NestedValues = expr(ctx);\n    ctx.signals.merge(possibleMergeValues, mods.has(IF_MISSING));\n    delete el.dataset[ctx.rawKey];\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:rocket\n// Slug: Star\n// Description: Sage advice for the weary traveler\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const Star: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"star\",\n    onLoad: () => {\n        alert(\"YOU ARE PROBABLY OVERCOMPLICATING IT\");\n    },\n};\n", "export const kebabize = (str: string) =>\n    str.replace(\n        /[A-Z]+(?![a-z])|[A-Z]/g,\n        ($, ofs) => (ofs ? \"-\" : \"\") + $.toLowerCase(),\n    );\n\nexport const isBoolString = (str: string) => str.trim() === \"true\";\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport {\n  ERR_BAD_ARGS,\n  ERR_METHOD_NOT_ALLOWED,\n} from \"../../../../engine/errors\";\nimport { kebabize } from \"../../../../utils/text\";\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/;\nconst updateModelEvents = [\"change\", \"input\", \"keydown\"];\n\nexport const Bind: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"bind\",\n  onLoad: (ctx) => {\n    const {\n      el,\n      value,\n      expr,\n      key,\n      signals,\n      reactivity: { effect },\n    } = ctx;\n\n    let setFromSignal = () => {};\n    let fromElementToSignal = () => {};\n\n    const isTwoWayBinding = key === \"\";\n\n    if (isTwoWayBinding) {\n      const signalName = value;\n\n      // I better be tied to a signal\n      if (typeof signalName !== \"string\") {\n        throw new Error(\"Invalid expression\");\n      }\n      if (signalName.includes(\"$\")) {\n        throw new Error(\"Not an expression\");\n      }\n\n      const tnl = el.tagName.toLowerCase();\n      let signalDefault: string | boolean | number | File = \"\";\n      const isInput = tnl.includes(\"input\");\n      const type = el.getAttribute(\"type\");\n      const isCheckbox =\n        tnl.includes(\"checkbox\") || (isInput && type === \"checkbox\");\n      if (isCheckbox) {\n        signalDefault = false;\n      }\n      const isNumber = isInput && type === \"number\";\n      if (isNumber) {\n        signalDefault = 0;\n      }\n      const isSelect = tnl.includes(\"select\");\n      const isRadio = tnl.includes(\"radio\") || (isInput && type === \"radio\");\n      const isFile = isInput && type === \"file\";\n      if (isFile) {\n        // can't set a default value for a file input, yet\n      }\n      if (isRadio) {\n        const name = el.getAttribute(\"name\");\n        if (!name?.length) {\n          el.setAttribute(\"name\", signalName);\n        }\n      }\n\n      signals.upsert(signalName, signalDefault);\n\n      setFromSignal = () => {\n        const hasValue = \"value\" in el;\n        const v = signals.value(signalName);\n        const vStr = `${v}`;\n        if (isCheckbox || isRadio) {\n          const input = el as HTMLInputElement;\n          if (isCheckbox) {\n            input.checked = !!!v || v === \"true\";\n          } else if (isRadio) {\n            // evaluate the value as string to handle any type casting\n            // automatically since the attribute has to be a string anyways\n            input.checked = vStr === input.value;\n          }\n        } else if (isFile) {\n          // File input reading from a signal is not supported yet\n        } else if (isSelect) {\n          const select = el as HTMLSelectElement;\n          if (select.multiple) {\n            Array.from(select.options).forEach((opt) => {\n              if (opt?.disabled) return;\n              if (Array.isArray(v) || typeof v === \"string\") {\n                opt.selected = v.includes(opt.value);\n              } else if (typeof v === \"number\") {\n                opt.selected = v === Number(opt.value);\n              } else {\n                opt.selected = v as boolean;\n              }\n            });\n          } else {\n            select.value = vStr;\n          }\n        } else if (hasValue) {\n          el.value = vStr;\n        } else {\n          el.setAttribute(\"value\", vStr);\n        }\n      };\n\n      fromElementToSignal = async () => {\n        if (isFile) {\n          const files = [...((el as HTMLInputElement)?.files || [])],\n            allContents: string[] = [],\n            allMimes: string[] = [],\n            allNames: string[] = [];\n\n          await Promise.all(\n            files.map((f) => {\n              return new Promise<void>((resolve) => {\n                const reader = new FileReader();\n                reader.onload = () => {\n                  if (typeof reader.result !== \"string\") {\n                    // console.error(`Invalid result type: ${typeof reader.result}`);\n                    throw ERR_BAD_ARGS;\n                  }\n                  const match = reader.result.match(dataURIRegex);\n                  if (!match?.groups) {\n                    // console.error(`Invalid data URI: ${reader.result}`);\n                    throw ERR_BAD_ARGS;\n                  }\n                  allContents.push(match.groups.contents);\n                  allMimes.push(match.groups.mime);\n                  allNames.push(f.name);\n                };\n                reader.onloadend = () => resolve(void 0);\n                reader.readAsDataURL(f);\n              });\n            })\n          );\n\n          signals.set(signalName, allContents);\n          const mimeName = `${signalName}Mimes`,\n            nameName = `${signalName}Names`;\n          if (mimeName in signals) {\n            signals.upsert(mimeName, allMimes);\n          }\n          if (nameName in signals) {\n            signals.upsert(nameName, allNames);\n          }\n          return;\n        }\n\n        const current = signals.value(signalName);\n        const input = (el as HTMLInputElement) || (el as HTMLElement);\n\n        if (typeof current === \"number\") {\n          const v = Number(input.value || input.getAttribute(\"value\"));\n          signals.set(signalName, v);\n        } else if (typeof current === \"string\") {\n          const v = input.value || input.getAttribute(\"value\") || \"\";\n          signals.set(signalName, v);\n        } else if (typeof current === \"boolean\") {\n          if (isCheckbox) {\n            const v = input.checked || input.getAttribute(\"checked\") === \"true\";\n            signals.set(signalName, v);\n          } else {\n            const v = Boolean(input.value || input.getAttribute(\"value\"));\n            signals.set(signalName, v);\n          }\n        } else if (typeof current === \"undefined\") {\n        } else if (Array.isArray(current)) {\n          // check if the input is a select element\n          if (isSelect) {\n            const select = el as HTMLSelectElement;\n            const selectedOptions = [...select.selectedOptions];\n            const selectedValues = selectedOptions\n              .filter((opt) => opt.selected)\n              .map((opt) => opt.value);\n            signals.set(signalName, selectedValues);\n          } else {\n            // assume it's a comma-separated string\n            const v = JSON.stringify(input.value.split(\",\"));\n            signals.set(signalName, v);\n          }\n          console.log(input.value);\n        } else {\n          // console.log(`Unsupported type ${typeof current}`);\n          throw ERR_METHOD_NOT_ALLOWED;\n        }\n      };\n    } else {\n      // tied to an attribute\n      const kebabKey = kebabize(key);\n      setFromSignal = () => {\n        const value = expr(ctx);\n        let v: string;\n        if (typeof value === \"string\") {\n          v = value;\n        } else {\n          v = JSON.stringify(value);\n        }\n        if (!v || v === \"false\" || v === \"null\" || v === \"undefined\") {\n          el.removeAttribute(kebabKey);\n        } else {\n          el.setAttribute(kebabKey, v);\n        }\n      };\n    }\n\n    if (isTwoWayBinding) {\n      updateModelEvents.forEach((event) => {\n        el.addEventListener(event, fromElementToSignal);\n      });\n    }\n\n    const setElementFromSignalDisposer = effect(async () => {\n      setFromSignal();\n    });\n\n    return () => {\n      setElementFromSignalDisposer();\n\n      if (isTwoWayBinding) {\n        updateModelEvents.forEach((event) => {\n          el.removeEventListener(event, fromElementToSignal);\n        });\n      }\n    };\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const Class: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"class\",\n  noKey: true,\n  mustValue: true,\n\n  onLoad: (ctx) => {\n    return ctx.reactivity.effect(() => {\n      const classes: Object = ctx.expr(ctx);\n      for (const [k, v] of Object.entries(classes)) {\n        const classNames = k.split(\" \");\n        if (v) {\n          ctx.el.classList.add(...classNames);\n        } else {\n          ctx.el.classList.remove(...classNames);\n        }\n      }\n    });\n  },\n};\n", "export function argsToMs(args: string[] | undefined) {\n    if (!args || args?.length === 0) return 0;\n\n    for (const arg of args) {\n        if (arg.endsWith(\"ms\")) {\n            return Number(arg.replace(\"ms\", \"\"));\n        } else if (arg.endsWith(\"s\")) {\n            return Number(arg.replace(\"s\", \"\")) * 1000;\n        }\n\n        try {\n            return parseFloat(arg);\n        } catch (e) {}\n    }\n\n    return 0;\n}\n\nexport function argsHas(\n    args: string[] | undefined,\n    arg: string,\n    defaultValue = false,\n) {\n    if (!args) return false;\n    return args.includes(arg) || defaultValue;\n}\n", "export type TimerHandler = (...args: any[]) => void;\n\nexport function debounce(\n    callback: TimerHandler,\n    wait: number,\n    leading = false,\n    trailing = true,\n): TimerHandler {\n    let timer = -1;\n\n    const resetTimer = () => timer && clearTimeout(timer);\n\n    return function wrapper(...args: any[]) {\n        resetTimer();\n\n        if (leading && !timer) {\n            callback(...args);\n        }\n\n        timer = setTimeout(() => {\n            if (trailing) {\n                callback(...args);\n            }\n            resetTimer();\n        }, wait);\n    };\n}\n\nexport function throttle(\n    callback: TimerHandler,\n    wait: number,\n    leading = true,\n    trailing = false,\n): TimerHandler {\n    let waiting = false;\n\n    return function wrapper(...args: any[]) {\n        if (waiting) return;\n\n        if (leading) {\n            callback(...args);\n        }\n\n        waiting = true;\n        setTimeout(() => {\n            waiting = false;\n            if (trailing) {\n                callback(...args);\n            }\n        }, wait);\n    };\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This action adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { argsHas, argsToMs } from \"../../../../utils/arguments\";\nimport { kebabize } from \"../../../../utils/text\";\nimport { debounce, throttle } from \"../../../../utils/timing\";\n\nconst knownOnModifiers = new Set([\n  \"window\",\n  \"once\",\n  \"passive\",\n  \"capture\",\n  \"debounce\",\n  \"throttle\",\n  \"remote\",\n  \"outside\",\n]);\n\nlet lastSignalsMarshalled = \"\";\n\n// Sets the event listener of the element\nexport const On: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"on\",\n  mustKey: true,\n  mustValue: true,\n  argNames: [\"evt\"],\n  onLoad: (ctx) => {\n    const { el, key, expr } = ctx;\n\n    let target: Element | Window | Document = ctx.el;\n    if (ctx.mods.get(\"window\")) {\n      target = window;\n    }\n\n    let callback = (evt?: Event) => {\n      expr(ctx, evt);\n    };\n\n    const debounceArgs = ctx.mods.get(\"debounce\");\n    if (debounceArgs) {\n      const wait = argsToMs(debounceArgs);\n      const leading = argsHas(debounceArgs, \"leading\", false);\n      const trailing = argsHas(debounceArgs, \"noTrail\", true);\n      callback = debounce(callback, wait, leading, trailing);\n    }\n\n    const throttleArgs = ctx.mods.get(\"throttle\");\n    if (throttleArgs) {\n      const wait = argsToMs(throttleArgs);\n      const leading = argsHas(throttleArgs, \"noLead\", true);\n      const trailing = argsHas(throttleArgs, \"noTrail\", false);\n      callback = throttle(callback, wait, leading, trailing);\n    }\n\n    const evtListOpts: AddEventListenerOptions = {\n      capture: true,\n      passive: false,\n      once: false,\n    };\n    if (!ctx.mods.has(\"capture\")) evtListOpts.capture = false;\n    if (ctx.mods.has(\"passive\")) evtListOpts.passive = true;\n    if (ctx.mods.has(\"once\")) evtListOpts.once = true;\n\n    const unknownModifierKeys = [...ctx.mods.keys()].filter(\n      (key) => !knownOnModifiers.has(key)\n    );\n\n    unknownModifierKeys.forEach((attrName) => {\n      const eventValues = ctx.mods.get(attrName) || [];\n      const cb = callback;\n      const revisedCallback = () => {\n        const evt = event as any;\n        const attr = evt[attrName];\n        let valid: boolean;\n\n        if (typeof attr === \"function\") {\n          valid = attr(...eventValues);\n        } else if (typeof attr === \"boolean\") {\n          valid = attr;\n        } else if (typeof attr === \"string\") {\n          const lowerAttr = attr.toLowerCase().trim();\n          const expr = eventValues.join(\"\").toLowerCase().trim();\n          valid = lowerAttr === expr;\n        } else {\n          // console.error(`Invalid value for ${attrName} modifier on ${key} on ${el}`);\n          throw ERR_BAD_ARGS;\n        }\n\n        if (valid) {\n          cb(evt);\n        }\n      };\n      callback = revisedCallback;\n    });\n\n    const eventName = kebabize(key).toLowerCase();\n    switch (eventName) {\n      case \"load\":\n        callback();\n        delete ctx.el.dataset.onLoad;\n        return () => {};\n\n      case \"raf\":\n        let rafId: number | undefined;\n        const raf = () => {\n          callback();\n          rafId = requestAnimationFrame(raf);\n        };\n        rafId = requestAnimationFrame(raf);\n\n        return () => {\n          if (rafId) cancelAnimationFrame(rafId);\n        };\n\n      case \"signals-change\":\n        return ctx.reactivity.effect(() => {\n          const onlyRemoteSignals = ctx.mods.has(\"remote\");\n          const current = ctx.signals.JSON(false, onlyRemoteSignals);\n          if (lastSignalsMarshalled !== current) {\n            lastSignalsMarshalled = current;\n            callback();\n          }\n        });\n\n      default:\n        const testOutside = ctx.mods.has(\"outside\");\n        if (testOutside) {\n          target = document;\n          const cb = callback;\n          let called = false;\n          const targetOutsideCallback = (e?: Event) => {\n            const targetHTML = e?.target as HTMLElement;\n            if (!targetHTML) return;\n            const isEl = el.id === targetHTML.id;\n            if (isEl && called) {\n              called = false;\n            }\n            if (!isEl && !called) {\n              cb(e);\n              called = true;\n            }\n          };\n          callback = targetOutsideCallback;\n        }\n\n        target.addEventListener(eventName, callback, evtListOpts);\n        return () => {\n          // console.log(`Removing event listener for ${eventName} on ${el}`)\n          target.removeEventListener(eventName, callback);\n        };\n    }\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"ref\",\n  noKey: true,\n  mustValue: true,\n  noGenExpr: () => true,\n  onLoad: ({ el, value, signals }) => {\n    signals.upsert(value, el);\n    return () => signals.remove(value);\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\n\nexport const Text: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"text\",\n  noKey: true,\n  onLoad: (ctx) => {\n    const {\n      el,\n      expr,\n      reactivity: { effect },\n    } = ctx;\n    if (!(el instanceof HTMLElement)) {\n      // Element is not HTMLElement\n      throw ERR_BAD_ARGS;\n    }\n    return effect(() => {\n      const res = expr(ctx);\n      el.textContent = `${res}`;\n    });\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:floppy-variant\n// Slug: Persist data to local storage or session storage\n// Description: This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { DATASTAR, DATASTAR_EVENT } from \"../../../../engine/consts\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { DatastarSSEEvent } from \"../../watchers/backend/sseShared\";\n\nconst SESSION = \"session\";\nconst LOCAL = \"local\";\nconst REMOTE = \"remote\";\n\nexport const Persist: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"persist\",\n  onlyMods: new Set([LOCAL, SESSION, REMOTE]),\n  onLoad: (ctx) => {\n    const { signals, expr } = ctx;\n    const key = ctx.key || DATASTAR;\n    const expression = ctx.value;\n    const keys = new Set<string>();\n\n    if (expression.trim() !== \"\") {\n      const value = expr(ctx);\n      const parts = value.split(\" \");\n      for (const part of parts) {\n        keys.add(part);\n      }\n    }\n\n    let lastMarshalled = \"\";\n    const storageType = ctx.mods.has(SESSION) ? SESSION : LOCAL;\n    const useRemote = ctx.mods.has(REMOTE);\n\n    const signalsUpdateHandler = ((_: CustomEvent<DatastarSSEEvent>) => {\n      const marshalled = signals.subset(...keys).JSON(false, useRemote);\n\n      if (marshalled === lastMarshalled) {\n        return;\n      }\n\n      if (storageType === SESSION) {\n        window.sessionStorage.setItem(key, marshalled);\n      } else {\n        window.localStorage.setItem(key, marshalled);\n      }\n\n      lastMarshalled = marshalled;\n    }) as EventListener;\n\n    window.addEventListener(DATASTAR_EVENT, signalsUpdateHandler);\n\n    let marshalledSignals: string | null;\n\n    if (storageType === SESSION) {\n      marshalledSignals = window.sessionStorage.getItem(key);\n    } else {\n      marshalledSignals = window.localStorage.getItem(key);\n    }\n\n    if (!!marshalledSignals) {\n      const unmarshalledSignals = JSON.parse(marshalledSignals);\n      signals.merge(unmarshalledSignals, true);\n    }\n\n    return () => {\n      window.removeEventListener(DATASTAR_EVENT, signalsUpdateHandler);\n    };\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: carbon:url\n// Slug: Replace the current URL with a new URL\n// Description: This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nexport const ReplaceUrl: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"replaceUrl\",\n  noKey: true,\n  mustValue: true,\n\n  onLoad: (ctx) => {\n    const {\n      expr,\n      reactivity: { effect },\n    } = ctx;\n    return effect(() => {\n      const value = expr(ctx);\n      const baseUrl = window.location.href;\n      const url = new URL(value, baseUrl).toString();\n\n      window.history.replaceState({}, \"\", url);\n    });\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Run expression when element intersects with viewport\n// Description: An attribute that runs an expression when the element intersects with the viewport.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nconst ONCE = \"once\";\nconst HALF = \"half\";\nconst FULL = \"full\";\n\n// Run expression when element intersects with viewport\nexport const Intersection: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"intersects\",\n  onlyMods: new Set([ONCE, HALF, FULL]),\n  noKey: true,\n  onLoad: (ctx) => {\n    const { mods } = ctx;\n    const options = { threshold: 0 };\n    if (mods.has(FULL)) options.threshold = 1;\n    else if (mods.has(HALF)) options.threshold = 0.5;\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          ctx.expr(ctx);\n          if (mods.has(ONCE)) {\n            observer.disconnect();\n            delete ctx.el.dataset[ctx.rawKey];\n          }\n        }\n      });\n    }, options);\n\n    observer.observe(ctx.el);\n    return () => observer.disconnect();\n  },\n};\n", "import { DATASTAR } from \"../engine/consts\";\nimport { ERR_NOT_FOUND } from \"../engine/errors\";\n\nexport function consistentUniqID(el: Element) {\n    if (el.id) return el.id;\n    let hash = 0;\n    const hashUpdate = (n: number) => {\n        hash = ((hash << 5) - hash) + n;\n        return hash & hash;\n    };\n    const hashUpdateFromStr = (str: string) =>\n        str.split(\"\").forEach((c) => hashUpdate(c.charCodeAt(0)));\n\n    while (el.parentNode) {\n        if (el.id) {\n            hashUpdateFromStr(`${el.id}`);\n            break;\n        } else {\n            if (el === el.ownerDocument.documentElement) {\n                hashUpdateFromStr(el.tagName);\n            } else {\n                for (\n                    let i = 1, e = el;\n                    e.previousElementSibling;\n                    e = e.previousElementSibling, i++\n                ) {\n                    hashUpdate(i);\n                }\n                el = el.parentNode as Element;\n            }\n        }\n        el = el.parentNode as Element;\n    }\n    return DATASTAR + hash;\n}\n\nexport function scrollIntoView(\n    el: HTMLElement | SVGElement,\n    opts: ScrollIntoViewOptions,\n    shouldFocus = true,\n) {\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        // Element is not an HTMLElement or SVGElement\n        throw ERR_NOT_FOUND;\n    }\n    if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n\n    el.scrollIntoView(opts);\n    if (shouldFocus) el.focus();\n}\n", "// Authors: Delaney Gillilan\n// Icon: hugeicons:mouse-scroll-01\n// Slug: Scroll an element into view\n// Description: This attribute scrolls the element into view.\n\nimport { AttributeContext, AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { scrollIntoView } from \"../../../../utils/dom\";\n\nconst SMOOTH = \"smooth\";\nconst INSTANT = \"instant\";\nconst AUTO = \"auto\";\nconst HSTART = \"hstart\";\nconst HCENTER = \"hcenter\";\nconst HEND = \"hend\";\nconst HNEAREST = \"hnearest\";\nconst VSTART = \"vstart\";\nconst VCENTER = \"vcenter\";\nconst VEND = \"vend\";\nconst VNEAREST = \"vnearest\";\nconst FOCUS = \"focus\";\n\nconst CENTER = \"center\";\nconst START = \"start\";\nconst END = \"end\";\nconst NEAREST = \"nearest\";\n\n// Scrolls the element into view\nexport const ScrollIntoView: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"scrollIntoView\",\n  noKey: true,\n  noVal: true,\n  onlyMods: new Set([\n    SMOOTH,\n    INSTANT,\n    AUTO,\n    HSTART,\n    HCENTER,\n    HEND,\n    HNEAREST,\n    VSTART,\n    VCENTER,\n    VEND,\n    VNEAREST,\n    FOCUS,\n  ]),\n\n  onLoad: ({ el, mods, rawKey }: AttributeContext) => {\n    if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n    const opts: ScrollIntoViewOptions = {\n      behavior: SMOOTH,\n      block: CENTER,\n      inline: CENTER,\n    };\n    if (mods.has(SMOOTH)) opts.behavior = SMOOTH;\n    if (mods.has(INSTANT)) opts.behavior = INSTANT;\n    if (mods.has(AUTO)) opts.behavior = AUTO;\n    if (mods.has(HSTART)) opts.inline = START;\n    if (mods.has(HCENTER)) opts.inline = CENTER;\n    if (mods.has(HEND)) opts.inline = END;\n    if (mods.has(HNEAREST)) opts.inline = NEAREST;\n    if (mods.has(VSTART)) opts.block = START;\n    if (mods.has(VCENTER)) opts.block = CENTER;\n    if (mods.has(VEND)) opts.block = END;\n    if (mods.has(VNEAREST)) opts.block = NEAREST;\n\n    scrollIntoView(el, opts, mods.has(\"focus\"));\n    delete el.dataset[rawKey];\n    return () => {};\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nconst NONE = \"none\";\nconst DISPLAY = \"display\";\n\nexport const Show: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: \"show\",\n  noKey: true,\n  mustValue: true,\n\n  onLoad: (ctx) => {\n    const {\n      expr,\n      el: { style: s },\n      reactivity: { effect },\n    } = ctx;\n    return effect(async () => {\n      const shouldShow: boolean = expr(ctx);\n      if (shouldShow) {\n        if (s.display === NONE) {\n          s.removeProperty(DISPLAY);\n        }\n      } else {\n        s.setProperty(DISPLAY, NONE);\n      }\n    });\n  },\n};\n", "export interface DocumentSupportingViewTransitionAPI {\n    startViewTransition(\n        updateCallback: () => Promise<void> | void,\n    ): IViewTransition;\n}\n\nexport interface IViewTransition {\n    finished: Promise<void>;\n    ready: Promise<void>;\n    updateCallbackDone: Promise<void>;\n    skipTransition(): void;\n}\n\nexport const docWithViewTransitionAPI =\n    document as unknown as DocumentSupportingViewTransitionAPI;\nexport const supportsViewTransitions = !!docWithViewTransitionAPI\n    .startViewTransition;\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:masked-transitions\n// Slug: Setup view transitions\n// Description: This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { supportsViewTransitions } from \"../../../../utils/view-transitions\";\n\nconst VIEW_TRANSITION = \"view-transition\";\n\nexport const ViewTransition: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: VIEW_TRANSITION,\n  onGlobalInit() {\n    let hasViewTransitionMeta = false;\n    document.head.childNodes.forEach((node) => {\n      if (node instanceof HTMLMetaElement && node.name === VIEW_TRANSITION) {\n        hasViewTransitionMeta = true;\n      }\n    });\n\n    if (!hasViewTransitionMeta) {\n      const meta = document.createElement(\"meta\");\n      meta.name = VIEW_TRANSITION;\n      meta.content = \"same-origin\";\n      document.head.appendChild(meta);\n    }\n  },\n  onLoad: (ctx) => {\n    if (!supportsViewTransitions) {\n      console.error(\"Browser does not support view transitions\");\n      return;\n    }\n\n    return ctx.reactivity.effect(() => {\n      const { el, expr } = ctx;\n      let name = expr(ctx);\n      if (!name) return;\n      const elVTASTyle = el.style as unknown as CSSStyleDeclaration;\n      elVTASTyle.viewTransitionName = name;\n    });\n  },\n};\n", "// We don't use these exports, they are purely for access via package managers like NPM\n\nimport { MacroPlugin, RegexpGroups } from \"../../../../engine\";\nimport { PluginType } from \"../../../../engine/enums\";\n\nconst validJSIdentifier = `[a-zA-Z_$]+`;\nconst validNestedJSIdentifier = validJSIdentifier + `[0-9a-zA-Z_$.]*`;\n\n// Replacing $signal with ctx.signals.signal.value`\nexport const SignalsGetMacro: MacroPlugin = {\n  name: \"get$\",\n  type: PluginType.Macro,\n  regexp: new RegExp(`(?<whole>\\\\$(?<key>${validNestedJSIdentifier}))`, \"gm\"),\n  alter: (groups: RegexpGroups) => {\n    const { key } = groups;\n    return `ctx.signals.value('${key}')`;\n  },\n};\n\nexport const SignalsSetMacro: MacroPlugin = {\n  name: \"set$\",\n  type: PluginType.Macro,\n  regexp: new RegExp(\n    `(?<whole>\\\\$(?<key>${validNestedJSIdentifier})\\\\s*=\\\\s*(?<value>[\\\\w.(),]*))`,\n    \"gm\"\n  ),\n  alter: ({ key, value }) => {\n    return `ctx.signals.set(\"${key}\", ${value})`;\n  },\n};\n\nexport const ActionsMacro: MacroPlugin = {\n  name: \"action\",\n  type: PluginType.Macro,\n  regexp: new RegExp(\n    `(?<whole>@(?<action>${validJSIdentifier})\\\\((?<args>.*)\\\\))`,\n    \"gm\"\n  ),\n  alter: ({ action, args }: RegexpGroups) => {\n    const withCtx = [`ctx`];\n    if (args) {\n      withCtx.push(...args.split(\",\").map((x) => x.trim()));\n    }\n    const argsJoined = withCtx.join(\",\");\n    return `ctx.actions.${action}.fn(${argsJoined})`;\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: tabler:file-type-js\n// Slug: Execute JavaScript using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { WatcherPlugin } from \"../../../../engine/types\";\n\nimport {\n  EventTypes,\n  executeScriptAttributes,\n  executeScriptAutoRemove,\n} from \"../../../../engine/consts\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const ExecuteScript: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.ExecuteScript,\n  onGlobalInit: async () => {\n    datastarSSEEventWatcher(\n      EventTypes.ExecuteScript,\n      ({\n        autoRemove: autoRemoveRaw = `${executeScriptAutoRemove}`,\n        attributes: attributesRaw = executeScriptAttributes,\n        script,\n      }) => {\n        const autoRemove = isBoolString(autoRemoveRaw);\n        if (!script?.length) {\n          // No script provided\n          throw ERR_BAD_ARGS;\n        }\n        const scriptEl = document.createElement(\"script\");\n        attributesRaw.split(\"\\n\").forEach((attr) => {\n          const pivot = attr.indexOf(\" \");\n          const key = pivot ? attr.slice(0, pivot) : attr;\n          const value = pivot ? attr.slice(pivot) : \"\";\n          scriptEl.setAttribute(key.trim(), value.trim());\n        });\n        scriptEl.text = script;\n        document.head.appendChild(scriptEl);\n        if (autoRemove) {\n          scriptEl.remove();\n        }\n      }\n    );\n  },\n};\n", "import { FragmentMergeModes } from \"../engine/consts\";\nimport { ERR_BAD_ARGS, ERR_NOT_FOUND } from \"../engine/errors\";\n\nconst generatedByIdiomorphId = new WeakSet();\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(\n    oldNode: Document | Element,\n    newContent: string | Element,\n    config = {},\n) {\n    if (oldNode instanceof Document) {\n        oldNode = oldNode.documentElement;\n    }\n\n    let parsedContent: Element;\n    if (typeof newContent === \"string\") {\n        parsedContent = parseContent(newContent) as Element;\n    } else {\n        parsedContent = newContent;\n    }\n\n    const normalizedContent = normalizeContent(parsedContent);\n    const ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n}\n\nfunction morphNormalizedContent(\n    oldNode: Element,\n    normalizedNewContent: Element,\n    ctx: any,\n) {\n    if (ctx.head.block) {\n        const oldHead = oldNode.querySelector(\"head\");\n        const newHead = normalizedNewContent.querySelector(\"head\");\n        if (oldHead && newHead) {\n            const promises = handleHeadElement(newHead, oldHead, ctx);\n            // when head promises resolve, call morph again, ignoring the head tag\n            Promise.all(promises).then(() => {\n                morphNormalizedContent(\n                    oldNode,\n                    normalizedNewContent,\n                    Object.assign(ctx, {\n                        head: {\n                            block: false,\n                            ignore: true,\n                        },\n                    }),\n                );\n            });\n            return;\n        }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n        // innerHTML, so we are only updating the children\n        morphChildren(normalizedNewContent, oldNode, ctx);\n        return oldNode.children;\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n        // otherwise find the best element match in the new content, morph that, and merge its siblings\n        // into either side of the best match\n        const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n        if (!bestMatch) {\n            // could not find a best match, so throw an error\n            throw ERR_NOT_FOUND;\n        }\n\n        // stash the siblings that will need to be inserted on either side of the best match\n        const previousSibling = bestMatch?.previousSibling as Element;\n        const nextSibling = bestMatch?.nextSibling as Element;\n\n        // morph it\n        const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n        if (bestMatch) {\n            // if there was a best match, merge the siblings in too and return the\n            // whole bunch\n            return insertSiblings(previousSibling, morphedNode, nextSibling);\n        } else {\n            // otherwise nothing was added to the DOM\n            return [];\n        }\n    } else {\n        // console.error(`Do not understand how to morph style ${ctx.morphStyle}`);\n        throw ERR_BAD_ARGS;\n    }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n    } else if (newContent == null) {\n        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return;\n\n        oldNode.remove();\n        ctx.callbacks.afterNodeRemoved(oldNode);\n        return;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return;\n        if (ctx.callbacks.beforeNodeAdded(newContent) === false) return;\n\n        if (!oldNode.parentElement) {\n            // oldNode has no parentElement\n            throw ERR_BAD_ARGS;\n        }\n        oldNode.parentElement.replaceChild(newContent, oldNode);\n        ctx.callbacks.afterNodeAdded(newContent);\n        ctx.callbacks.afterNodeRemoved(oldNode);\n        return newContent;\n    } else {\n        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n            return;\n        }\n\n        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n            // ignore the head element\n        } else if (\n            newContent instanceof HTMLHeadElement &&\n            oldNode instanceof HTMLHeadElement &&\n            ctx.head.style !== FragmentMergeModes.Morph\n        ) {\n            handleHeadElement(newContent, oldNode, ctx);\n        } else {\n            syncNodeFrom(newContent, oldNode);\n            morphChildren(newContent, oldNode, ctx);\n        }\n        ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n        return oldNode;\n    }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n    let nextNewChild = newParent.firstChild as Element | null;\n    let insertionPoint = oldParent.firstChild as Element | null;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n        newChild = nextNewChild;\n        nextNewChild = newChild.nextSibling as Element | null;\n\n        // if we are at the end of the exiting parent's children, just append\n        if (insertionPoint == null) {\n            if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n            oldParent.appendChild(newChild);\n            ctx.callbacks.afterNodeAdded(newChild);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // if the current node has an id set match then morph\n        if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n            morphOldNodeTo(insertionPoint, newChild, ctx);\n            insertionPoint = insertionPoint.nextSibling as Element | null;\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // otherwise search forward in the existing old children for an id set match\n        let idSetMatch = findIdSetMatch(\n            newParent,\n            oldParent,\n            newChild,\n            insertionPoint,\n            ctx,\n        );\n\n        // if we found a potential match, remove the nodes until that point and morph\n        if (idSetMatch) {\n            insertionPoint = removeNodesBetween(\n                insertionPoint,\n                idSetMatch,\n                ctx,\n            );\n            morphOldNodeTo(idSetMatch, newChild, ctx);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // no id set match found, so scan forward for a soft match for the current node\n        let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx);\n\n        // if we found a soft match for the current node, morph\n        if (softMatch) {\n            insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n            morphOldNodeTo(softMatch, newChild, ctx);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // abandon all hope of morphing, just insert the new child before the insertion point\n        // and move on\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n        removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n        let tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling as Element | null;\n        removeNode(tempNode, ctx);\n    }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n        for (const fromAttribute of from.attributes) {\n            const toAttribute = to.getAttribute(fromAttribute.name);\n            if (toAttribute !== fromAttribute.value) {\n                to.setAttribute(fromAttribute.name, fromAttribute.value);\n            }\n        }\n        for (const toAttribute of to.attributes) {\n            if (!from.hasAttribute(toAttribute.name)) {\n                to.removeAttribute(toAttribute.name);\n            }\n        }\n    }\n\n    // sync text nodes\n    if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n        if (to.nodeValue !== from.nodeValue) {\n            to.nodeValue = from.nodeValue;\n        }\n    }\n\n    // NB: many bothans died to bring us information:\n    //\n    // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n    // sync input value\n    if (\n        from instanceof HTMLInputElement && to instanceof HTMLInputElement &&\n        from.type !== \"file\"\n    ) {\n        to.value = from.value || \"\";\n        syncAttribute(from, to, \"value\");\n\n        // sync boolean attributes\n        syncAttribute(from, to, \"checked\");\n        syncAttribute(from, to, \"disabled\");\n    } else if (from instanceof HTMLOptionElement) {\n        syncAttribute(from, to, \"selected\");\n    } else if (\n        from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement\n    ) {\n        const fromValue = from.value;\n        const toValue = to.value;\n        if (fromValue !== toValue) {\n            to.value = fromValue;\n        }\n        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n            to.firstChild.nodeValue = fromValue;\n        }\n    }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n    const fAttr = from.getAttribute(attributeName);\n    const tAttr = to.getAttribute(attributeName);\n\n    if (fAttr !== tAttr) {\n        if (fAttr) {\n            to.setAttribute(attributeName, fAttr);\n        } else {\n            to.removeAttribute(attributeName);\n        }\n    }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(\n    newHeadTag: HTMLHeadElement,\n    currentHead: HTMLHeadElement,\n    ctx: any,\n) {\n    const added = [];\n    const removed = [];\n    const preserved = [];\n    const nodesToAppend = [];\n\n    const headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    const srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n        // If the current head element is in the map\n        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n        if (inNewContent || isPreserved) {\n            if (isReAppended) {\n                // remove the current version and let the new version replace it and re-execute\n                removed.push(currentHeadElt);\n            } else {\n                // this element already exists and should not be re-appended, so remove it from\n                // the new content map, preserving it in the DOM\n                srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                preserved.push(currentHeadElt);\n            }\n        } else {\n            if (headMergeStyle === FragmentMergeModes.Append) {\n                // we are appending and this existing element is not new content\n                // so if and only if it is marked for re-append do we do anything\n                if (isReAppended) {\n                    removed.push(currentHeadElt);\n                    nodesToAppend.push(currentHeadElt);\n                }\n            } else {\n                // if this is a merge, we remove this content since it is not in the new head\n                if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                    removed.push(currentHeadElt);\n                }\n            }\n        }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    // console.log('to append: ', nodesToAppend)\n\n    const promises = [];\n    for (const newNode of nodesToAppend) {\n        // console.log('adding: ', newNode)\n        const newElt = document.createRange().createContextualFragment(\n            newNode.outerHTML,\n        ).firstChild as Element | null;\n        if (!newElt) {\n            // console.error(`could not create new element from: ${newNode.outerHTML}`);\n            throw ERR_BAD_ARGS;\n        }\n        // console.log(newElt)\n        if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n            if (newElt.hasAttribute(\"href\") || newElt.hasAttribute(\"src\")) {\n                let resolver: (value: unknown) => void;\n                const promise = new Promise((resolve) => {\n                    resolver = resolve;\n                });\n                newElt.addEventListener(\"load\", function () {\n                    resolver(undefined);\n                });\n                promises.push(promise);\n            }\n            currentHead.appendChild(newElt);\n            ctx.callbacks.afterNodeAdded(newElt);\n            added.push(newElt);\n        }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n            currentHead.removeChild(removedElement);\n            ctx.callbacks.afterNodeRemoved(removedElement);\n        }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n        added: added,\n        kept: preserved,\n        removed: removed,\n    });\n    return promises;\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(\n    oldNode: Element,\n    newContent: Element,\n    config: any,\n) {\n    return {\n        target: oldNode,\n        newContent: newContent,\n        config: config,\n        morphStyle: config.morphStyle,\n        ignoreActive: config.ignoreActive,\n        idMap: createIdMap(oldNode, newContent),\n        deadIds: new Set(),\n        callbacks: Object.assign(\n            {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n            },\n            config.callbacks,\n        ),\n        head: Object.assign(\n            {\n                style: \"merge\",\n                shouldPreserve: (elt: Element) =>\n                    elt.getAttribute(\"im-preserve\") === \"true\",\n                shouldReAppend: (elt: Element) =>\n                    elt.getAttribute(\"im-re-append\") === \"true\",\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            },\n            config.head,\n        ),\n    };\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n    if (!node1 || !node2) return false;\n\n    if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n        if (node1?.id?.length && node1.id === node2.id) return true;\n\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n    }\n    return false;\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n    if (!node1 || !node2) return false;\n\n    return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n}\n\nfunction removeNodesBetween(\n    startInclusive: Element,\n    endExclusive: Element,\n    ctx: any,\n) {\n    while (startInclusive !== endExclusive) {\n        const tempNode = startInclusive;\n        startInclusive = startInclusive?.nextSibling as Element;\n        if (!tempNode) {\n            // tempNode is null\n            throw ERR_BAD_ARGS;\n        }\n        removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling as Element | null;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(\n    newContent: Element,\n    oldParent: Element,\n    newChild: Element,\n    insertionPoint: Element,\n    ctx: any,\n) {\n    // max id matches we are willing to discard in our search\n    const newChildPotentialIdCount = getIdIntersectionCount(\n        ctx,\n        newChild,\n        oldParent,\n    );\n\n    let potentialMatch: Element | null = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n        potentialMatch = insertionPoint;\n        // if there is a possibility of an id match, scan forward\n        // keep track of the potential id match count we are discarding (the\n        // newChildPotentialIdCount must be greater than this to make it likely\n        // worth it)\n        let otherMatchCount = 0;\n        while (potentialMatch != null) {\n            // If we have an id match, return the current potential match\n            if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                return potentialMatch;\n            }\n\n            // computer the other potential matches of this new content\n            otherMatchCount += getIdIntersectionCount(\n                ctx,\n                potentialMatch,\n                newContent,\n            );\n            if (otherMatchCount > newChildPotentialIdCount) {\n                // if we have more potential id matches in _other_ content, we\n                // do not have a good candidate for an id match, so return null\n                return null;\n            }\n\n            // advanced to the next old content child\n            potentialMatch = potentialMatch.nextSibling as Element | null;\n        }\n    }\n    return potentialMatch;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(\n    newContent: Element,\n    newChild: Element,\n    insertionPoint: Element,\n    ctx: any,\n) {\n    let potentialSoftMatch = insertionPoint as Element | null;\n    let nextSibling = newChild.nextSibling as Element | null;\n\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch && nextSibling) {\n        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n            // the current potential soft match has a potential id set match with the remaining new\n            // content so bail out of looking\n            return null;\n        }\n\n        // if we have a soft match with the current node, return it\n        if (isSoftMatch(newChild, potentialSoftMatch)) {\n            return potentialSoftMatch;\n        }\n\n        if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n            // the next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling as Element | null;\n\n            // If there are two future soft matches, bail to allow the siblings to soft match\n            // so that we don't consume future soft matches for the sake of the current node\n            if (siblingSoftMatchCount >= 2) {\n                return null;\n            }\n        }\n\n        // advanced to the next old content child\n        potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null;\n    }\n\n    return potentialSoftMatch;\n}\n\nconst parser = new DOMParser();\nfunction parseContent(newContent: string) {\n    // remove svgs to avoid false-positive matches on head, etc.\n    const contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n        const content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n            generatedByIdiomorphId.add(content);\n            return content;\n        } else {\n            // otherwise return the html element as the parent container\n            let Element = content.firstChild;\n            if (Element) {\n                generatedByIdiomorphId.add(Element);\n                return Element as Element;\n            } else {\n                return null;\n            }\n        }\n    } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        const responseDoc = parser.parseFromString(\n            `<body><template>${newContent}</template></body>`,\n            \"text/html\",\n        );\n        const content = responseDoc.body.querySelector(\"template\")?.content;\n        if (!content) {\n            // Content is null\n            throw ERR_NOT_FOUND;\n        }\n        generatedByIdiomorphId.add(content);\n        return content;\n    }\n}\n\nfunction normalizeContent(newContent: Element) {\n    if (newContent == null) {\n        // noinspection UnnecessaryLocalVariableJS\n        const dummyParent = document.createElement(\"div\");\n        return dummyParent;\n    } else if (generatedByIdiomorphId.has(newContent)) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return newContent;\n    } else if (newContent instanceof Node) {\n        // a single node is added as a child to a dummy parent\n        const dummyParent = document.createElement(\"div\");\n        dummyParent.append(newContent);\n        return dummyParent;\n    } else {\n        // all nodes in the array or Element collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n            dummyParent.append(elt);\n        }\n        return dummyParent;\n    }\n}\n\nfunction insertSiblings(\n    previousSibling?: Element,\n    morphedNode?: Element,\n    nextSibling?: Element,\n) {\n    const stack = [];\n    const added = [];\n    while (previousSibling) {\n        stack.push(previousSibling);\n        previousSibling = previousSibling.previousSibling as Element;\n    }\n    while (stack.length > 0) {\n        const node = stack.pop()!;\n        added.push(node); // push added preceding siblings on in order and insert\n        morphedNode?.parentElement?.insertBefore(node, morphedNode);\n    }\n    added.push(morphedNode);\n    while (nextSibling) {\n        stack.push(nextSibling);\n        added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n        nextSibling = nextSibling.nextSibling as Element;\n    }\n    while (stack.length) {\n        morphedNode?.parentElement?.insertBefore(\n            stack.pop()!,\n            morphedNode.nextSibling,\n        );\n    }\n    return added;\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n    let currentElement = newContent.firstChild as Element | null;\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n        let newScore = scoreElement(currentElement, oldNode, ctx);\n        if (newScore > score) {\n            bestElement = currentElement;\n            score = newScore;\n        }\n        currentElement = currentElement.nextSibling as Element | null;\n    }\n    return bestElement;\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n    if (isSoftMatch(node1, node2)) {\n        return 0.5 + getIdIntersectionCount(ctx, node1, node2);\n    }\n    return 0;\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n    removeIdsFromConsideration(ctx, tempNode);\n    if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n    tempNode.remove();\n    ctx.callbacks.afterNodeRemoved(tempNode);\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n    return !ctx.deadIds.has(id);\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n    return ctx.idMap.get(targetNode)?.has(id) || false;\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n    const idSet = ctx.idMap.get(node);\n    if (!idSet) return;\n    for (const id of idSet) {\n        ctx.deadIds.add(id);\n    }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n    const sourceSet = ctx.idMap.get(node1);\n    if (!sourceSet) return 0;\n\n    let matchCount = 0;\n    for (const id of sourceSet) {\n        // a potential match is an id in the source and potentialIdsSet, but\n        // that has not already been merged into the DOM\n        if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n            ++matchCount;\n        }\n    }\n    return matchCount;\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n    const nodeParent = node.parentElement;\n    // find all elements with an id property\n    const idElements = node.querySelectorAll(\"[id]\");\n    for (const elt of idElements) {\n        let current = elt as Element | null;\n        // walk up the parent hierarchy of that element, adding the id\n        // of element to the parent's id set\n        while (current !== nodeParent && !!current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the  map\n            if (idSet == null) {\n                idSet = new Set();\n                idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n            current = current.parentElement;\n        }\n    }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n    const idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:cloud-download\n// Slug: Merge fragments into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { InitContext, WatcherPlugin } from \"../../../../engine\";\nimport {\n  EventTypes,\n  fragmentMergeMode,\n  FragmentMergeModes,\n  fragmentsUseViewTransitions,\n  settleDurationMs,\n} from \"../../../../engine/consts\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from \"../../../../utils/view-transitions\";\nimport { idiomorph } from \"../../../../vendored/idiomorph\";\nimport {\n  datastarSSEEventWatcher,\n  SETTLING_CLASS,\n  SWAPPING_CLASS,\n} from \"./sseShared\";\n\nexport const MergeFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.MergeFragments,\n  onGlobalInit: async (ctx) => {\n    const fragmentContainer = document.createElement(\"template\");\n    datastarSSEEventWatcher(\n      EventTypes.MergeFragments,\n      ({\n        fragments: fragmentsRaw = \"<div></div>\",\n        selector = \"\",\n        mergeMode = fragmentMergeMode,\n        settleDuration: settleDurationRaw = `${settleDurationMs}`,\n        useViewTransition:\n          useViewTransitionRaw = `${fragmentsUseViewTransitions}`,\n      }) => {\n        const settleDuration = parseInt(settleDurationRaw);\n        const useViewTransition = isBoolString(useViewTransitionRaw);\n\n        fragmentContainer.innerHTML = fragmentsRaw.trim();\n        const fragments = [...fragmentContainer.content.children];\n        fragments.forEach((fragment) => {\n          if (!(fragment instanceof Element)) {\n            // No fragments found\n            throw ERR_BAD_ARGS;\n          }\n\n          const selectorOrID = selector || `#${fragment.getAttribute(\"id\")}`;\n          const targets = document.querySelectorAll(selectorOrID) || [];\n          const allTargets = [...targets];\n          if (!allTargets.length) {\n            // No targets found\n            throw ERR_BAD_ARGS;\n          }\n\n          if (supportsViewTransitions && useViewTransition) {\n            docWithViewTransitionAPI.startViewTransition(() =>\n              applyToTargets(\n                ctx,\n                mergeMode,\n                settleDuration,\n                fragment,\n                allTargets\n              )\n            );\n          } else {\n            applyToTargets(\n              ctx,\n              mergeMode,\n              settleDuration,\n              fragment,\n              allTargets\n            );\n          }\n        });\n      }\n    );\n  },\n};\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mergeMode: string,\n  settleDuration: number,\n  fragment: Element,\n  capturedTargets: Element[]\n) {\n  for (const initialTarget of capturedTargets) {\n    initialTarget.classList.add(SWAPPING_CLASS);\n    const originalHTML = initialTarget.outerHTML;\n    let modifiedTarget = initialTarget;\n    switch (mergeMode) {\n      case FragmentMergeModes.Morph:\n        const result = idiomorph(modifiedTarget, fragment, {\n          callbacks: {\n            beforeNodeRemoved: (oldNode: Element, _: Element) => {\n              ctx.cleanup(oldNode);\n              return true;\n            },\n          },\n        });\n        if (!result?.length) {\n          // No morph result\n          throw ERR_BAD_ARGS;\n        }\n        modifiedTarget = result[0] as Element;\n        break;\n      case FragmentMergeModes.Inner:\n        // Replace the contents of the target element with the response\n        modifiedTarget.innerHTML = fragment.innerHTML;\n        break;\n      case FragmentMergeModes.Outer:\n        // Replace the entire target element with the response\n        modifiedTarget.replaceWith(fragment);\n        break;\n      case FragmentMergeModes.Prepend:\n        // Insert the response before the first child of the target element\n        modifiedTarget.prepend(fragment);\n        break;\n      case FragmentMergeModes.Append:\n        // Insert the response after the last child of the target element\n        modifiedTarget.append(fragment);\n        break;\n      case FragmentMergeModes.Before:\n        // Insert the response before the target element\n        modifiedTarget.before(fragment);\n        break;\n      case FragmentMergeModes.After:\n        // Insert the response after the target element\n        modifiedTarget.after(fragment);\n        break;\n      case FragmentMergeModes.UpsertAttributes:\n        // Upsert the attributes of the target element\n        fragment.getAttributeNames().forEach((attrName) => {\n          const value = fragment.getAttribute(attrName)!;\n          modifiedTarget.setAttribute(attrName, value);\n        });\n        break;\n      default:\n        // Unknown merge type\n        throw ERR_BAD_ARGS;\n    }\n    ctx.cleanup(modifiedTarget);\n    modifiedTarget.classList.add(SWAPPING_CLASS);\n\n    ctx.applyPlugins(document.body);\n\n    setTimeout(() => {\n      initialTarget.classList.remove(SWAPPING_CLASS);\n      modifiedTarget.classList.remove(SWAPPING_CLASS);\n    }, settleDuration);\n\n    const revisedHTML = modifiedTarget.outerHTML;\n\n    if (originalHTML !== revisedHTML) {\n      modifiedTarget.classList.add(SETTLING_CLASS);\n      setTimeout(() => {\n        modifiedTarget.classList.remove(SETTLING_CLASS);\n      }, settleDuration);\n    }\n  }\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge signals using a Server-Sent Event\n// // Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { WatcherPlugin } from \"../../../../engine\";\nimport {\n  EventTypes,\n  mergeSignalsOnlyIfMissing,\n} from \"../../../../engine/consts\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const MergeSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.MergeSignals,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.MergeSignals,\n      ({\n        signals: raw = \"{}\",\n        onlyIfMissing: onlyIfMissingRaw = `${mergeSignalsOnlyIfMissing}`,\n      }) => {\n        const { signals } = ctx;\n        const onlyIfMissing = isBoolString(onlyIfMissingRaw);\n        const fn = new Function(`return Object.assign({}, ${raw})`);\n        const possibleMergeSignals = fn();\n        signals.merge(possibleMergeSignals, onlyIfMissing);\n        ctx.applyPlugins(document.body);\n      }\n    );\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Remove fragments from the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { WatcherPlugin } from \"../../../../engine\";\nimport {\n  EventTypes,\n  fragmentsUseViewTransitions,\n  settleDurationMs,\n} from \"../../../../engine/consts\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from \"../../../../utils/view-transitions\";\nimport { datastarSSEEventWatcher, SWAPPING_CLASS } from \"./sseShared\";\n\nexport const RemoveFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.RemoveFragments,\n  onGlobalInit: async () => {\n    datastarSSEEventWatcher(\n      EventTypes.RemoveFragments,\n      ({\n        selector,\n        settleDuration: settleDurationRaw = `${settleDurationMs}`,\n        useViewTransition:\n          useViewTransitionRaw = `${fragmentsUseViewTransitions}`,\n      }) => {\n        if (!!!selector.length) {\n          // No selector provided for remove-fragments\n          throw ERR_BAD_ARGS;\n        }\n\n        const settleDuration = parseInt(settleDurationRaw);\n        const useViewTransition = isBoolString(useViewTransitionRaw);\n        const removeTargets = document.querySelectorAll(selector);\n\n        const applyToTargets = () => {\n          for (const target of removeTargets) {\n            target.classList.add(SWAPPING_CLASS);\n          }\n\n          setTimeout(() => {\n            for (const target of removeTargets) {\n              target.remove();\n            }\n          }, settleDuration);\n        };\n\n        if (supportsViewTransitions && useViewTransition) {\n          docWithViewTransitionAPI.startViewTransition(() => applyToTargets());\n        } else {\n          applyToTargets();\n        }\n      }\n    );\n  },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Remove signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { EventTypes } from \"../../../../engine/consts\";\nimport { PluginType } from \"../../../../engine/enums\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { WatcherPlugin } from \"../../../../engine/types\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const RemoveSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.RemoveSignals,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.RemoveSignals,\n      ({ paths: pathsRaw = \"\" }) => {\n        const paths = pathsRaw.split(\"\\n\").map((p) => p.trim());\n        if (!!!paths?.length) {\n          // No paths provided for remove-signals\n          throw ERR_BAD_ARGS;\n        }\n        ctx.signals.remove(...paths);\n      },\n    );\n  },\n};\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n\nimport { ERR_BAD_ARGS } from \"../engine/errors\";\n\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal;\n  _prevSource?: Node;\n  _nextSource?: Node;\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect;\n  _prevTarget?: Node;\n  _nextTarget?: Node;\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number;\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node;\n};\n\nfunction startBatch() {\n  batchDepth++;\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--;\n    return;\n  }\n\n  let error: unknown;\n  let hasError = false;\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect;\n    batchedEffect = undefined;\n\n    batchIteration++;\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect;\n      effect._nextBatchedEffect = undefined;\n      effect._flags &= ~NOTIFIED;\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback();\n        } catch (err) {\n          if (!hasError) {\n            error = err;\n            hasError = true;\n          }\n        }\n      }\n      effect = next;\n    }\n  }\n  batchIteration = 0;\n  batchDepth--;\n\n  if (hasError) {\n    throw error;\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn();\n  }\n  /*@__INLINE__**/ startBatch();\n  try {\n    return fn();\n  } finally {\n    endBatch();\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return fn();\n  } finally {\n    evalContext = prevContext;\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined;\n  }\n\n  let node = signal._node;\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    };\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node;\n    }\n    evalContext._sources = node;\n    signal._node = node;\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node);\n    }\n    return node;\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0;\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource;\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource;\n      }\n\n      node._prevSource = evalContext._sources;\n      node._nextSource = undefined;\n\n      evalContext._sources!._nextSource = node;\n      evalContext._sources = node;\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node;\n  }\n  return undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown;\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number;\n\n  /** @internal */\n  _node?: Node;\n\n  /** @internal */\n  _targets?: Node;\n\n  constructor(value?: T);\n\n  /** @internal */\n  _refresh(): boolean;\n\n  /** @internal */\n  _subscribe(node: Node): void;\n\n  /** @internal */\n  _unsubscribe(node: Node): void;\n\n  subscribe(fn: (value: T) => void): () => void;\n\n  valueOf(): T;\n\n  toString(): string;\n\n  toJSON(): T;\n\n  peek(): T;\n\n  brand: typeof BRAND_SYMBOL;\n\n  get value(): T;\n  set value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value;\n  this._version = 0;\n  this._node = undefined;\n  this._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n  return true;\n};\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets;\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node;\n    }\n    this._targets = node;\n  }\n};\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget;\n    const next = node._nextTarget;\n    if (prev !== undefined) {\n      prev._nextTarget = next;\n      node._prevTarget = undefined;\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev;\n      node._nextTarget = undefined;\n    }\n    if (node === this._targets) {\n      this._targets = next;\n    }\n  }\n};\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value;\n\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      fn(value);\n    } finally {\n      evalContext = prevContext;\n    }\n  });\n};\n\nSignal.prototype.valueOf = function () {\n  return this.value;\n};\n\nSignal.prototype.toString = function () {\n  return this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n  return this.value;\n};\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return this.value;\n  } finally {\n    evalContext = prevContext;\n  }\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n  get(this: Signal) {\n    const node = addDependency(this);\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    return this._value;\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        // Cycle detected\n        throw ERR_BAD_ARGS;\n      }\n\n      this._value = value;\n      this._version++;\n      globalVersion++;\n\n      /**@__INLINE__*/ startBatch();\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify();\n        }\n      } finally {\n        endBatch();\n      }\n    }\n  },\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true;\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node;\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode;\n    }\n    node._source._node = node;\n    node._version = -1;\n\n    if (node._nextSource === undefined) {\n      target._sources = node;\n      break;\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources;\n  let head = undefined;\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource;\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node);\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource;\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev;\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node;\n    }\n\n    node._source._node = node._rollbackNode;\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined;\n    }\n\n    node = prev;\n  }\n\n  target._sources = head;\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n  _fn: () => T;\n  _sources?: Node;\n  _globalVersion: number;\n  _flags: number;\n\n  constructor(fn: () => T);\n\n  _notify(): void;\n  get value(): T;\n}\n\nexport function Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined);\n\n  this._fn = fn;\n  this._sources = undefined;\n  this._globalVersion = globalVersion - 1;\n  this._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED;\n\n  if (this._flags & RUNNING) {\n    return false;\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true;\n  }\n  this._flags &= ~OUTDATED;\n\n  if (this._globalVersion === globalVersion) {\n    return true;\n  }\n  this._globalVersion = globalVersion;\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING;\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING;\n    return true;\n  }\n\n  const prevContext = evalContext;\n  try {\n    prepareSources(this);\n    evalContext = this;\n    const value = this._fn();\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value;\n      this._flags &= ~HAS_ERROR;\n      this._version++;\n    }\n  } catch (err) {\n    this._value = err;\n    this._flags |= HAS_ERROR;\n    this._version++;\n  }\n  evalContext = prevContext;\n  cleanupSources(this);\n  this._flags &= ~RUNNING;\n  return true;\n};\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING;\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node);\n    }\n  }\n  Signal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node);\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING;\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node);\n      }\n    }\n  }\n};\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED;\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify();\n    }\n  }\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw ERR_BAD_ARGS;\n    }\n    const node = addDependency(this);\n    this._refresh();\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    if (this._flags & HAS_ERROR) {\n      throw this._value;\n    }\n    return this._value;\n  },\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T;\n  peek(): T;\n\n  subscribe(fn: (value: T) => void): () => void;\n  valueOf(): T;\n  toString(): string;\n  toJSON(): T;\n  brand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup;\n  effect._cleanup = undefined;\n\n  if (typeof cleanup === \"function\") {\n    /*@__INLINE__**/ startBatch();\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      cleanup!();\n    } catch (err) {\n      effect._flags &= ~RUNNING;\n      effect._flags |= DISPOSED;\n      disposeEffect(effect);\n      throw err;\n    } finally {\n      evalContext = prevContext;\n      endBatch();\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node);\n  }\n  effect._fn = undefined;\n  effect._sources = undefined;\n\n  cleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    // Out-of-order effect\n    throw ERR_BAD_ARGS;\n  }\n  cleanupSources(this);\n  evalContext = prevContext;\n\n  this._flags &= ~RUNNING;\n  if (this._flags & DISPOSED) {\n    disposeEffect(this);\n  }\n  endBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n  _fn?: EffectFn;\n  _cleanup?: () => void;\n  _sources?: Node;\n  _nextBatchedEffect?: Effect;\n  _flags: number;\n\n  constructor(fn: EffectFn);\n\n  _callback(): void;\n  _start(): () => void;\n  _notify(): void;\n  _dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn;\n  this._cleanup = undefined;\n  this._sources = undefined;\n  this._nextBatchedEffect = undefined;\n  this._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start();\n  try {\n    if (this._flags & DISPOSED) return;\n    if (this._fn === undefined) return;\n\n    const cleanup = this._fn();\n    if (typeof cleanup === \"function\") {\n      this._cleanup = cleanup!;\n    }\n  } finally {\n    finish();\n  }\n};\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    // Cycle detected\n    throw ERR_BAD_ARGS;\n  }\n  this._flags |= RUNNING;\n  this._flags &= ~DISPOSED;\n  cleanupEffect(this);\n  prepareSources(this);\n\n  /*@__INLINE__**/ startBatch();\n  const prevContext = evalContext;\n  evalContext = this;\n  return endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED;\n    this._nextBatchedEffect = batchedEffect;\n    batchedEffect = this;\n  }\n};\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED;\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this);\n  }\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn);\n  try {\n    effect._callback();\n  } catch (err) {\n    effect._dispose();\n    throw err;\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect);\n}\n\nexport { batch, computed, effect, Signal, untracked };\nexport type { ReadonlySignal };\n", "import { Signal } from \"../vendored\";\nimport { NestedSignal, NestedValues } from \"./types\";\n\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedSignal,\n  onlyPublic = false\n): Record<string, any> {\n  const kv: Record<string, any> = {};\n  for (const key in signal) {\n    if (signal.hasOwnProperty(key)) {\n      const value = signal[key];\n      if (value instanceof Signal) {\n        if (onlyPublic && key.startsWith(\"_\")) {\n          continue;\n        }\n        kv[key] = value.value;\n      } else {\n        kv[key] = nestedValues(value);\n      }\n    }\n  }\n  return kv;\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  onlyIfMissing = false\n): void {\n  for (const key in values) {\n    if (values.hasOwnProperty(key)) {\n      const value = values[key];\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {};\n        }\n        mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          onlyIfMissing\n        );\n      } else {\n        if (onlyIfMissing && target[key]) {\n          continue;\n        }\n        target[key] = new Signal(value);\n      }\n    }\n  }\n}\n\nfunction walkNested(\n  signal: NestedSignal,\n  cb: (name: string, signal: Signal<any>) => void\n): void {\n  for (const key in signal) {\n    if (signal.hasOwnProperty(key)) {\n      const value = signal[key];\n      if (value instanceof Signal) {\n        cb(key, value);\n      } else {\n        walkNested(value as NestedSignal, cb);\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {};\n  for (const key of keys) {\n    const parts = key.split(\".\");\n    let subOriginal = original;\n    let subSubset = subset;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      if (!subOriginal[part]) {\n        return {};\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {};\n      }\n      subOriginal = subOriginal[part] as NestedValues;\n      subSubset = subSubset[part] as NestedValues;\n    }\n    const last = parts[parts.length - 1];\n    subSubset[last] = subOriginal[last];\n  }\n  return subset;\n}\n\nexport class SignalsRoot {\n  private _signals: NestedSignal = {};\n\n  constructor() {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath);\n  }\n\n  signal(dotDelimitedPath: string): Signal<any> | null {\n    const parts = dotDelimitedPath.split(\".\");\n    let subSignals = this._signals;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      if (!subSignals[part]) {\n        return null;\n      }\n      subSignals = subSignals[part] as NestedSignal;\n    }\n    const last = parts[parts.length - 1];\n    return subSignals[last] as Signal<any>;\n  }\n\n  add<T extends Signal>(dotDelimitedPath: string, signal: T) {\n    const parts = dotDelimitedPath.split(\".\");\n    let subSignals = this._signals;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      if (!subSignals[part]) {\n        subSignals[part] = {};\n      }\n      subSignals = subSignals[part] as NestedSignal;\n    }\n    const last = parts[parts.length - 1];\n    subSignals[last] = signal;\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath);\n    return signal?.value;\n  }\n\n  set<T>(dotDelimitedPath: string, value: T) {\n    const s = this.upsert(dotDelimitedPath, value);\n    s.value = value;\n  }\n\n  upsert<T>(dotDelimitedPath: string, value: T) {\n    const parts = dotDelimitedPath.split(\".\");\n    let subSignals = this._signals;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      if (!subSignals[part]) {\n        subSignals[part] = {};\n      }\n      subSignals = subSignals[part] as NestedSignal;\n    }\n    const last = parts[parts.length - 1];\n\n    const current = subSignals[last];\n    if (!!current) return current as Signal<T>;\n\n    const signal = new Signal(value);\n    subSignals[last] = signal;\n\n    return signal;\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split(\".\");\n      let subSignals = this._signals;\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i];\n        if (!subSignals[part]) {\n          return;\n        }\n        subSignals = subSignals[part] as NestedSignal;\n      }\n      const last = parts[parts.length - 1];\n      delete subSignals[last];\n    }\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    mergeNested(this._signals, other, onlyIfMissing);\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys);\n  }\n\n  walk(cb: (name: string, signal: Signal<any>) => void) {\n    walkNested(this._signals, cb);\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this._signals, onlyPublic);\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic);\n    if (!shouldIndent) {\n      return JSON.stringify(values);\n    }\n    return JSON.stringify(values, null, 2);\n  }\n\n  public toString() {\n    return this.JSON();\n  }\n}\n", "export const VERSION = '0.20.1';\n", "import { consistentUniqID } from \"../utils/dom\";\nimport { computed, effect, signal } from \"../vendored/preact-core\";\nimport { PluginType } from \"./enums\";\n\nimport {\n  ERR_ALREADY_EXISTS,\n  ERR_BAD_ARGS,\n  ERR_METHOD_NOT_ALLOWED,\n  ERR_NOT_ALLOWED,\n  ERR_NOT_FOUND,\n} from \"./errors\";\nimport { SignalsRoot } from \"./nestedSignals\";\nimport {\n  ActionPlugin,\n  ActionPlugins,\n  AttribtueExpressionFunction,\n  AttributeContext,\n  AttributePlugin,\n  DatastarPlugin,\n  HTMLorSVGElement,\n  InitContext,\n  MacroPlugin,\n  OnRemovalFn,\n  Reactivity,\n  WatcherPlugin,\n} from \"./types\";\nimport { VERSION } from \"./version\";\n\nconst isMacroPlugin = (p: DatastarPlugin): p is MacroPlugin =>\n  p.type === PluginType.Macro;\nconst isWatcherPlugin = (p: DatastarPlugin): p is WatcherPlugin =>\n  p.type === PluginType.Watcher;\nconst isAttributePlugin = (p: DatastarPlugin): p is AttributePlugin =>\n  p.type === PluginType.Attribute;\nconst isActionPlugin = (p: DatastarPlugin): p is ActionPlugin =>\n  p.type === PluginType.Action;\n\nexport class Engine {\n  private _signals = new SignalsRoot();\n  private plugins: AttributePlugin[] = [];\n  private macros: MacroPlugin[] = [];\n  private actions: ActionPlugins = {};\n  private watchers: WatcherPlugin[] = [];\n  private reactivity: Reactivity = { signal, computed, effect };\n  private removals = new Map<Element, { id: string; set: Set<OnRemovalFn> }>();\n\n  get version() {\n    return VERSION;\n  }\n\n  load(...pluginsToLoad: DatastarPlugin[]) {\n    const allLoadedPlugins = new Set<DatastarPlugin>(this.plugins);\n\n    pluginsToLoad.forEach((plugin) => {\n      if (plugin.requiredPlugins) {\n        for (const requiredPluginType of plugin.requiredPlugins) {\n          if (!allLoadedPlugins.has(requiredPluginType)) {\n            // requires other plugin to be loaded\n            throw ERR_NOT_ALLOWED;\n          }\n        }\n      }\n\n      let globalInitializer: ((ctx: InitContext) => void) | undefined;\n      if (isMacroPlugin(plugin)) {\n        if (this.macros.includes(plugin)) {\n          throw ERR_ALREADY_EXISTS;\n        }\n        this.macros.push(plugin);\n      } else if (isWatcherPlugin(plugin)) {\n        if (this.watchers.includes(plugin)) {\n          throw ERR_ALREADY_EXISTS;\n        }\n        this.watchers.push(plugin);\n        globalInitializer = plugin.onGlobalInit;\n      } else if (isActionPlugin(plugin)) {\n        if (!!this.actions[plugin.name]) {\n          throw ERR_ALREADY_EXISTS;\n        }\n        this.actions[plugin.name] = plugin;\n      } else if (isAttributePlugin(plugin)) {\n        if (this.plugins.includes(plugin)) {\n          throw ERR_ALREADY_EXISTS;\n        }\n        this.plugins.push(plugin);\n        globalInitializer = plugin.onGlobalInit;\n      } else {\n        throw ERR_NOT_FOUND;\n      }\n\n      if (globalInitializer) {\n        const that = this; // I hate javascript\n        globalInitializer({\n          get signals() {\n            return that._signals;\n          },\n          actions: this.actions,\n          reactivity: this.reactivity,\n          applyPlugins: this.applyPlugins.bind(this),\n          cleanup: this.cleanup.bind(this),\n        });\n      }\n\n      allLoadedPlugins.add(plugin);\n    });\n\n    this.applyPlugins(document.body);\n  }\n\n  private cleanup(element: Element) {\n    const removalSet = this.removals.get(element);\n    if (removalSet) {\n      for (const removal of removalSet.set) {\n        removal();\n      }\n      this.removals.delete(element);\n    }\n  }\n\n  applyPlugins(rootElement: Element) {\n    const appliedMacros = new Set<MacroPlugin>();\n\n    this.plugins.forEach((p, pi) => {\n      this.walkDownDOM(rootElement, (el) => {\n        if (!pi) this.cleanup(el);\n\n        for (const rawKey in el.dataset) {\n          const rawValue = `${el.dataset[rawKey]}` || \"\";\n          let valueRevised = rawValue;\n\n          if (!rawKey.startsWith(p.name)) continue;\n\n          if (!el.id.length) {\n            el.id = consistentUniqID(el);\n          }\n\n          appliedMacros.clear();\n\n          if (p.tags) {\n            const lowerCaseTag = el.tagName.toLowerCase();\n            const allowed = [...p.tags].some((r) => lowerCaseTag.match(r));\n            if (!allowed) {\n              throw ERR_NOT_ALLOWED;\n            }\n          }\n\n          let keyRaw = rawKey.slice(p.name.length);\n          let [key, ...modifiersWithArgsArr] = keyRaw.split(\".\");\n          if (p.noKey && key.length > 0) {\n            // must have empty key\n            throw ERR_BAD_ARGS;\n          }\n          if (p.mustKey && key.length === 0) {\n            // must have non-empty key\n            throw ERR_BAD_ARGS;\n          }\n          if (key.length) {\n            key = key[0].toLowerCase() + key.slice(1);\n          }\n\n          const modifiersArr = modifiersWithArgsArr.map((m) => {\n            const [label, ...args] = m.split(\"_\");\n            return { label, args };\n          });\n          if (p.onlyMods) {\n            for (const modifier of modifiersArr) {\n              if (!p.onlyMods.has(modifier.label)) {\n                // modifier not allowed\n                throw ERR_NOT_ALLOWED;\n              }\n            }\n          }\n          const mods = new Map<string, string[]>();\n          for (const modifier of modifiersArr) {\n            mods.set(modifier.label, modifier.args);\n          }\n\n          if (p.noVal && valueRevised.length) {\n            // must have empty expression\n            throw ERR_BAD_ARGS;\n          }\n          if (p.mustValue && !valueRevised.length) {\n            // must have non-empty expression\n            throw ERR_BAD_ARGS;\n          }\n\n          const splitRegex = /;|\\n/;\n\n          const macros = [\n            ...(p.macros?.pre || []),\n            ...this.macros,\n            ...(p.macros?.post || []),\n          ];\n          for (const macro of macros) {\n            if (appliedMacros.has(macro)) continue;\n            appliedMacros.add(macro);\n\n            const expressionParts = valueRevised.split(splitRegex);\n            const revisedParts: string[] = [];\n\n            expressionParts.forEach((exp) => {\n              let revised = exp;\n              const matches = [...revised.matchAll(macro.regexp)];\n              if (matches.length) {\n                for (const match of matches) {\n                  if (!match.groups) continue;\n                  const { groups } = match;\n                  const { whole } = groups;\n                  revised = revised.replace(whole, macro.alter(groups));\n                }\n              }\n              revisedParts.push(revised);\n            });\n\n            valueRevised = revisedParts.join(\";\\n\");\n          }\n\n          const that = this; // I hate javascript\n          const ctx: AttributeContext = {\n            get signals() {\n              return that._signals;\n            },\n            applyPlugins: this.applyPlugins.bind(this),\n            cleanup: this.cleanup.bind(this),\n            actions: this.actions,\n            reactivity: this.reactivity,\n            el,\n            rawKey,\n            key,\n            rawValue: rawValue,\n            value: valueRevised,\n            expr: () => {\n              throw ERR_METHOD_NOT_ALLOWED;\n            },\n            mods: mods,\n          };\n\n          if (!p.noGenExpr?.(ctx) && !p.noVal && valueRevised.length) {\n            const statements = valueRevised\n              .split(splitRegex)\n              .map((s) => s.trim())\n              .filter((s) => s.length);\n            statements[statements.length - 1] = `return ${\n              statements[statements.length - 1]\n            }`;\n            const j = statements.map((s) => `  ${s}`).join(\";\\n\");\n            const fnContent = `try{${j}}catch(e){console.error(\\`Error evaluating Datastar expression:\\n${j.replaceAll(\n              \"`\",\n              \"\\\\`\"\n            )}\\n\\nError: \\${e.message}\\n\\nCheck if the expression is valid before raising an issue.\\`.trim());\\ndebugger\\n}`;\n            try {\n              const argumentNames = p.argNames || [];\n              const fn = new Function(\n                \"ctx\",\n                ...argumentNames,\n                fnContent\n              ) as AttribtueExpressionFunction;\n              ctx.expr = fn;\n            } catch (e) {\n              const err = new Error(`${e}\\nwith\\n${fnContent}`);\n              console.error(err);\n              debugger;\n            }\n          }\n\n          const removal = p.onLoad(ctx);\n          if (removal) {\n            if (!this.removals.has(el)) {\n              this.removals.set(el, {\n                id: el.id,\n                set: new Set(),\n              });\n            }\n            this.removals.get(el)!.set.add(removal);\n          }\n        }\n      });\n    });\n  }\n\n  private walkDownDOM(\n    element: Element | null,\n    callback: (el: HTMLorSVGElement) => void,\n    siblingOffset = 0\n  ) {\n    if (\n      !element ||\n      !(element instanceof HTMLElement || element instanceof SVGElement)\n    ) {\n      return null;\n    }\n\n    callback(element);\n\n    siblingOffset = 0;\n    element = element.firstElementChild;\n    while (element) {\n      this.walkDownDOM(element, callback, siblingOffset++);\n      element = element.nextElementSibling;\n    }\n  }\n}\n", "import { ActionsMacro, SignalsGetMacro, SignalsSetMacro } from \"../plugins\";\nimport { Computed } from \"../plugins/official/attributes/core/computed\";\nimport { MergeSignals } from \"../plugins/official/attributes/core/mergeSignals\";\nimport { Star } from \"../plugins/official/attributes/core/star\";\nimport { Engine } from \"./engine\";\n\nexport { VERSION } from \"./consts\";\n\nexport type * from \"./types\";\n\nconst ds = new Engine();\nds.load(\n    Star,\n    ActionsMacro,\n    SignalsSetMacro,\n    SignalsGetMacro,\n    MergeSignals,\n    Computed,\n);\n\nexport const Datastar = ds;\n", "import { Datastar } from \"../engine\";\n\nDatastar.load();\n"],
  "mappings": "mBAEO,IAAMA,EAAW,WACXC,GAAiB,iBACjBC,GAAmB,mBAkBzB,IAAMC,GAA0B,cAsBhC,IAAMC,EAAqB,CAE9B,MAAO,QAEP,MAAO,QAEP,MAAO,QAEP,QAAS,UAET,OAAQ,SAER,OAAQ,SAER,MAAO,QAEP,iBAAkB,kBACtB,EAGaC,GAAoBD,EAAmB,MAGvCE,EAAa,CAEtB,eAAgB,2BAEhB,aAAc,yBAEd,gBAAiB,4BAEjB,cAAe,0BAEf,cAAe,yBACnB,EC5EA,IAAMC,EAAOC,GAAiB,CAC1B,IAAM,EAAI,IAAI,MACd,SAAE,KAAO,GAAGC,CAAQ,GAAGD,CAAI,GACpB,CACX,EAEaE,EAAeH,EAAI,GAAG,EACtBI,EAAqBJ,EAAI,GAAG,EAC5BK,EAAgBL,EAAI,GAAG,EACvBM,EAAkBN,EAAI,GAAG,EACzBO,GAAyBP,EAAI,GAAG,EAChCQ,GAA0BR,EAAI,GAAG,ECQ9C,eAAsBS,GAClBC,EACAC,EACF,CACE,IAAMC,EAASF,EAAO,UAAU,EAC5BG,EACJ,KAAO,EAAEA,EAAS,MAAMD,EAAO,KAAK,GAAG,MACnCD,EAAQE,EAAO,KAAK,CAE5B,CAeO,SAASC,GACZC,EACF,CACE,IAAIC,EACAC,EACAC,EACAC,EAAyB,GAG7B,OAAO,SAAiBC,EAAiB,CACjCJ,IAAW,QACXA,EAASI,EACTH,EAAW,EACXC,EAAc,IAGdF,EAASK,GAAOL,EAAQI,CAAG,EAG/B,IAAME,EAAYN,EAAO,OACrBO,EAAY,EAChB,KAAON,EAAWK,GAAW,CACrBH,IACIH,EAAOC,CAAQ,IAAM,KACrBM,EAAY,EAAEN,GAGlBE,EAAyB,IAI7B,IAAIK,EAAU,GACd,KAAOP,EAAWK,GAAaE,IAAY,GAAI,EAAEP,EAC7C,OAAQD,EAAOC,CAAQ,EAAG,CACtB,IAAK,IACGC,IAAgB,KAChBA,EAAcD,EAAWM,GAE7B,MAEJ,IAAK,IACDJ,EAAyB,GAC7B,IAAK,IACDK,EAAUP,EACV,KACR,CAGJ,GAAIO,IAAY,GAGZ,MAIJT,EAAOC,EAAO,SAASO,EAAWC,CAAO,EAAGN,CAAW,EACvDK,EAAYN,EACZC,EAAc,EAClB,CAEIK,IAAcD,EACdN,EAAS,OACFO,IAAc,IAGrBP,EAASA,EAAO,SAASO,CAAS,EAClCN,GAAYM,EAEpB,CACJ,CASO,SAASE,GACZC,EACAC,EACAC,EACF,CACE,IAAIC,EAAUC,GAAW,EACnBC,EAAU,IAAI,YAGpB,OAAO,SAAgBC,EAAkBd,EAAqB,CAC1D,GAAIc,EAAK,SAAW,EAEhBJ,IAAYC,CAAO,EACnBA,EAAUC,GAAW,UACdZ,EAAc,EAAG,CAGxB,IAAMe,EAAQF,EAAQ,OAAOC,EAAK,SAAS,EAAGd,CAAW,CAAC,EACpDgB,EAAchB,GACfc,EAAKd,EAAc,CAAC,IAAM,GAAqB,EAAI,GAClDiB,EAAQJ,EAAQ,OAAOC,EAAK,SAASE,CAAW,CAAC,EAEvD,OAAQD,EAAO,CACX,IAAK,OAGDJ,EAAQ,KAAOA,EAAQ,KACjBA,EAAQ,KAAO;AAAA,EAAOM,EACtBA,EACN,MACJ,IAAK,QACDN,EAAQ,MAAQM,EAChB,MACJ,IAAK,KACDT,EAAKG,EAAQ,GAAKM,CAAK,EACvB,MACJ,IAAK,QACD,IAAMC,EAAQ,SAASD,EAAO,EAAE,EAC3B,MAAMC,CAAK,GACZT,EAAQE,EAAQ,MAAQO,CAAK,EAEjC,KACR,CACJ,CACJ,CACJ,CAEA,SAASf,GAAOgB,EAAeC,EAAe,CAC1C,IAAMC,EAAM,IAAI,WAAWF,EAAE,OAASC,EAAE,MAAM,EAC9C,OAAAC,EAAI,IAAIF,CAAC,EACTE,EAAI,IAAID,EAAGD,EAAE,MAAM,EACZE,CACX,CAEA,SAAST,IAAiC,CAKtC,MAAO,CACH,KAAM,GACN,MAAO,GACP,GAAI,GACJ,MAAO,MACX,CACJ,CCzLO,IAAMU,GAAyB,oBAEhCC,GAAuB,IACvBC,GAAc,gBA2Db,SAASC,GAAiBC,EAAoB,CACjD,OAAQC,EACR,QAASC,EACT,OAAQC,EACR,UAAAC,EACA,QAAAC,EACA,QAAAC,EACA,eAAAC,EACA,MAAOC,EACP,YAAAC,EAAc,EACd,eAAAC,EAAiB,IACjB,cAAAC,EAAgB,GAChB,GAAGC,CACP,EAAyB,CACrB,OAAO,IAAI,QAAc,CAACC,EAASC,IAAW,CAC1C,IAAIC,EAAU,EAGRC,EAAU,CAAE,GAAGd,CAAa,EAC7Bc,EAAQ,SACTA,EAAQ,OAASpB,IAGrB,IAAIqB,EACJ,SAASC,GAAqB,CAC1BD,EAAqB,MAAM,EACtB,SAAS,QACVE,EAAO,CAEf,CAEKZ,GACD,SAAS,iBAAiB,mBAAoBW,CAAkB,EAGpE,IAAIE,EAAgBvB,GAChBwB,EAAa,EACjB,SAASC,GAAU,CACf,SAAS,oBACL,mBACAJ,CACJ,EACA,OAAO,aAAaG,CAAU,EAC9BJ,EAAqB,MAAM,CAC/B,CAGAhB,GAAa,iBAAiB,QAAS,IAAM,CACzCqB,EAAQ,EACRT,EAAQ,CACZ,CAAC,EAED,IAAMU,EAAQf,GAAc,OAAO,MAC7BgB,EAASrB,GACX,UAEE,CAAC,EAEP,eAAegB,GAAS,CACpBF,EAAuB,IAAI,gBAC3B,GAAI,CACA,IAAMQ,EAAW,MAAMF,EAAMvB,EAAO,CAChC,GAAGY,EACH,QAAAI,EACA,OAAQC,EAAqB,MACjC,CAAC,EAED,MAAMO,EAAOC,CAAQ,EAErB,MAAMC,GACFD,EAAS,KACTE,GAASC,GAAaC,GAAO,CACrBA,EAEAb,EAAQlB,EAAW,EAAI+B,EAGvB,OAAOb,EAAQlB,EAAW,CAElC,EAAIgC,GAAU,CACVV,EAAgBU,CACpB,EAAG1B,CAAS,CAAC,CACjB,EAEAC,IAAU,EACViB,EAAQ,EACRT,EAAQ,CACZ,OAASkB,EAAK,CACV,GAAI,CAACd,EAAqB,OAAO,QAE7B,GAAI,CAEA,IAAMe,EAAgB1B,IAAUyB,CAAG,GAAKX,EACxC,OAAO,aAAaC,CAAU,EAC9BA,EAAa,OAAO,WAAWF,EAAQa,CAAQ,EAC/CZ,GAAiBX,EACjBW,EAAgB,KAAK,IAAIA,EAAeV,CAAc,EACtDK,IACIA,GAAWJ,GAEXW,EAAQ,EAERR,EAAOmB,EAAuB,GAE9B,QAAQ,MACJ,4BAA4BrB,EAAK,MAAM,IAAIZ,EAAM,SAAS,CAAC,aAAagC,CAAQ,IACpF,CAER,OAASE,EAAU,CAEfZ,EAAQ,EACRR,EAAOoB,CAAQ,CACnB,CAER,CACJ,CAEAf,EAAO,CACX,CAAC,CACL,CCtLO,IAAMgB,EAAqB,GAAGC,CAAQ,OAChCC,GAAiB,GAAGD,CAAQ,YAC5BE,EAAiB,GAAGF,CAAQ,YAC5BG,GAAU,UACVC,GAAW,WA+BjB,SAASC,EAEZC,EACAC,EACF,CACE,SAAS,iBACLR,EACCS,GAAyC,CACtC,GAAIA,EAAM,OAAO,MAAQF,EAAW,OACpC,GAAM,CAAE,QAAAG,CAAQ,EAAID,EAAM,OAC1BD,EAAGE,CAAO,CACd,CACJ,CACJ,CClCA,IAAMC,GAAkBC,GAAa,GAAGA,CAAG,GAAG,SAAS,mBAAmB,EAO1E,SAASC,GAAYC,EAAcC,EAAiC,CAClE,SAAS,cACP,IAAI,YAA8BC,EAAoB,CACpD,OAAQ,CAAE,KAAAF,EAAM,QAAAC,CAAQ,CAC1B,CAAC,CACH,CACF,CAEO,SAASE,EAAeC,EAA8B,CAC3D,MAAO,OAAOC,EAAKC,EAAKC,IAA0B,CAChD,GAAI,CAAGD,GAAK,OAAQ,MAAME,EAE1B,IAAMC,EAAoBF,GAAM,mBAAqB,GAC/CG,EAAU,OAAO,OACrB,CACE,eAAgB,mBAChB,CAACC,EAAgB,EAAG,EACtB,EACAJ,GAAM,OACR,EACM,CAAE,QAAAK,EAAS,GAAI,CAAE,GAAIC,CAAK,CAAE,EAAIR,EAChCS,EAAcF,EAAQ,KAAK,GAAOH,CAAiB,EAEzDV,GAAYgB,GAAS,CAAE,KAAAF,CAAK,CAAC,EAE7B,IAAMG,EAAc,IAAI,IAAIV,EAAK,OAAO,SAAS,MAAM,EAGvDF,EAASA,EAAO,YAAY,EAE5B,IAAMa,EAA4B,CAChC,OAAAb,EACA,QAAAM,EACA,UAAYQ,GAAQ,CAClB,GAAI,CAACA,EAAI,MAAM,WAAWC,CAAQ,EAChC,OAEF,IAAMnB,EAAOkB,EAAI,MACXE,EAAyC,CAAC,EAE1CC,EAAQH,EAAI,KAAK,MAAM;AAAA,CAAI,EACjC,QAAWI,KAAQD,EAAO,CACxB,IAAME,EAAaD,EAAK,QAAQ,GAAG,EAC7BE,EAAMF,EAAK,MAAM,EAAGC,CAAU,EAChCE,EAAWL,EAAaI,CAAG,EAC1BC,IACHA,EAAW,CAAC,EACZL,EAAaI,CAAG,EAAIC,GAEtB,IAAMC,EAAQJ,EAAK,MAAMC,EAAa,CAAC,EAAE,KAAK,EAC9CE,EAAS,KAAKC,CAAK,CACrB,CAEA,IAAMzB,EAAkC,CAAC,EACzC,OAAW,CAACuB,EAAKH,CAAK,IAAK,OAAO,QAAQD,CAAY,EACpDnB,EAAQuB,CAAG,EAAIH,EAAM,KAAK;AAAA,CAAI,EAKhCtB,GAAYC,EAAMC,CAAO,CAC3B,EACA,QAAUH,GAAQ,CAChB,GAAID,GAAeC,CAAG,EAEpB,MAAMA,EAGJA,GACF,QAAQ,MAAMA,EAAI,OAAO,CAE7B,EACA,QAAS,IAAM,CACbC,GAAY4B,GAAU,CAAE,KAAAd,CAAK,CAAC,CAChC,CACF,EAEA,GAAIT,IAAW,MAAO,CACpB,IAAMwB,EAAc,IAAI,gBAAgBZ,EAAY,MAAM,EAC1DY,EAAY,OAAOT,EAAUL,CAAW,EACxCE,EAAY,OAASY,EAAY,SAAS,CAC5C,MACEX,EAAI,KAAOH,EAGb,GAAI,CACF,IAAMe,EAAab,EAAY,SAAS,EACxC,MAAMc,GAAiBD,EAAYZ,CAAG,CACxC,OAASnB,EAAK,CACZ,GAAI,CAACD,GAAeC,CAAG,EACrB,MAAMA,CAOV,CACF,CACF,CCjHO,IAAMiC,GAA0B,CACrC,OACA,KAAM,SACN,GAAIC,EAAe,QAAQ,CAC7B,ECJO,IAAMC,GAAuB,CAClC,OACA,KAAM,MACN,GAAIC,EAAe,KAAK,CAC1B,ECJO,IAAMC,GAAyB,CACpC,OACA,KAAM,QACN,GAAIC,EAAe,OAAO,CAC5B,ECJO,IAAMC,GAAwB,CACnC,OACA,KAAM,OACN,GAAIC,EAAe,MAAM,CAC3B,ECJO,IAAMC,GAAuB,CAClC,OACA,KAAM,MACN,GAAIC,EAAe,KAAK,CAC1B,ECJO,IAAMC,GAA0B,CACrC,OACA,KAAM,YACN,GAAI,CAACC,EAAGC,IAAS,CACf,GAAI,CAAC,UAAU,UAEb,MAAMC,EAER,UAAU,UAAU,UAAUD,CAAI,CACpC,CACF,ECZO,IAAME,GAA0B,CACrC,OACA,KAAM,YACN,GAAI,CAACC,EAAKC,EAAeC,IAAU,CACjC,IAAMC,EAASH,EAAI,QAAQ,OAAOC,EAAe,CAAC,EAClDE,EAAO,OAASD,CAClB,CACF,ECPO,IAAME,GAAuB,CAClC,OACA,KAAM,SACN,GAAI,CAACC,EAAKC,EAAQC,IAAa,CAC7B,IAAMC,EAAK,IAAI,OAAOF,CAAM,EAC5BD,EAAI,QAAQ,KACV,CAACI,EAAMC,IAAWF,EAAG,KAAKC,CAAI,IAAMC,EAAO,MAAQH,EACrD,CACF,CACF,ECTO,IAAMI,GAA0B,CACrC,OACA,KAAM,YACN,GAAI,CAACC,EAAKC,IAAW,CACnB,IAAMC,EAAK,IAAI,OAAOD,CAAM,EAC5BD,EAAI,QAAQ,KACV,CAACG,EAAMC,IAAWF,EAAG,KAAKC,CAAI,IAAMC,EAAO,MAAQ,CAACA,EAAO,MAC7D,CACF,CACF,ECRO,IAAMC,GAAyB,CACpC,OACA,KAAM,WACN,GAAI,CACFC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,KAAK,IACVD,EACA,KAAK,IACHC,GACEJ,EAAIC,IAAWC,EAASD,IAAYG,EAASD,GAAUA,CAC3D,CACF,CAEJ,ECnBO,IAAME,GAA4B,CACvC,OACA,KAAM,cACN,GAAI,CACFC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,KAAK,MACV,KAAK,IACHD,EACA,KAAK,IACHC,GACEJ,EAAIC,IAAWC,EAASD,IAAYG,EAASD,GAAUA,CAC3D,CACF,CACF,CAEJ,ECrBO,IAAME,GAAoB,CAC/B,OACA,KAAM,MACN,GAAI,CACFC,EACAC,EACAC,EACAC,EACAC,EACAC,KAESJ,EAAIC,IAAWC,EAASD,IAAYG,EAASD,GAAUA,CAEpE,ECbO,IAAME,GAAuB,CAClC,OACA,KAAM,SACN,GAAI,CACFC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,KAAK,OACRJ,EAAIC,IAAWC,EAASD,IAAYG,EAASD,GAAUA,CAC3D,CAEJ,ECRO,IAAME,GAAkB,GAAGC,CAAQ,aAC7BC,GAA0B,GAAGF,EAAe,WAE5CG,GAA6B,CACxC,OACA,KAAM,YACN,MAAO,GACP,OAASC,GAAQ,CACf,GAAM,CAAE,MAAAC,EAAO,QAAAC,EAAS,GAAAC,CAAG,EAAIH,EACzBI,EAASF,EAAQ,OAAOD,EAAO,EAAK,EAEpCI,EAAWC,GAAyC,CACxD,GAAM,CACJ,KAAAC,EACA,QAAS,CAAE,KAAAC,CAAK,CAClB,EAAIF,EAAM,OACV,GAAIE,IAASL,EAAG,GAChB,OAAQI,EAAM,CACZ,KAAKE,GACHL,EAAO,MAAQ,GACf,MACF,KAAKM,GACHN,EAAO,MAAQ,GACf,KACJ,CACF,EAEA,gBAAS,iBAAiBO,EAAoBN,CAAO,EAE9C,IAAM,CACX,SAAS,oBAAoBM,EAAoBN,CAAO,CAC1D,CACF,CACF,ECvCO,IAAMO,GAA4B,CACvC,OACA,KAAM,WACN,QAAS,GACT,OAASC,GAAQ,CACf,GAAM,CACJ,QAAAC,EACA,IAAAC,EACA,KAAAC,EACA,WAAY,CAAE,SAAAC,CAAS,CACzB,EAAIJ,EAEEK,EAAID,EAAS,IACVD,EAAKH,CAAG,CAChB,EACD,OAAAC,EAAQ,IAAIC,EAAKG,CAAC,EAEX,IAAM,CACXJ,EAAQ,OAAOC,CAAG,CACpB,CACF,CACF,EClBA,IAAMI,GAAa,YAGNC,GAAgC,CAC3C,OACA,KAAM,eACN,SAAU,IAAI,IAAI,CAACD,EAAU,CAAC,EAC9B,OAASE,GAA0B,CACjC,GAAM,CAAE,GAAAC,EAAI,KAAAC,EAAM,KAAAC,CAAK,EAAIH,EACrBI,EAAoCF,EAAKF,CAAG,EAClDA,EAAI,QAAQ,MAAMI,EAAqBD,EAAK,IAAIL,EAAU,CAAC,EAC3D,OAAOG,EAAG,QAAQD,EAAI,MAAM,CAC9B,CACF,ECjBO,IAAMK,GAAwB,CACjC,OACA,KAAM,OACN,OAAQ,IAAM,CACV,MAAM,sCAAsC,CAChD,CACJ,ECdO,IAAMC,GAAYC,GACrBA,EAAI,QACA,yBACA,CAACC,EAAGC,KAASA,EAAM,IAAM,IAAMD,EAAE,YAAY,CACjD,EAESE,EAAgBH,GAAgBA,EAAI,KAAK,IAAM,OCO5D,IAAMI,GAAe,+CACfC,GAAoB,CAAC,SAAU,QAAS,SAAS,EAE1CC,GAAwB,CACnC,OACA,KAAM,OACN,OAASC,GAAQ,CACf,GAAM,CACJ,GAAAC,EACA,MAAAC,EACA,KAAAC,EACA,IAAAC,EACA,QAAAC,EACA,WAAY,CAAE,OAAAC,CAAO,CACvB,EAAIN,EAEAO,EAAgB,IAAM,CAAC,EACvBC,EAAsB,IAAM,CAAC,EAE3BC,EAAkBL,IAAQ,GAEhC,GAAIK,EAAiB,CACnB,IAAMC,EAAaR,EAGnB,GAAI,OAAOQ,GAAe,SACxB,MAAM,IAAI,MAAM,oBAAoB,EAEtC,GAAIA,EAAW,SAAS,GAAG,EACzB,MAAM,IAAI,MAAM,mBAAmB,EAGrC,IAAMC,EAAMV,EAAG,QAAQ,YAAY,EAC/BW,EAAkD,GAChDC,EAAUF,EAAI,SAAS,OAAO,EAC9BG,EAAOb,EAAG,aAAa,MAAM,EAC7Bc,EACJJ,EAAI,SAAS,UAAU,GAAME,GAAWC,IAAS,WAC/CC,IACFH,EAAgB,IAEDC,GAAWC,IAAS,WAEnCF,EAAgB,GAElB,IAAMI,EAAWL,EAAI,SAAS,QAAQ,EAChCM,EAAUN,EAAI,SAAS,OAAO,GAAME,GAAWC,IAAS,QACxDI,EAASL,GAAWC,IAAS,OAI/BG,IACWhB,EAAG,aAAa,MAAM,GACxB,QACTA,EAAG,aAAa,OAAQS,CAAU,GAItCL,EAAQ,OAAOK,EAAYE,CAAa,EAExCL,EAAgB,IAAM,CACpB,IAAMY,EAAW,UAAWlB,EACtBmB,EAAIf,EAAQ,MAAMK,CAAU,EAC5BW,EAAO,GAAGD,CAAC,GACjB,GAAIL,GAAcE,EAAS,CACzB,IAAMK,EAAQrB,EACVc,EACFO,EAAM,QAAU,CAAGF,GAAKA,IAAM,OACrBH,IAGTK,EAAM,QAAUD,IAASC,EAAM,MAEnC,SAAW,CAAAJ,EAEJ,GAAIF,EAAU,CACnB,IAAMO,EAAStB,EACXsB,EAAO,SACT,MAAM,KAAKA,EAAO,OAAO,EAAE,QAASC,GAAQ,CACtCA,GAAK,WACL,MAAM,QAAQJ,CAAC,GAAK,OAAOA,GAAM,SACnCI,EAAI,SAAWJ,EAAE,SAASI,EAAI,KAAK,EAC1B,OAAOJ,GAAM,SACtBI,EAAI,SAAWJ,IAAM,OAAOI,EAAI,KAAK,EAErCA,EAAI,SAAWJ,EAEnB,CAAC,EAEDG,EAAO,MAAQF,CAEnB,MAAWF,EACTlB,EAAG,MAAQoB,EAEXpB,EAAG,aAAa,QAASoB,CAAI,CAEjC,EAEAb,EAAsB,SAAY,CAChC,GAAIU,EAAQ,CACV,IAAMO,EAAQ,CAAC,GAAKxB,GAAyB,OAAS,CAAC,CAAE,EACvDyB,EAAwB,CAAC,EACzBC,EAAqB,CAAC,EACtBC,EAAqB,CAAC,EAExB,MAAM,QAAQ,IACZH,EAAM,IAAKI,IACF,IAAI,QAAeC,IAAY,CACpC,IAAMC,EAAS,IAAI,WACnBA,EAAO,OAAS,IAAM,CACpB,GAAI,OAAOA,EAAO,QAAW,SAE3B,MAAMC,EAER,IAAMC,GAAQF,EAAO,OAAO,MAAMlC,EAAY,EAC9C,GAAI,CAACoC,IAAO,OAEV,MAAMD,EAERN,EAAY,KAAKO,GAAM,OAAO,QAAQ,EACtCN,EAAS,KAAKM,GAAM,OAAO,IAAI,EAC/BL,EAAS,KAAKC,GAAE,IAAI,CACtB,EACAE,EAAO,UAAY,IAAMD,GAAQ,MAAM,EACvCC,EAAO,cAAcF,EAAC,CACxB,CAAC,CACF,CACH,EAEAxB,EAAQ,IAAIK,EAAYgB,CAAW,EACnC,IAAMQ,GAAW,GAAGxB,CAAU,QAC5ByB,GAAW,GAAGzB,CAAU,QACtBwB,MAAY7B,GACdA,EAAQ,OAAO6B,GAAUP,CAAQ,EAE/BQ,MAAY9B,GACdA,EAAQ,OAAO8B,GAAUP,CAAQ,EAEnC,MACF,CAEA,IAAMQ,EAAU/B,EAAQ,MAAMK,CAAU,EAClCY,EAASrB,GAA4BA,EAE3C,GAAI,OAAOmC,GAAY,SAAU,CAC/B,IAAMhB,EAAI,OAAOE,EAAM,OAASA,EAAM,aAAa,OAAO,CAAC,EAC3DjB,EAAQ,IAAIK,EAAYU,CAAC,CAC3B,SAAW,OAAOgB,GAAY,SAAU,CACtC,IAAMhB,EAAIE,EAAM,OAASA,EAAM,aAAa,OAAO,GAAK,GACxDjB,EAAQ,IAAIK,EAAYU,CAAC,CAC3B,SAAW,OAAOgB,GAAY,UAC5B,GAAIrB,EAAY,CACd,IAAMK,EAAIE,EAAM,SAAWA,EAAM,aAAa,SAAS,IAAM,OAC7DjB,EAAQ,IAAIK,EAAYU,CAAC,CAC3B,KAAO,CACL,IAAMA,EAAI,GAAQE,EAAM,OAASA,EAAM,aAAa,OAAO,GAC3DjB,EAAQ,IAAIK,EAAYU,CAAC,CAC3B,SACS,SAAOgB,EAAY,KACvB,GAAI,MAAM,QAAQA,CAAO,EAAG,CAEjC,GAAIpB,EAAU,CAGZ,IAAMqB,EADkB,CAAC,GADVpC,EACoB,eAAe,EAE/C,OAAQuB,GAAQA,EAAI,QAAQ,EAC5B,IAAKA,GAAQA,EAAI,KAAK,EACzBnB,EAAQ,IAAIK,EAAY2B,CAAc,CACxC,KAAO,CAEL,IAAMjB,EAAI,KAAK,UAAUE,EAAM,MAAM,MAAM,GAAG,CAAC,EAC/CjB,EAAQ,IAAIK,EAAYU,CAAC,CAC3B,CACA,QAAQ,IAAIE,EAAM,KAAK,CACzB,KAEE,OAAMgB,EAEV,CACF,KAAO,CAEL,IAAMC,EAAWC,GAASpC,CAAG,EAC7BG,EAAgB,IAAM,CACpB,IAAML,EAAQC,EAAKH,CAAG,EAClBoB,EACA,OAAOlB,GAAU,SACnBkB,EAAIlB,EAEJkB,EAAI,KAAK,UAAUlB,CAAK,EAEtB,CAACkB,GAAKA,IAAM,SAAWA,IAAM,QAAUA,IAAM,YAC/CnB,EAAG,gBAAgBsC,CAAQ,EAE3BtC,EAAG,aAAasC,EAAUnB,CAAC,CAE/B,CACF,CAEIX,GACFX,GAAkB,QAAS2C,GAAU,CACnCxC,EAAG,iBAAiBwC,EAAOjC,CAAmB,CAChD,CAAC,EAGH,IAAMkC,EAA+BpC,EAAO,SAAY,CACtDC,EAAc,CAChB,CAAC,EAED,MAAO,IAAM,CACXmC,EAA6B,EAEzBjC,GACFX,GAAkB,QAAS2C,GAAU,CACnCxC,EAAG,oBAAoBwC,EAAOjC,CAAmB,CACnD,CAAC,CAEL,CACF,CACF,EC/NO,IAAMmC,GAAyB,CACpC,OACA,KAAM,QACN,MAAO,GACP,UAAW,GAEX,OAASC,GACAA,EAAI,WAAW,OAAO,IAAM,CACjC,IAAMC,EAAkBD,EAAI,KAAKA,CAAG,EACpC,OAAW,CAACE,EAAGC,CAAC,IAAK,OAAO,QAAQF,CAAO,EAAG,CAC5C,IAAMG,EAAaF,EAAE,MAAM,GAAG,EAC1BC,EACFH,EAAI,GAAG,UAAU,IAAI,GAAGI,CAAU,EAElCJ,EAAI,GAAG,UAAU,OAAO,GAAGI,CAAU,CAEzC,CACF,CAAC,CAEL,EC3BO,SAASC,GAASC,EAA4B,CACjD,GAAI,CAACA,GAAQA,GAAM,SAAW,EAAG,MAAO,GAExC,QAAWC,KAAOD,EAAM,CACpB,GAAIC,EAAI,SAAS,IAAI,EACjB,OAAO,OAAOA,EAAI,QAAQ,KAAM,EAAE,CAAC,EAChC,GAAIA,EAAI,SAAS,GAAG,EACvB,OAAO,OAAOA,EAAI,QAAQ,IAAK,EAAE,CAAC,EAAI,IAG1C,GAAI,CACA,OAAO,WAAWA,CAAG,CACzB,MAAY,CAAC,CACjB,CAEA,MAAO,EACX,CAEO,SAASC,EACZF,EACAC,EACAE,EAAe,GACjB,CACE,OAAKH,EACEA,EAAK,SAASC,CAAG,GAAKE,EADX,EAEtB,CCvBO,SAASC,GACZC,EACAC,EACAC,EAAU,GACVC,EAAW,GACC,CACZ,IAAIC,EAAQ,GAENC,EAAa,IAAMD,GAAS,aAAaA,CAAK,EAEpD,OAAO,YAAoBE,EAAa,CACpCD,EAAW,EAEPH,GAAW,CAACE,GACZJ,EAAS,GAAGM,CAAI,EAGpBF,EAAQ,WAAW,IAAM,CACjBD,GACAH,EAAS,GAAGM,CAAI,EAEpBD,EAAW,CACf,EAAGJ,CAAI,CACX,CACJ,CAEO,SAASM,GACZP,EACAC,EACAC,EAAU,GACVC,EAAW,GACC,CACZ,IAAIK,EAAU,GAEd,OAAO,YAAoBF,EAAa,CAChCE,IAEAN,GACAF,EAAS,GAAGM,CAAI,EAGpBE,EAAU,GACV,WAAW,IAAM,CACbA,EAAU,GACNL,GACAH,EAAS,GAAGM,CAAI,CAExB,EAAGL,CAAI,EACX,CACJ,CCvCA,IAAMQ,GAAmB,IAAI,IAAI,CAC/B,SACA,OACA,UACA,UACA,WACA,WACA,SACA,SACF,CAAC,EAEGC,GAAwB,GAGfC,GAAsB,CACjC,OACA,KAAM,KACN,QAAS,GACT,UAAW,GACX,SAAU,CAAC,KAAK,EAChB,OAASC,GAAQ,CACf,GAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,CAAK,EAAIH,EAEtBI,EAAsCJ,EAAI,GAC1CA,EAAI,KAAK,IAAI,QAAQ,IACvBI,EAAS,QAGX,IAAIC,EAAYC,GAAgB,CAC9BH,EAAKH,EAAKM,CAAG,CACf,EAEMC,EAAeP,EAAI,KAAK,IAAI,UAAU,EAC5C,GAAIO,EAAc,CAChB,IAAMC,EAAOC,GAASF,CAAY,EAC5BG,EAAUC,EAAQJ,EAAc,UAAW,EAAK,EAChDK,EAAWD,EAAQJ,EAAc,UAAW,EAAI,EACtDF,EAAWQ,GAASR,EAAUG,EAAME,EAASE,CAAQ,CACvD,CAEA,IAAME,EAAed,EAAI,KAAK,IAAI,UAAU,EAC5C,GAAIc,EAAc,CAChB,IAAMN,EAAOC,GAASK,CAAY,EAC5BJ,EAAUC,EAAQG,EAAc,SAAU,EAAI,EAC9CF,EAAWD,EAAQG,EAAc,UAAW,EAAK,EACvDT,EAAWU,GAASV,EAAUG,EAAME,EAASE,CAAQ,CACvD,CAEA,IAAMI,EAAuC,CAC3C,QAAS,GACT,QAAS,GACT,KAAM,EACR,EACKhB,EAAI,KAAK,IAAI,SAAS,IAAGgB,EAAY,QAAU,IAChDhB,EAAI,KAAK,IAAI,SAAS,IAAGgB,EAAY,QAAU,IAC/ChB,EAAI,KAAK,IAAI,MAAM,IAAGgB,EAAY,KAAO,IAEjB,CAAC,GAAGhB,EAAI,KAAK,KAAK,CAAC,EAAE,OAC9CE,GAAQ,CAACL,GAAiB,IAAIK,CAAG,CACpC,EAEoB,QAASe,GAAa,CACxC,IAAMC,EAAclB,EAAI,KAAK,IAAIiB,CAAQ,GAAK,CAAC,EACzCE,EAAKd,EAuBXA,EAtBwB,IAAM,CAC5B,IAAMC,EAAM,MACNc,EAAOd,EAAIW,CAAQ,EACrBI,EAEJ,GAAI,OAAOD,GAAS,WAClBC,EAAQD,EAAK,GAAGF,CAAW,UAClB,OAAOE,GAAS,UACzBC,EAAQD,UACC,OAAOA,GAAS,SAAU,CACnC,IAAME,EAAYF,EAAK,YAAY,EAAE,KAAK,EACpCjB,EAAOe,EAAY,KAAK,EAAE,EAAE,YAAY,EAAE,KAAK,EACrDG,EAAQC,IAAcnB,CACxB,KAEE,OAAMoB,EAGJF,GACFF,EAAGb,CAAG,CAEV,CAEF,CAAC,EAED,IAAMkB,EAAYC,GAASvB,CAAG,EAAE,YAAY,EAC5C,OAAQsB,EAAW,CACjB,IAAK,OACH,OAAAnB,EAAS,EACT,OAAOL,EAAI,GAAG,QAAQ,OACf,IAAM,CAAC,EAEhB,IAAK,MACH,IAAI0B,EACEC,EAAM,IAAM,CAChBtB,EAAS,EACTqB,EAAQ,sBAAsBC,CAAG,CACnC,EACA,OAAAD,EAAQ,sBAAsBC,CAAG,EAE1B,IAAM,CACPD,GAAO,qBAAqBA,CAAK,CACvC,EAEF,IAAK,iBACH,OAAO1B,EAAI,WAAW,OAAO,IAAM,CACjC,IAAM4B,EAAoB5B,EAAI,KAAK,IAAI,QAAQ,EACzC6B,EAAU7B,EAAI,QAAQ,KAAK,GAAO4B,CAAiB,EACrD9B,KAA0B+B,IAC5B/B,GAAwB+B,EACxBxB,EAAS,EAEb,CAAC,EAEH,QAEE,GADoBL,EAAI,KAAK,IAAI,SAAS,EACzB,CACfI,EAAS,SACT,IAAMe,EAAKd,EACPyB,EAAS,GAabzB,EAZ+B0B,GAAc,CAC3C,IAAMC,EAAaD,GAAG,OACtB,GAAI,CAACC,EAAY,OACjB,IAAMC,EAAOhC,EAAG,KAAO+B,EAAW,GAC9BC,GAAQH,IACVA,EAAS,IAEP,CAACG,GAAQ,CAACH,IACZX,EAAGY,CAAC,EACJD,EAAS,GAEb,CAEF,CAEA,OAAA1B,EAAO,iBAAiBoB,EAAWnB,EAAUW,CAAW,EACjD,IAAM,CAEXZ,EAAO,oBAAoBoB,EAAWnB,CAAQ,CAChD,CACJ,CACF,CACF,ECrJO,IAAM6B,GAAuB,CAClC,OACA,KAAM,MACN,MAAO,GACP,UAAW,GACX,UAAW,IAAM,GACjB,OAAQ,CAAC,CAAE,GAAAC,EAAI,MAAAC,EAAO,QAAAC,CAAQ,KAC5BA,EAAQ,OAAOD,EAAOD,CAAE,EACjB,IAAME,EAAQ,OAAOD,CAAK,EAErC,ECVO,IAAME,GAAwB,CACnC,OACA,KAAM,OACN,MAAO,GACP,OAASC,GAAQ,CACf,GAAM,CACJ,GAAAC,EACA,KAAAC,EACA,WAAY,CAAE,OAAAC,CAAO,CACvB,EAAIH,EACJ,GAAI,EAAEC,aAAc,aAElB,MAAMG,EAER,OAAOD,EAAO,IAAM,CAClB,IAAME,EAAMH,EAAKF,CAAG,EACpBC,EAAG,YAAc,GAAGI,CAAG,EACzB,CAAC,CACH,CACF,EClBA,IAAMC,EAAU,UACVC,GAAQ,QACRC,GAAS,SAEFC,GAA2B,CACtC,OACA,KAAM,UACN,SAAU,IAAI,IAAI,CAACF,GAAOD,EAASE,EAAM,CAAC,EAC1C,OAASE,GAAQ,CACf,GAAM,CAAE,QAAAC,EAAS,KAAAC,CAAK,EAAIF,EACpBG,EAAMH,EAAI,KAAOI,EACjBC,EAAaL,EAAI,MACjBM,EAAO,IAAI,IAEjB,GAAID,EAAW,KAAK,IAAM,GAAI,CAE5B,IAAME,EADQL,EAAKF,CAAG,EACF,MAAM,GAAG,EAC7B,QAAWQ,KAAQD,EACjBD,EAAK,IAAIE,CAAI,CAEjB,CAEA,IAAIC,EAAiB,GACfC,EAAcV,EAAI,KAAK,IAAIJ,CAAO,EAAIA,EAAUC,GAChDc,EAAYX,EAAI,KAAK,IAAIF,EAAM,EAE/Bc,EAAyBC,GAAqC,CAClE,IAAMC,EAAab,EAAQ,OAAO,GAAGK,CAAI,EAAE,KAAK,GAAOK,CAAS,EAE5DG,IAAeL,IAIfC,IAAgBd,EAClB,OAAO,eAAe,QAAQO,EAAKW,CAAU,EAE7C,OAAO,aAAa,QAAQX,EAAKW,CAAU,EAG7CL,EAAiBK,EACnB,EAEA,OAAO,iBAAiBC,GAAgBH,CAAoB,EAE5D,IAAII,EAQJ,GANIN,IAAgBd,EAClBoB,EAAoB,OAAO,eAAe,QAAQb,CAAG,EAErDa,EAAoB,OAAO,aAAa,QAAQb,CAAG,EAG/Ca,EAAmB,CACvB,IAAMC,EAAsB,KAAK,MAAMD,CAAiB,EACxDf,EAAQ,MAAMgB,EAAqB,EAAI,CACzC,CAEA,MAAO,IAAM,CACX,OAAO,oBAAoBF,GAAgBH,CAAoB,CACjE,CACF,CACF,EC/DO,IAAMM,GAA8B,CACzC,OACA,KAAM,aACN,MAAO,GACP,UAAW,GAEX,OAASC,GAAQ,CACf,GAAM,CACJ,KAAAC,EACA,WAAY,CAAE,OAAAC,CAAO,CACvB,EAAIF,EACJ,OAAOE,EAAO,IAAM,CAClB,IAAMC,EAAQF,EAAKD,CAAG,EAChBI,EAAU,OAAO,SAAS,KAC1BC,EAAM,IAAI,IAAIF,EAAOC,CAAO,EAAE,SAAS,EAE7C,OAAO,QAAQ,aAAa,CAAC,EAAG,GAAIC,CAAG,CACzC,CAAC,CACH,CACF,ECnBA,IAAMC,GAAO,OACPC,GAAO,OACPC,GAAO,OAGAC,GAAgC,CAC3C,OACA,KAAM,aACN,SAAU,IAAI,IAAI,CAACH,GAAMC,GAAMC,EAAI,CAAC,EACpC,MAAO,GACP,OAASE,GAAQ,CACf,GAAM,CAAE,KAAAC,CAAK,EAAID,EACXE,EAAU,CAAE,UAAW,CAAE,EAC3BD,EAAK,IAAIH,EAAI,EAAGI,EAAQ,UAAY,EAC/BD,EAAK,IAAIJ,EAAI,IAAGK,EAAQ,UAAY,IAE7C,IAAMC,EAAW,IAAI,qBAAsBC,GAAY,CACrDA,EAAQ,QAASC,GAAU,CACrBA,EAAM,iBACRL,EAAI,KAAKA,CAAG,EACRC,EAAK,IAAIL,EAAI,IACfO,EAAS,WAAW,EACpB,OAAOH,EAAI,GAAG,QAAQA,EAAI,MAAM,GAGtC,CAAC,CACH,EAAGE,CAAO,EAEV,OAAAC,EAAS,QAAQH,EAAI,EAAE,EAChB,IAAMG,EAAS,WAAW,CACnC,CACF,ECpCO,SAASG,GAAiBC,EAAa,CAC1C,GAAIA,EAAG,GAAI,OAAOA,EAAG,GACrB,IAAIC,EAAO,EACLC,EAAcC,IAChBF,GAASA,GAAQ,GAAKA,EAAQE,EACvBF,EAAOA,GAEZG,EAAqBC,GACvBA,EAAI,MAAM,EAAE,EAAE,QAASC,GAAMJ,EAAWI,EAAE,WAAW,CAAC,CAAC,CAAC,EAE5D,KAAON,EAAG,YAAY,CAClB,GAAIA,EAAG,GAAI,CACPI,EAAkB,GAAGJ,EAAG,EAAE,EAAE,EAC5B,KACJ,SACQA,IAAOA,EAAG,cAAc,gBACxBI,EAAkBJ,EAAG,OAAO,MACzB,CACH,QACQO,EAAI,EAAGC,EAAIR,EACfQ,EAAE,uBACFA,EAAIA,EAAE,uBAAwBD,IAE9BL,EAAWK,CAAC,EAEhBP,EAAKA,EAAG,UACZ,CAEJA,EAAKA,EAAG,UACZ,CACA,OAAOS,EAAWR,CACtB,CAEO,SAASS,GACZV,EACAW,EACAC,EAAc,GAChB,CACE,GAAI,EAAEZ,aAAc,aAAeA,aAAc,YAE7C,MAAMa,EAELb,EAAG,UAAUA,EAAG,aAAa,WAAY,GAAG,EAEjDA,EAAG,eAAeW,CAAI,EAClBC,GAAaZ,EAAG,MAAM,CAC9B,CCxCA,IAAMc,GAAS,SACTC,GAAU,UACVC,GAAO,OACPC,GAAS,SACTC,GAAU,UACVC,GAAO,OACPC,GAAW,WACXC,GAAS,SACTC,GAAU,UACVC,GAAO,OACPC,GAAW,WACXC,GAAQ,QAERC,GAAS,SACTC,GAAQ,QACRC,GAAM,MACNC,GAAU,UAGHC,GAAkC,CAC7C,OACA,KAAM,iBACN,MAAO,GACP,MAAO,GACP,SAAU,IAAI,IAAI,CAChBhB,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,EACF,CAAC,EAED,OAAQ,CAAC,CAAE,GAAAM,EAAI,KAAAC,EAAM,OAAAC,CAAO,IAAwB,CAC7CF,EAAG,UAAUA,EAAG,aAAa,WAAY,GAAG,EACjD,IAAMG,EAA8B,CAClC,SAAUpB,GACV,MAAOY,GACP,OAAQA,EACV,EACA,OAAIM,EAAK,IAAIlB,EAAM,IAAGoB,EAAK,SAAWpB,IAClCkB,EAAK,IAAIjB,EAAO,IAAGmB,EAAK,SAAWnB,IACnCiB,EAAK,IAAIhB,EAAI,IAAGkB,EAAK,SAAWlB,IAChCgB,EAAK,IAAIf,EAAM,IAAGiB,EAAK,OAASP,IAChCK,EAAK,IAAId,EAAO,IAAGgB,EAAK,OAASR,IACjCM,EAAK,IAAIb,EAAI,IAAGe,EAAK,OAASN,IAC9BI,EAAK,IAAIZ,EAAQ,IAAGc,EAAK,OAASL,IAClCG,EAAK,IAAIX,EAAM,IAAGa,EAAK,MAAQP,IAC/BK,EAAK,IAAIV,EAAO,IAAGY,EAAK,MAAQR,IAChCM,EAAK,IAAIT,EAAI,IAAGW,EAAK,MAAQN,IAC7BI,EAAK,IAAIR,EAAQ,IAAGU,EAAK,MAAQL,IAErCM,GAAeJ,EAAIG,EAAMF,EAAK,IAAI,OAAO,CAAC,EAC1C,OAAOD,EAAG,QAAQE,CAAM,EACjB,IAAM,CAAC,CAChB,CACF,EC/DA,IAAMG,GAAO,OACPC,GAAU,UAEHC,GAAwB,CACnC,OACA,KAAM,OACN,MAAO,GACP,UAAW,GAEX,OAASC,GAAQ,CACf,GAAM,CACJ,KAAAC,EACA,GAAI,CAAE,MAAOC,CAAE,EACf,WAAY,CAAE,OAAAC,CAAO,CACvB,EAAIH,EACJ,OAAOG,EAAO,SAAY,CACIF,EAAKD,CAAG,EAE9BE,EAAE,UAAYL,IAChBK,EAAE,eAAeJ,EAAO,EAG1BI,EAAE,YAAYJ,GAASD,EAAI,CAE/B,CAAC,CACH,CACF,ECrBO,IAAMO,GACT,SACSC,EAA0B,CAAC,CAACD,GACpC,oBCPL,IAAME,GAAkB,kBAEXC,GAAkC,CAC7C,OACA,KAAMD,GACN,cAAe,CACb,IAAIE,EAAwB,GAO5B,GANA,SAAS,KAAK,WAAW,QAASC,GAAS,CACrCA,aAAgB,iBAAmBA,EAAK,OAASH,KACnDE,EAAwB,GAE5B,CAAC,EAEG,CAACA,EAAuB,CAC1B,IAAME,EAAO,SAAS,cAAc,MAAM,EAC1CA,EAAK,KAAOJ,GACZI,EAAK,QAAU,cACf,SAAS,KAAK,YAAYA,CAAI,CAChC,CACF,EACA,OAASC,GAAQ,CACf,GAAI,CAACC,EAAyB,CAC5B,QAAQ,MAAM,2CAA2C,EACzD,MACF,CAEA,OAAOD,EAAI,WAAW,OAAO,IAAM,CACjC,GAAM,CAAE,GAAAE,EAAI,KAAAC,CAAK,EAAIH,EACjBI,EAAOD,EAAKH,CAAG,EACnB,GAAI,CAACI,EAAM,OACX,IAAMC,EAAaH,EAAG,MACtBG,EAAW,mBAAqBD,CAClC,CAAC,CACH,CACF,ECtCA,IAAME,GAAoB,cACpBC,GAA0BD,GAAoB,kBAGvCE,GAA+B,CAC1C,KAAM,OACN,OACA,OAAQ,IAAI,OAAO,sBAAsBD,EAAuB,KAAM,IAAI,EAC1E,MAAQE,GAAyB,CAC/B,GAAM,CAAE,IAAAC,CAAI,EAAID,EAChB,MAAO,sBAAsBC,CAAG,IAClC,CACF,EAEaC,GAA+B,CAC1C,KAAM,OACN,OACA,OAAQ,IAAI,OACV,sBAAsBJ,EAAuB,kCAC7C,IACF,EACA,MAAO,CAAC,CAAE,IAAAG,EAAK,MAAAE,CAAM,IACZ,oBAAoBF,CAAG,MAAME,CAAK,GAE7C,EAEaC,GAA4B,CACvC,KAAM,SACN,OACA,OAAQ,IAAI,OACV,uBAAuBP,EAAiB,sBACxC,IACF,EACA,MAAO,CAAC,CAAE,OAAAQ,EAAQ,KAAAC,CAAK,IAAoB,CACzC,IAAMC,EAAU,CAAC,KAAK,EAClBD,GACFC,EAAQ,KAAK,GAAGD,EAAK,MAAM,GAAG,EAAE,IAAKE,GAAMA,EAAE,KAAK,CAAC,CAAC,EAEtD,IAAMC,EAAaF,EAAQ,KAAK,GAAG,EACnC,MAAO,eAAeF,CAAM,OAAOI,CAAU,GAC/C,CACF,EC7BO,IAAMC,GAA+B,CAC1C,OACA,KAAMC,EAAW,cACjB,aAAc,SAAY,CACxBC,EACED,EAAW,cACX,CAAC,CACC,WAAYE,EAAgB,GAAG,EAAuB,GACtD,WAAYC,EAAgBC,GAC5B,OAAAC,CACF,IAAM,CACJ,IAAMC,EAAaC,EAAaL,CAAa,EAC7C,GAAI,CAACG,GAAQ,OAEX,MAAMG,EAER,IAAMC,EAAW,SAAS,cAAc,QAAQ,EAChDN,EAAc,MAAM;AAAA,CAAI,EAAE,QAASO,GAAS,CAC1C,IAAMC,EAAQD,EAAK,QAAQ,GAAG,EACxBE,EAAMD,EAAQD,EAAK,MAAM,EAAGC,CAAK,EAAID,EACrCG,EAAQF,EAAQD,EAAK,MAAMC,CAAK,EAAI,GAC1CF,EAAS,aAAaG,EAAI,KAAK,EAAGC,EAAM,KAAK,CAAC,CAChD,CAAC,EACDJ,EAAS,KAAOJ,EAChB,SAAS,KAAK,YAAYI,CAAQ,EAC9BH,GACFG,EAAS,OAAO,CAEpB,CACF,CACF,CACF,EC7CA,IAAMK,GAAyB,IAAI,QAK5B,SAASC,GACZC,EACAC,EACAC,EAAS,CAAC,EACZ,CACMF,aAAmB,WACnBA,EAAUA,EAAQ,iBAGtB,IAAIG,EACA,OAAOF,GAAe,SACtBE,EAAgBC,GAAaH,CAAU,EAEvCE,EAAgBF,EAGpB,IAAMI,EAAoBC,GAAiBH,CAAa,EAClDI,EAAMC,GAAmBR,EAASK,EAAmBH,CAAM,EAEjE,OAAOO,GAAuBT,EAASK,EAAmBE,CAAG,CACjE,CAEA,SAASE,GACLT,EACAU,EACAH,EACF,CACE,GAAIA,EAAI,KAAK,MAAO,CAChB,IAAMI,EAAUX,EAAQ,cAAc,MAAM,EACtCY,EAAUF,EAAqB,cAAc,MAAM,EACzD,GAAIC,GAAWC,EAAS,CACpB,IAAMC,EAAWC,GAAkBF,EAASD,EAASJ,CAAG,EAExD,QAAQ,IAAIM,CAAQ,EAAE,KAAK,IAAM,CAC7BJ,GACIT,EACAU,EACA,OAAO,OAAOH,EAAK,CACf,KAAM,CACF,MAAO,GACP,OAAQ,EACZ,CACJ,CAAC,CACL,CACJ,CAAC,EACD,MACJ,CACJ,CAEA,GAAIA,EAAI,aAAe,YAEnB,OAAAQ,GAAcL,EAAsBV,EAASO,CAAG,EACzCP,EAAQ,SACZ,GAAIO,EAAI,aAAe,aAAeA,EAAI,YAAc,KAAM,CAGjE,IAAMS,EAAYC,GAAkBP,EAAsBV,EAASO,CAAG,EACtE,GAAI,CAACS,EAED,MAAME,EAIV,IAAMC,EAAkBH,GAAW,gBAC7BI,EAAcJ,GAAW,YAGzBK,EAAcC,GAAetB,EAASgB,EAAWT,CAAG,EAE1D,OAAIS,EAGOO,GAAeJ,EAAiBE,EAAaD,CAAW,EAGxD,CAAC,CAEhB,KAEI,OAAMI,CAEd,CAQA,SAASF,GAAetB,EAAkBC,EAAqBM,EAAU,CACrE,GAAI,EAAAA,EAAI,cAAgBP,IAAY,SAAS,eAEtC,GAAIC,GAAc,KAAM,CAC3B,GAAIM,EAAI,UAAU,kBAAkBP,CAAO,IAAM,GAAO,OAExDA,EAAQ,OAAO,EACfO,EAAI,UAAU,iBAAiBP,CAAO,EACtC,MACJ,KAAO,IAAKyB,GAAYzB,EAASC,CAAU,EAavC,OAAIM,EAAI,UAAU,kBAAkBP,EAASC,CAAU,IAAM,GACzD,QAGAD,aAAmB,iBAAmBO,EAAI,KAAK,SAG/CN,aAAsB,iBACtBD,aAAmB,iBACnBO,EAAI,KAAK,QAAUmB,EAAmB,MAEtCZ,GAAkBb,EAAYD,EAASO,CAAG,GAE1CoB,GAAa1B,EAAYD,CAAO,EAChCe,GAAcd,EAAYD,EAASO,CAAG,IAE1CA,EAAI,UAAU,iBAAiBP,EAASC,CAAU,EAC3CD,GA5BP,GADIO,EAAI,UAAU,kBAAkBP,CAAO,IAAM,IAC7CO,EAAI,UAAU,gBAAgBN,CAAU,IAAM,GAAO,OAEzD,GAAI,CAACD,EAAQ,cAET,MAAMwB,EAEV,OAAAxB,EAAQ,cAAc,aAAaC,EAAYD,CAAO,EACtDO,EAAI,UAAU,eAAeN,CAAU,EACvCM,EAAI,UAAU,iBAAiBP,CAAO,EAC/BC,EAqBf,CAwBA,SAASc,GAAca,EAAoBC,EAAoBtB,EAAU,CACrE,IAAIuB,EAAeF,EAAU,WACzBG,EAAiBF,EAAU,WAC3BG,EAGJ,KAAOF,GAAc,CAKjB,GAJAE,EAAWF,EACXA,EAAeE,EAAS,YAGpBD,GAAkB,KAAM,CACxB,GAAIxB,EAAI,UAAU,gBAAgByB,CAAQ,IAAM,GAAO,OAEvDH,EAAU,YAAYG,CAAQ,EAC9BzB,EAAI,UAAU,eAAeyB,CAAQ,EACrCC,EAA2B1B,EAAKyB,CAAQ,EACxC,QACJ,CAGA,GAAIE,GAAaF,EAAUD,EAAgBxB,CAAG,EAAG,CAC7Ce,GAAeS,EAAgBC,EAAUzB,CAAG,EAC5CwB,EAAiBA,EAAe,YAChCE,EAA2B1B,EAAKyB,CAAQ,EACxC,QACJ,CAGA,IAAIG,EAAaC,GACbR,EACAC,EACAG,EACAD,EACAxB,CACJ,EAGA,GAAI4B,EAAY,CACZJ,EAAiBM,GACbN,EACAI,EACA5B,CACJ,EACAe,GAAea,EAAYH,EAAUzB,CAAG,EACxC0B,EAA2B1B,EAAKyB,CAAQ,EACxC,QACJ,CAGA,IAAIM,EAAYC,GAAcX,EAAWI,EAAUD,EAAgBxB,CAAG,EAGtE,GAAI+B,EAAW,CACXP,EAAiBM,GAAmBN,EAAgBO,EAAW/B,CAAG,EAClEe,GAAegB,EAAWN,EAAUzB,CAAG,EACvC0B,EAA2B1B,EAAKyB,CAAQ,EACxC,QACJ,CAIA,GAAIzB,EAAI,UAAU,gBAAgByB,CAAQ,IAAM,GAAO,OAEvDH,EAAU,aAAaG,EAAUD,CAAc,EAC/CxB,EAAI,UAAU,eAAeyB,CAAQ,EACrCC,EAA2B1B,EAAKyB,CAAQ,CAC5C,CAGA,KAAOD,IAAmB,MAAM,CAC5B,IAAIS,EAAWT,EACfA,EAAiBA,EAAe,YAChCU,GAAWD,EAAUjC,CAAG,CAC5B,CACJ,CAaA,SAASoB,GAAae,EAAeC,EAAa,CAC9C,IAAIC,EAAOF,EAAK,SAIhB,GAAIE,IAAS,EAAsB,CAC/B,QAAWC,KAAiBH,EAAK,WACTC,EAAG,aAAaE,EAAc,IAAI,IAClCA,EAAc,OAC9BF,EAAG,aAAaE,EAAc,KAAMA,EAAc,KAAK,EAG/D,QAAWC,KAAeH,EAAG,WACpBD,EAAK,aAAaI,EAAY,IAAI,GACnCH,EAAG,gBAAgBG,EAAY,IAAI,CAG/C,CAeA,IAZIF,IAAS,KAAK,cAAgBA,IAAS,KAAK,YACxCD,EAAG,YAAcD,EAAK,YACtBC,EAAG,UAAYD,EAAK,WAWxBA,aAAgB,kBAAoBC,aAAc,kBAClDD,EAAK,OAAS,OAEdC,EAAG,MAAQD,EAAK,OAAS,GACzBK,GAAcL,EAAMC,EAAI,OAAO,EAG/BI,GAAcL,EAAMC,EAAI,SAAS,EACjCI,GAAcL,EAAMC,EAAI,UAAU,UAC3BD,aAAgB,kBACvBK,GAAcL,EAAMC,EAAI,UAAU,UAElCD,aAAgB,qBAAuBC,aAAc,oBACvD,CACE,IAAMK,EAAYN,EAAK,MACjBO,EAAUN,EAAG,MACfK,IAAcC,IACdN,EAAG,MAAQK,GAEXL,EAAG,YAAcA,EAAG,WAAW,YAAcK,IAC7CL,EAAG,WAAW,UAAYK,EAElC,CACJ,CAEA,SAASD,GAAcL,EAAeC,EAAaO,EAAuB,CACtE,IAAMC,EAAQT,EAAK,aAAaQ,CAAa,EACvCE,EAAQT,EAAG,aAAaO,CAAa,EAEvCC,IAAUC,IACND,EACAR,EAAG,aAAaO,EAAeC,CAAK,EAEpCR,EAAG,gBAAgBO,CAAa,EAG5C,CAKA,SAASpC,GACLuC,EACAC,EACA/C,EACF,CACE,IAAMgD,EAAQ,CAAC,EACTC,EAAU,CAAC,EACXC,EAAY,CAAC,EACbC,EAAgB,CAAC,EAEjBC,EAAiBpD,EAAI,KAAK,MAG1BqD,EAAoB,IAAI,IAC9B,QAAWC,KAAgBR,EAAW,SAClCO,EAAkB,IAAIC,EAAa,UAAWA,CAAY,EAI9D,QAAWC,KAAkBR,EAAY,SAAU,CAE/C,IAAIS,EAAeH,EAAkB,IAAIE,EAAe,SAAS,EAC7DE,EAAezD,EAAI,KAAK,eAAeuD,CAAc,EACrDG,EAAc1D,EAAI,KAAK,eAAeuD,CAAc,EACpDC,GAAgBE,EACZD,EAEAR,EAAQ,KAAKM,CAAc,GAI3BF,EAAkB,OAAOE,EAAe,SAAS,EACjDL,EAAU,KAAKK,CAAc,GAG7BH,IAAmBjC,EAAmB,OAGlCsC,IACAR,EAAQ,KAAKM,CAAc,EAC3BJ,EAAc,KAAKI,CAAc,GAIjCvD,EAAI,KAAK,aAAauD,CAAc,IAAM,IAC1CN,EAAQ,KAAKM,CAAc,CAI3C,CAIAJ,EAAc,KAAK,GAAGE,EAAkB,OAAO,CAAC,EAGhD,IAAM/C,EAAW,CAAC,EAClB,QAAWqD,KAAWR,EAAe,CAEjC,IAAMS,EAAS,SAAS,YAAY,EAAE,yBAClCD,EAAQ,SACZ,EAAE,WACF,GAAI,CAACC,EAED,MAAM3C,EAGV,GAAMjB,EAAI,UAAU,gBAAgB4D,CAAM,EAAG,CACzC,GAAIA,EAAO,aAAa,MAAM,GAAKA,EAAO,aAAa,KAAK,EAAG,CAC3D,IAAIC,EACEC,EAAU,IAAI,QAASC,GAAY,CACrCF,EAAWE,CACf,CAAC,EACDH,EAAO,iBAAiB,OAAQ,UAAY,CACxCC,EAAS,MAAS,CACtB,CAAC,EACDvD,EAAS,KAAKwD,CAAO,CACzB,CACAf,EAAY,YAAYa,CAAM,EAC9B5D,EAAI,UAAU,eAAe4D,CAAM,EACnCZ,EAAM,KAAKY,CAAM,CACrB,CACJ,CAIA,QAAWI,KAAkBf,EACrBjD,EAAI,UAAU,kBAAkBgE,CAAc,IAAM,KACpDjB,EAAY,YAAYiB,CAAc,EACtChE,EAAI,UAAU,iBAAiBgE,CAAc,GAIrD,OAAAhE,EAAI,KAAK,iBAAiB+C,EAAa,CACnC,MAAOC,EACP,KAAME,EACN,QAASD,CACb,CAAC,EACM3C,CACX,CAKA,SAAS2D,GAAO,CAAC,CAEjB,SAAShE,GACLR,EACAC,EACAC,EACF,CACE,MAAO,CACH,OAAQF,EACR,WAAYC,EACZ,OAAQC,EACR,WAAYA,EAAO,WACnB,aAAcA,EAAO,aACrB,MAAOuE,GAAYzE,EAASC,CAAU,EACtC,QAAS,IAAI,IACb,UAAW,OAAO,OACd,CACI,gBAAiBuE,EACjB,eAAgBA,EAChB,kBAAmBA,EACnB,iBAAkBA,EAClB,kBAAmBA,EACnB,iBAAkBA,CACtB,EACAtE,EAAO,SACX,EACA,KAAM,OAAO,OACT,CACI,MAAO,QACP,eAAiBwE,GACbA,EAAI,aAAa,aAAa,IAAM,OACxC,eAAiBA,GACbA,EAAI,aAAa,cAAc,IAAM,OACzC,aAAcF,EACd,iBAAkBA,CACtB,EACAtE,EAAO,IACX,CACJ,CACJ,CAEA,SAASgC,GAAayC,EAAgBC,EAAgBrE,EAAU,CAC5D,MAAI,CAACoE,GAAS,CAACC,EAAc,GAEzBD,EAAM,WAAaC,EAAM,UAAYD,EAAM,UAAYC,EAAM,QACzDD,GAAO,IAAI,QAAUA,EAAM,KAAOC,EAAM,GAAW,GAEhDC,GAAuBtE,EAAKoE,EAAOC,CAAK,EAAI,EAEhD,EACX,CAEA,SAASnD,GAAYkD,EAAgBC,EAAgB,CACjD,MAAI,CAACD,GAAS,CAACC,EAAc,GAEtBD,EAAM,WAAaC,EAAM,UAAYD,EAAM,UAAYC,EAAM,OACxE,CAEA,SAASvC,GACLyC,EACAC,EACAxE,EACF,CACE,KAAOuE,IAAmBC,GAAc,CACpC,IAAMvC,EAAWsC,EAEjB,GADAA,EAAiBA,GAAgB,YAC7B,CAACtC,EAED,MAAMhB,EAEViB,GAAWD,EAAUjC,CAAG,CAC5B,CACA,OAAA0B,EAA2B1B,EAAKwE,CAAY,EACrCA,EAAa,WACxB,CAQA,SAAS3C,GACLnC,EACA4B,EACAG,EACAD,EACAxB,EACF,CAEE,IAAMyE,EAA2BH,GAC7BtE,EACAyB,EACAH,CACJ,EAEIoD,EAAiC,KAGrC,GAAID,EAA2B,EAAG,CAC9BC,EAAiBlD,EAKjB,IAAImD,EAAkB,EACtB,KAAOD,GAAkB,MAAM,CAE3B,GAAI/C,GAAaF,EAAUiD,EAAgB1E,CAAG,EAC1C,OAAO0E,EASX,GALAC,GAAmBL,GACftE,EACA0E,EACAhF,CACJ,EACIiF,EAAkBF,EAGlB,OAAO,KAIXC,EAAiBA,EAAe,WACpC,CACJ,CACA,OAAOA,CACX,CAQA,SAAS1C,GACLtC,EACA+B,EACAD,EACAxB,EACF,CACE,IAAI4E,EAAqBpD,EACrBX,EAAcY,EAAS,YAEvBoD,EAAwB,EAE5B,KAAOD,GAAsB/D,GAAa,CACtC,GAAIyD,GAAuBtE,EAAK4E,EAAoBlF,CAAU,EAAI,EAG9D,OAAO,KAIX,GAAIwB,GAAYO,EAAUmD,CAAkB,EACxC,OAAOA,EAGX,GAAI1D,GAAYL,EAAa+D,CAAkB,IAG3CC,IACAhE,EAAcA,EAAY,YAItBgE,GAAyB,GACzB,OAAO,KAKfD,EAAqBA,EAAmB,WAC5C,CAEA,OAAOA,CACX,CAEA,IAAME,GAAS,IAAI,UACnB,SAASjF,GAAaH,EAAoB,CAEtC,IAAMqF,EAAyBrF,EAAW,QACtC,uCACA,EACJ,EAGA,GACIqF,EAAuB,MAAM,UAAU,GACvCA,EAAuB,MAAM,UAAU,GACvCA,EAAuB,MAAM,UAAU,EACzC,CACE,IAAMC,EAAUF,GAAO,gBAAgBpF,EAAY,WAAW,EAE9D,GAAIqF,EAAuB,MAAM,UAAU,EACvC,OAAAxF,GAAuB,IAAIyF,CAAO,EAC3BA,EACJ,CAEH,IAAIC,EAAUD,EAAQ,WACtB,OAAIC,GACA1F,GAAuB,IAAI0F,CAAO,EAC3BA,GAEA,IAEf,CACJ,KAAO,CAOH,IAAMD,EAJcF,GAAO,gBACvB,mBAAmBpF,CAAU,qBAC7B,WACJ,EAC4B,KAAK,cAAc,UAAU,GAAG,QAC5D,GAAI,CAACsF,EAED,MAAMrE,EAEV,OAAApB,GAAuB,IAAIyF,CAAO,EAC3BA,CACX,CACJ,CAEA,SAASjF,GAAiBL,EAAqB,CAC3C,GAAIA,GAAc,KAGd,OADoB,SAAS,cAAc,KAAK,EAE7C,GAAIH,GAAuB,IAAIG,CAAU,EAE5C,OAAOA,EACJ,GAAIA,aAAsB,KAAM,CAEnC,IAAMwF,EAAc,SAAS,cAAc,KAAK,EAChD,OAAAA,EAAY,OAAOxF,CAAU,EACtBwF,CACX,KAAO,CAGH,IAAMA,EAAc,SAAS,cAAc,KAAK,EAChD,QAAWf,IAAO,CAAC,GAAGzE,CAAU,EAC5BwF,EAAY,OAAOf,CAAG,EAE1B,OAAOe,CACX,CACJ,CAEA,SAASlE,GACLJ,EACAE,EACAD,EACF,CACE,IAAMsE,EAAQ,CAAC,EACTnC,EAAQ,CAAC,EACf,KAAOpC,GACHuE,EAAM,KAAKvE,CAAe,EAC1BA,EAAkBA,EAAgB,gBAEtC,KAAOuE,EAAM,OAAS,GAAG,CACrB,IAAMC,EAAOD,EAAM,IAAI,EACvBnC,EAAM,KAAKoC,CAAI,EACftE,GAAa,eAAe,aAAasE,EAAMtE,CAAW,CAC9D,CAEA,IADAkC,EAAM,KAAKlC,CAAW,EACfD,GACHsE,EAAM,KAAKtE,CAAW,EACtBmC,EAAM,KAAKnC,CAAW,EACtBA,EAAcA,EAAY,YAE9B,KAAOsE,EAAM,QACTrE,GAAa,eAAe,aACxBqE,EAAM,IAAI,EACVrE,EAAY,WAChB,EAEJ,OAAOkC,CACX,CAEA,SAAStC,GAAkBhB,EAAqBD,EAAkBO,EAAU,CACxE,IAAIqF,EAAiB3F,EAAW,WAC5B4F,EAAcD,EACdE,EAAQ,EACZ,KAAOF,GAAgB,CACnB,IAAIG,EAAWC,GAAaJ,EAAgB5F,EAASO,CAAG,EACpDwF,EAAWD,IACXD,EAAcD,EACdE,EAAQC,GAEZH,EAAiBA,EAAe,WACpC,CACA,OAAOC,CACX,CAEA,SAASG,GAAarB,EAAgBC,EAAgBrE,EAAU,CAC5D,OAAIkB,GAAYkD,EAAOC,CAAK,EACjB,GAAMC,GAAuBtE,EAAKoE,EAAOC,CAAK,EAElD,CACX,CAEA,SAASnC,GAAWD,EAAmBjC,EAAU,CAC7C0B,EAA2B1B,EAAKiC,CAAQ,EACpCjC,EAAI,UAAU,kBAAkBiC,CAAQ,IAAM,KAElDA,EAAS,OAAO,EAChBjC,EAAI,UAAU,iBAAiBiC,CAAQ,EAC3C,CAMA,SAASyD,GAAoB1F,EAAU2F,EAAY,CAC/C,MAAO,CAAC3F,EAAI,QAAQ,IAAI2F,CAAE,CAC9B,CAEA,SAASC,GAAe5F,EAAU2F,EAAYE,EAAqB,CAC/D,OAAO7F,EAAI,MAAM,IAAI6F,CAAU,GAAG,IAAIF,CAAE,GAAK,EACjD,CAEA,SAASjE,EAA2B1B,EAAUoF,EAAe,CACzD,IAAMU,EAAQ9F,EAAI,MAAM,IAAIoF,CAAI,EAChC,GAAKU,EACL,QAAWH,KAAMG,EACb9F,EAAI,QAAQ,IAAI2F,CAAE,CAE1B,CAEA,SAASrB,GAAuBtE,EAAUoE,EAAgBC,EAAgB,CACtE,IAAM0B,EAAY/F,EAAI,MAAM,IAAIoE,CAAK,EACrC,GAAI,CAAC2B,EAAW,MAAO,GAEvB,IAAIC,EAAa,EACjB,QAAWL,KAAMI,EAGTL,GAAoB1F,EAAK2F,CAAE,GAAKC,GAAe5F,EAAK2F,EAAItB,CAAK,GAC7D,EAAE2B,EAGV,OAAOA,CACX,CAUA,SAASC,GAAqBb,EAAec,EAAkC,CAC3E,IAAMC,EAAaf,EAAK,cAElBgB,EAAahB,EAAK,iBAAiB,MAAM,EAC/C,QAAWjB,KAAOiC,EAAY,CAC1B,IAAIC,EAAUlC,EAGd,KAAOkC,IAAYF,GAAgBE,GAAS,CACxC,IAAIP,EAAQI,EAAM,IAAIG,CAAO,EAEzBP,GAAS,OACTA,EAAQ,IAAI,IACZI,EAAM,IAAIG,EAASP,CAAK,GAE5BA,EAAM,IAAI3B,EAAI,EAAE,EAChBkC,EAAUA,EAAQ,aACtB,CACJ,CACJ,CAYA,SAASnC,GAAYoC,EAAqB5G,EAAqB,CAC3D,IAAMwG,EAAQ,IAAI,IAClB,OAAAD,GAAqBK,EAAYJ,CAAK,EACtCD,GAAqBvG,EAAYwG,CAAK,EAC/BA,CACX,CCvxBO,IAAMK,GAAgC,CAC3C,OACA,KAAMC,EAAW,eACjB,aAAc,MAAOC,GAAQ,CAC3B,IAAMC,EAAoB,SAAS,cAAc,UAAU,EAC3DC,EACEH,EAAW,eACX,CAAC,CACC,UAAWI,EAAe,cAC1B,SAAAC,EAAW,GACX,UAAAC,EAAYC,GACZ,eAAgBC,EAAoB,GAAG,GAAgB,GACvD,kBACEC,EAAuB,GAAG,EAA2B,EACzD,IAAM,CACJ,IAAMC,EAAiB,SAASF,CAAiB,EAC3CG,EAAoBC,EAAaH,CAAoB,EAE3DP,EAAkB,UAAYE,EAAa,KAAK,EAC9B,CAAC,GAAGF,EAAkB,QAAQ,QAAQ,EAC9C,QAASW,GAAa,CAC9B,GAAI,EAAEA,aAAoB,SAExB,MAAMC,EAGR,IAAMC,EAAeV,GAAY,IAAIQ,EAAS,aAAa,IAAI,CAAC,GAE1DG,EAAa,CAAC,GADJ,SAAS,iBAAiBD,CAAY,GAAK,CAAC,CAC9B,EAC9B,GAAI,CAACC,EAAW,OAEd,MAAMF,EAGJG,GAA2BN,EAC7BO,GAAyB,oBAAoB,IAC3CC,GACElB,EACAK,EACAI,EACAG,EACAG,CACF,CACF,EAEAG,GACElB,EACAK,EACAI,EACAG,EACAG,CACF,CAEJ,CAAC,CACH,CACF,CACF,CACF,EAEA,SAASG,GACPlB,EACAK,EACAI,EACAG,EACAO,EACA,CACA,QAAWC,KAAiBD,EAAiB,CAC3CC,EAAc,UAAU,IAAIC,CAAc,EAC1C,IAAMC,EAAeF,EAAc,UAC/BG,EAAiBH,EACrB,OAAQf,EAAW,CACjB,KAAKmB,EAAmB,MACtB,IAAMC,EAASC,GAAUH,EAAgBX,EAAU,CACjD,UAAW,CACT,kBAAmB,CAACe,EAAkBC,KACpC5B,EAAI,QAAQ2B,CAAO,EACZ,GAEX,CACF,CAAC,EACD,GAAI,CAACF,GAAQ,OAEX,MAAMZ,EAERU,EAAiBE,EAAO,CAAC,EACzB,MACF,KAAKD,EAAmB,MAEtBD,EAAe,UAAYX,EAAS,UACpC,MACF,KAAKY,EAAmB,MAEtBD,EAAe,YAAYX,CAAQ,EACnC,MACF,KAAKY,EAAmB,QAEtBD,EAAe,QAAQX,CAAQ,EAC/B,MACF,KAAKY,EAAmB,OAEtBD,EAAe,OAAOX,CAAQ,EAC9B,MACF,KAAKY,EAAmB,OAEtBD,EAAe,OAAOX,CAAQ,EAC9B,MACF,KAAKY,EAAmB,MAEtBD,EAAe,MAAMX,CAAQ,EAC7B,MACF,KAAKY,EAAmB,iBAEtBZ,EAAS,kBAAkB,EAAE,QAASiB,GAAa,CACjD,IAAMC,EAAQlB,EAAS,aAAaiB,CAAQ,EAC5CN,EAAe,aAAaM,EAAUC,CAAK,CAC7C,CAAC,EACD,MACF,QAEE,MAAMjB,CACV,CACAb,EAAI,QAAQuB,CAAc,EAC1BA,EAAe,UAAU,IAAIF,CAAc,EAE3CrB,EAAI,aAAa,SAAS,IAAI,EAE9B,WAAW,IAAM,CACfoB,EAAc,UAAU,OAAOC,CAAc,EAC7CE,EAAe,UAAU,OAAOF,CAAc,CAChD,EAAGZ,CAAc,EAEjB,IAAMsB,EAAcR,EAAe,UAE/BD,IAAiBS,IACnBR,EAAe,UAAU,IAAIS,EAAc,EAC3C,WAAW,IAAM,CACfT,EAAe,UAAU,OAAOS,EAAc,CAChD,EAAGvB,CAAc,EAErB,CACF,CCzJO,IAAMwB,GAA8B,CACzC,OACA,KAAMC,EAAW,aACjB,aAAc,MAAOC,GAAQ,CAC3BC,EACEF,EAAW,aACX,CAAC,CACC,QAASG,EAAM,KACf,cAAeC,EAAmB,GAAG,EAAyB,EAChE,IAAM,CACJ,GAAM,CAAE,QAAAC,CAAQ,EAAIJ,EACdK,EAAgBC,EAAaH,CAAgB,EAE7CI,EADK,IAAI,SAAS,4BAA4BL,CAAG,GAAG,EAC1B,EAChCE,EAAQ,MAAMG,EAAsBF,CAAa,EACjDL,EAAI,aAAa,SAAS,IAAI,CAChC,CACF,CACF,CACF,ECbO,IAAMQ,GAAiC,CAC5C,OACA,KAAMC,EAAW,gBACjB,aAAc,SAAY,CACxBC,EACED,EAAW,gBACX,CAAC,CACC,SAAAE,EACA,eAAgBC,EAAoB,GAAG,GAAgB,GACvD,kBACEC,EAAuB,GAAG,EAA2B,EACzD,IAAM,CACJ,GAAI,CAAGF,EAAS,OAEd,MAAMG,EAGR,IAAMC,EAAiB,SAASH,CAAiB,EAC3CI,EAAoBC,EAAaJ,CAAoB,EACrDK,EAAgB,SAAS,iBAAiBP,CAAQ,EAElDQ,EAAiB,IAAM,CAC3B,QAAWC,KAAUF,EACnBE,EAAO,UAAU,IAAIC,CAAc,EAGrC,WAAW,IAAM,CACf,QAAWD,KAAUF,EACnBE,EAAO,OAAO,CAElB,EAAGL,CAAc,CACnB,EAEIO,GAA2BN,EAC7BO,GAAyB,oBAAoB,IAAMJ,EAAe,CAAC,EAEnEA,EAAe,CAEnB,CACF,CACF,CACF,EClDO,IAAMK,GAA+B,CAC1C,OACA,KAAMC,EAAW,cACjB,aAAc,MAAOC,GAAQ,CAC3BC,EACEF,EAAW,cACX,CAAC,CAAE,MAAOG,EAAW,EAAG,IAAM,CAC5B,IAAMC,EAAQD,EAAS,MAAM;AAAA,CAAI,EAAE,IAAKE,GAAMA,EAAE,KAAK,CAAC,EACtD,GAAI,CAAGD,GAAO,OAEZ,MAAME,EAERL,EAAI,QAAQ,OAAO,GAAGG,CAAK,CAC7B,CACF,CACF,CACF,ECtBA,IAAMG,GAAe,OAAO,IAAI,gBAAgB,EAG1CC,EAAU,EACVC,EAAW,EACXC,GAAW,EACXC,EAAW,EACXC,GAAY,GACZC,EAAW,GA0BjB,SAASC,IAAa,CACpBC,IACF,CAEA,SAASC,IAAW,CAClB,GAAID,GAAa,EAAG,CAClBA,KACA,MACF,CAEA,IAAIE,EACAC,EAAW,GAEf,KAAOC,KAAkB,QAAW,CAClC,IAAIC,EAA6BD,GAKjC,IAJAA,GAAgB,OAEhBE,KAEOD,IAAW,QAAW,CAC3B,IAAME,EAA2BF,EAAO,mBAIxC,GAHAA,EAAO,mBAAqB,OAC5BA,EAAO,QAAU,CAACX,EAEd,EAAEW,EAAO,OAAST,IAAaY,GAAiBH,CAAM,EACxD,GAAI,CACFA,EAAO,UAAU,CACnB,OAASI,EAAK,CACPN,IACHD,EAAQO,EACRN,EAAW,GAEf,CAEFE,EAASE,CACX,CACF,CAIA,GAHAD,GAAiB,EACjBN,KAEIG,EACF,MAAMD,CAEV,CA2BA,IAAIQ,EAoBJ,IAAIC,GACAC,GAAa,EACbC,GAAiB,EAIjBC,GAAgB,EAEpB,SAASC,GAAcC,EAAkC,CACvD,GAAIC,IAAgB,OAClB,OAGF,IAAIC,EAAOF,EAAO,MAClB,GAAIE,IAAS,QAAaA,EAAK,UAAYD,EAazC,OAAAC,EAAO,CACL,SAAU,EACV,QAASF,EACT,YAAaC,EAAY,SACzB,YAAa,OACb,QAASA,EACT,YAAa,OACb,YAAa,OACb,cAAeC,CACjB,EAEID,EAAY,WAAa,SAC3BA,EAAY,SAAS,YAAcC,GAErCD,EAAY,SAAWC,EACvBF,EAAO,MAAQE,EAIXD,EAAY,OAASE,GACvBH,EAAO,WAAWE,CAAI,EAEjBA,EACF,GAAIA,EAAK,WAAa,GAE3B,OAAAA,EAAK,SAAW,EAeZA,EAAK,cAAgB,SACvBA,EAAK,YAAY,YAAcA,EAAK,YAEhCA,EAAK,cAAgB,SACvBA,EAAK,YAAY,YAAcA,EAAK,aAGtCA,EAAK,YAAcD,EAAY,SAC/BC,EAAK,YAAc,OAEnBD,EAAY,SAAU,YAAcC,EACpCD,EAAY,SAAWC,GAKlBA,CAGX,CAgEA,SAASE,EAAqBC,EAAiB,CAC7C,KAAK,OAASA,EACd,KAAK,SAAW,EAChB,KAAK,MAAQ,OACb,KAAK,SAAW,MAClB,CAEAD,EAAO,UAAU,MAAQE,GAEzBF,EAAO,UAAU,SAAW,UAAY,CACtC,MAAO,EACT,EAEAA,EAAO,UAAU,WAAa,SAAUF,EAAM,CACxC,KAAK,WAAaA,GAAQA,EAAK,cAAgB,SACjDA,EAAK,YAAc,KAAK,SACpB,KAAK,WAAa,SACpB,KAAK,SAAS,YAAcA,GAE9B,KAAK,SAAWA,EAEpB,EAEAE,EAAO,UAAU,aAAe,SAAUF,EAAM,CAE9C,GAAI,KAAK,WAAa,OAAW,CAC/B,IAAMK,EAAOL,EAAK,YACZM,EAAON,EAAK,YACdK,IAAS,SACXA,EAAK,YAAcC,EACnBN,EAAK,YAAc,QAEjBM,IAAS,SACXA,EAAK,YAAcD,EACnBL,EAAK,YAAc,QAEjBA,IAAS,KAAK,WAChB,KAAK,SAAWM,EAEpB,CACF,EAEAJ,EAAO,UAAU,UAAY,SAAUK,EAAI,CACzC,OAAOC,GAAO,IAAM,CAClB,IAAML,EAAQ,KAAK,MAEbM,EAAcV,EACpBA,EAAc,OACd,GAAI,CACFQ,EAAGJ,CAAK,CACV,QAAE,CACAJ,EAAcU,CAChB,CACF,CAAC,CACH,EAEAP,EAAO,UAAU,QAAU,UAAY,CACrC,OAAO,KAAK,KACd,EAEAA,EAAO,UAAU,SAAW,UAAY,CACtC,OAAO,KAAK,MAAQ,EACtB,EAEAA,EAAO,UAAU,OAAS,UAAY,CACpC,OAAO,KAAK,KACd,EAEAA,EAAO,UAAU,KAAO,UAAY,CAClC,IAAMO,EAAcV,EACpBA,EAAc,OACd,GAAI,CACF,OAAO,KAAK,KACd,QAAE,CACAA,EAAcU,CAChB,CACF,EAEA,OAAO,eAAeP,EAAO,UAAW,QAAS,CAC/C,KAAkB,CAChB,IAAMF,EAAOH,GAAc,IAAI,EAC/B,OAAIG,IAAS,SACXA,EAAK,SAAW,KAAK,UAEhB,KAAK,MACd,EACA,IAAkBG,EAAO,CACvB,GAAIA,IAAU,KAAK,OAAQ,CACzB,GAAIR,GAAiB,IAEnB,MAAMe,EAGR,KAAK,OAASP,EACd,KAAK,WACLP,KAEiBe,GAAW,EAC5B,GAAI,CACF,QACMX,EAAO,KAAK,SAChBA,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,QAAQ,CAEzB,QAAE,CACAY,GAAS,CACX,CACF,CACF,CACF,CAAC,EAUM,SAASd,GAAUK,EAAsB,CAC9C,OAAO,IAAID,EAAOC,CAAK,CACzB,CAEA,SAASU,GAAiBC,EAAoC,CAI5D,QACMd,EAAOc,EAAO,SAClBd,IAAS,OACTA,EAAOA,EAAK,YAKZ,GACEA,EAAK,QAAQ,WAAaA,EAAK,UAC/B,CAACA,EAAK,QAAQ,SAAS,GACvBA,EAAK,QAAQ,WAAaA,EAAK,SAE/B,MAAO,GAKX,MAAO,EACT,CAEA,SAASe,GAAeD,EAA2B,CAajD,QACMd,EAAOc,EAAO,SAClBd,IAAS,OACTA,EAAOA,EAAK,YACZ,CACA,IAAMgB,EAAehB,EAAK,QAAQ,MAOlC,GANIgB,IAAiB,SACnBhB,EAAK,cAAgBgB,GAEvBhB,EAAK,QAAQ,MAAQA,EACrBA,EAAK,SAAW,GAEZA,EAAK,cAAgB,OAAW,CAClCc,EAAO,SAAWd,EAClB,KACF,CACF,CACF,CAEA,SAASiB,GAAeH,EAA2B,CACjD,IAAId,EAAOc,EAAO,SACdI,EAOJ,KAAOlB,IAAS,QAAW,CACzB,IAAMK,EAAOL,EAAK,YAUdA,EAAK,WAAa,IACpBA,EAAK,QAAQ,aAAaA,CAAI,EAE1BK,IAAS,SACXA,EAAK,YAAcL,EAAK,aAEtBA,EAAK,cAAgB,SACvBA,EAAK,YAAY,YAAcK,IAajCa,EAAOlB,EAGTA,EAAK,QAAQ,MAAQA,EAAK,cACtBA,EAAK,gBAAkB,SACzBA,EAAK,cAAgB,QAGvBA,EAAOK,CACT,CAEAS,EAAO,SAAWI,CACpB,CAcO,SAASC,EAAyBZ,EAAmB,CAC1DL,EAAO,KAAK,KAAM,MAAS,EAE3B,KAAK,IAAMK,EACX,KAAK,SAAW,OAChB,KAAK,eAAiBX,GAAgB,EACtC,KAAK,OAASwB,EAChB,CAEAD,EAAS,UAAY,IAAIjB,EAEzBiB,EAAS,UAAU,SAAW,UAAY,CAGxC,GAFA,KAAK,QAAU,CAACE,EAEZ,KAAK,OAASC,EAChB,MAAO,GAWT,IALK,KAAK,QAAUF,GAAWnB,MAAeA,IAG9C,KAAK,QAAU,CAACmB,GAEZ,KAAK,iBAAmBxB,IAC1B,MAAO,GAOT,GALA,KAAK,eAAiBA,GAItB,KAAK,QAAU0B,EACX,KAAK,SAAW,GAAK,CAACT,GAAiB,IAAI,EAC7C,YAAK,QAAU,CAACS,EACT,GAGT,IAAMb,EAAcV,EACpB,GAAI,CACFgB,GAAe,IAAI,EACnBhB,EAAc,KACd,IAAMI,EAAQ,KAAK,IAAI,GAErB,KAAK,OAASoB,IACd,KAAK,SAAWpB,GAChB,KAAK,WAAa,KAElB,KAAK,OAASA,EACd,KAAK,QAAU,CAACoB,GAChB,KAAK,WAET,OAASC,EAAK,CACZ,KAAK,OAASA,EACd,KAAK,QAAUD,GACf,KAAK,UACP,CACA,OAAAxB,EAAcU,EACdQ,GAAe,IAAI,EACnB,KAAK,QAAU,CAACK,EACT,EACT,EAEAH,EAAS,UAAU,WAAa,SAAUnB,EAAM,CAC9C,GAAI,KAAK,WAAa,OAAW,CAC/B,KAAK,QAAUoB,GAAWnB,EAI1B,QACMD,EAAO,KAAK,SAChBA,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,WAAWA,CAAI,CAEhC,CACAE,EAAO,UAAU,WAAW,KAAK,KAAMF,CAAI,CAC7C,EAEAmB,EAAS,UAAU,aAAe,SAAUnB,EAAM,CAEhD,GAAI,KAAK,WAAa,SACpBE,EAAO,UAAU,aAAa,KAAK,KAAMF,CAAI,EAIzC,KAAK,WAAa,QAAW,CAC/B,KAAK,QAAU,CAACC,EAEhB,QACMD,EAAO,KAAK,SAChBA,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,aAAaA,CAAI,CAElC,CAEJ,EAEAmB,EAAS,UAAU,QAAU,UAAY,CACvC,GAAI,EAAE,KAAK,OAASE,GAAW,CAC7B,KAAK,QAAUD,GAAWC,EAE1B,QACMrB,EAAO,KAAK,SAChBA,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,QAAQ,CAEzB,CACF,EAEA,OAAO,eAAemB,EAAS,UAAW,QAAS,CACjD,KAAoB,CAClB,GAAI,KAAK,OAASG,EAEhB,MAAMZ,EAER,IAAMV,EAAOH,GAAc,IAAI,EAK/B,GAJA,KAAK,SAAS,EACVG,IAAS,SACXA,EAAK,SAAW,KAAK,UAEnB,KAAK,OAASuB,GAChB,MAAM,KAAK,OAEb,OAAO,KAAK,MACd,CACF,CAAC,EAyBD,SAASE,GAAYlB,EAAgC,CACnD,OAAO,IAAIY,EAASZ,CAAE,CACxB,CAEA,SAASmB,GAAclB,EAAgB,CACrC,IAAMmB,EAAUnB,EAAO,SAGvB,GAFAA,EAAO,SAAW,OAEd,OAAOmB,GAAY,WAAY,CAChBhB,GAAW,EAG5B,IAAMF,EAAcV,EACpBA,EAAc,OACd,GAAI,CACF4B,EAAS,CACX,OAASH,EAAK,CACZ,MAAAhB,EAAO,QAAU,CAACc,EAClBd,EAAO,QAAUoB,EACjBC,GAAcrB,CAAM,EACdgB,CACR,QAAE,CACAzB,EAAcU,EACdG,GAAS,CACX,CACF,CACF,CAEA,SAASiB,GAAcrB,EAAgB,CACrC,QACMR,EAAOQ,EAAO,SAClBR,IAAS,OACTA,EAAOA,EAAK,YAEZA,EAAK,QAAQ,aAAaA,CAAI,EAEhCQ,EAAO,IAAM,OACbA,EAAO,SAAW,OAElBkB,GAAclB,CAAM,CACtB,CAEA,SAASsB,GAAwBrB,EAAiC,CAChE,GAAIV,IAAgB,KAElB,MAAMW,EAERO,GAAe,IAAI,EACnBlB,EAAcU,EAEd,KAAK,QAAU,CAACa,EACZ,KAAK,OAASM,GAChBC,GAAc,IAAI,EAEpBjB,GAAS,CACX,CAmBA,SAASmB,GAAqBxB,EAAc,CAC1C,KAAK,IAAMA,EACX,KAAK,SAAW,OAChB,KAAK,SAAW,OAChB,KAAK,mBAAqB,OAC1B,KAAK,OAASN,CAChB,CAEA8B,GAAO,UAAU,UAAY,UAAY,CACvC,IAAMC,EAAS,KAAK,OAAO,EAC3B,GAAI,CAEF,GADI,KAAK,OAASJ,GACd,KAAK,MAAQ,OAAW,OAE5B,IAAMD,EAAU,KAAK,IAAI,EACrB,OAAOA,GAAY,aACrB,KAAK,SAAWA,EAEpB,QAAE,CACAK,EAAO,CACT,CACF,EAEAD,GAAO,UAAU,OAAS,UAAY,CACpC,GAAI,KAAK,OAAST,EAEhB,MAAMZ,EAER,KAAK,QAAUY,EACf,KAAK,QAAU,CAACM,EAChBF,GAAc,IAAI,EAClBX,GAAe,IAAI,EAEFJ,GAAW,EAC5B,IAAMF,EAAcV,EACpB,OAAAA,EAAc,KACP+B,GAAU,KAAK,KAAMrB,CAAW,CACzC,EAEAsB,GAAO,UAAU,QAAU,UAAY,CAC/B,KAAK,OAASV,IAClB,KAAK,QAAUA,EACf,KAAK,mBAAqB5B,GAC1BA,GAAgB,KAEpB,EAEAsC,GAAO,UAAU,SAAW,UAAY,CACtC,KAAK,QAAUH,EAET,KAAK,OAASN,GAClBO,GAAc,IAAI,CAEtB,EAeA,SAASrB,GAAOD,EAA0B,CACxC,IAAMC,EAAS,IAAIuB,GAAOxB,CAAE,EAC5B,GAAI,CACFC,EAAO,UAAU,CACnB,OAASgB,EAAK,CACZ,MAAAhB,EAAO,SAAS,EACVgB,CACR,CAGA,OAAOhB,EAAO,SAAS,KAAKA,CAAM,CACpC,CCj0BA,SAASyB,GACPC,EACAC,EAAa,GACQ,CACrB,IAAMC,EAA0B,CAAC,EACjC,QAAWC,KAAOH,EAChB,GAAIA,EAAO,eAAeG,CAAG,EAAG,CAC9B,IAAMC,EAAQJ,EAAOG,CAAG,EACxB,GAAIC,aAAiBC,EAAQ,CAC3B,GAAIJ,GAAcE,EAAI,WAAW,GAAG,EAClC,SAEFD,EAAGC,CAAG,EAAIC,EAAM,KAClB,MACEF,EAAGC,CAAG,EAAIJ,GAAaK,CAAK,CAEhC,CAEF,OAAOF,CACT,CAEA,SAASI,GACPC,EACAC,EACAC,EAAgB,GACV,CACN,QAAWN,KAAOK,EAChB,GAAIA,EAAO,eAAeL,CAAG,EAAG,CAC9B,IAAMC,EAAQI,EAAOL,CAAG,EACxB,GAAIC,aAAiB,QAAU,CAAC,MAAM,QAAQA,CAAK,EAC5CG,EAAOJ,CAAG,IACbI,EAAOJ,CAAG,EAAI,CAAC,GAEjBG,GACEC,EAAOJ,CAAG,EACVC,EACAK,CACF,MACK,CACL,GAAIA,GAAiBF,EAAOJ,CAAG,EAC7B,SAEFI,EAAOJ,CAAG,EAAI,IAAIE,EAAOD,CAAK,CAChC,CACF,CAEJ,CAEA,SAASM,GACPV,EACAW,EACM,CACN,QAAWR,KAAOH,EAChB,GAAIA,EAAO,eAAeG,CAAG,EAAG,CAC9B,IAAMC,EAAQJ,EAAOG,CAAG,EACpBC,aAAiBC,EACnBM,EAAGR,EAAKC,CAAK,EAEbM,GAAWN,EAAuBO,CAAE,CAExC,CAEJ,CAGA,SAASC,GAAaC,KAA2BC,EAA8B,CAC7E,IAAMC,EAAuB,CAAC,EAC9B,QAAWZ,KAAOW,EAAM,CACtB,IAAME,EAAQb,EAAI,MAAM,GAAG,EACvBc,EAAcJ,EACdK,EAAYH,EAChB,QAASI,EAAI,EAAGA,EAAIH,EAAM,OAAS,EAAGG,IAAK,CACzC,IAAMC,EAAOJ,EAAMG,CAAC,EACpB,GAAI,CAACF,EAAYG,CAAI,EACnB,MAAO,CAAC,EAELF,EAAUE,CAAI,IACjBF,EAAUE,CAAI,EAAI,CAAC,GAErBH,EAAcA,EAAYG,CAAI,EAC9BF,EAAYA,EAAUE,CAAI,CAC5B,CACA,IAAMC,EAAOL,EAAMA,EAAM,OAAS,CAAC,EACnCE,EAAUG,CAAI,EAAIJ,EAAYI,CAAI,CACpC,CACA,OAAON,CACT,CAEO,IAAMO,GAAN,KAAkB,CAGvB,aAAc,CAFd,KAAQ,SAAyB,CAAC,CAEnB,CAEf,OAAOC,EAAmC,CACxC,MAAO,CAAC,CAAC,KAAK,OAAOA,CAAgB,CACvC,CAEA,OAAOA,EAA8C,CACnD,IAAMP,EAAQO,EAAiB,MAAM,GAAG,EACpCC,EAAa,KAAK,SACtB,QAASL,EAAI,EAAGA,EAAIH,EAAM,OAAS,EAAGG,IAAK,CACzC,IAAMC,EAAOJ,EAAMG,CAAC,EACpB,GAAI,CAACK,EAAWJ,CAAI,EAClB,OAAO,KAETI,EAAaA,EAAWJ,CAAI,CAC9B,CACA,IAAMC,EAAOL,EAAMA,EAAM,OAAS,CAAC,EACnC,OAAOQ,EAAWH,CAAI,CACxB,CAEA,IAAsBE,EAA0BvB,EAAW,CACzD,IAAMgB,EAAQO,EAAiB,MAAM,GAAG,EACpCC,EAAa,KAAK,SACtB,QAAS,EAAI,EAAG,EAAIR,EAAM,OAAS,EAAG,IAAK,CACzC,IAAMI,EAAOJ,EAAM,CAAC,EACfQ,EAAWJ,CAAI,IAClBI,EAAWJ,CAAI,EAAI,CAAC,GAEtBI,EAAaA,EAAWJ,CAAI,CAC9B,CACA,IAAMC,EAAOL,EAAMA,EAAM,OAAS,CAAC,EACnCQ,EAAWH,CAAI,EAAIrB,CACrB,CAEA,MAASuB,EAA6B,CAEpC,OADe,KAAK,OAAOA,CAAgB,GAC5B,KACjB,CAEA,IAAOA,EAA0BnB,EAAU,CACzC,IAAMqB,EAAI,KAAK,OAAOF,EAAkBnB,CAAK,EAC7CqB,EAAE,MAAQrB,CACZ,CAEA,OAAUmB,EAA0BnB,EAAU,CAC5C,IAAMY,EAAQO,EAAiB,MAAM,GAAG,EACpCC,EAAa,KAAK,SACtB,QAASL,EAAI,EAAGA,EAAIH,EAAM,OAAS,EAAGG,IAAK,CACzC,IAAMC,EAAOJ,EAAMG,CAAC,EACfK,EAAWJ,CAAI,IAClBI,EAAWJ,CAAI,EAAI,CAAC,GAEtBI,EAAaA,EAAWJ,CAAI,CAC9B,CACA,IAAMC,EAAOL,EAAMA,EAAM,OAAS,CAAC,EAE7BU,EAAUF,EAAWH,CAAI,EAC/B,GAAMK,EAAS,OAAOA,EAEtB,IAAM1B,EAAS,IAAIK,EAAOD,CAAK,EAC/B,OAAAoB,EAAWH,CAAI,EAAIrB,EAEZA,CACT,CAEA,UAAU2B,EAA6B,CACrC,QAAWC,KAAQD,EAAmB,CACpC,IAAMX,EAAQY,EAAK,MAAM,GAAG,EACxBJ,EAAa,KAAK,SACtB,QAAS,EAAI,EAAG,EAAIR,EAAM,OAAS,EAAG,IAAK,CACzC,IAAMI,EAAOJ,EAAM,CAAC,EACpB,GAAI,CAACQ,EAAWJ,CAAI,EAClB,OAEFI,EAAaA,EAAWJ,CAAI,CAC9B,CACA,IAAMC,EAAOL,EAAMA,EAAM,OAAS,CAAC,EACnC,OAAOQ,EAAWH,CAAI,CACxB,CACF,CAEA,MAAMQ,EAAqBpB,EAAgB,GAAO,CAChDH,GAAY,KAAK,SAAUuB,EAAOpB,CAAa,CACjD,CAEA,UAAUK,EAA8B,CACtC,OAAOF,GAAa,KAAK,OAAO,EAAG,GAAGE,CAAI,CAC5C,CAEA,KAAKH,EAAiD,CACpDD,GAAW,KAAK,SAAUC,CAAE,CAC9B,CAEA,OAAOV,EAAa,GAAqB,CACvC,OAAOF,GAAa,KAAK,SAAUE,CAAU,CAC/C,CAEA,KAAK6B,EAAe,GAAM7B,EAAa,GAAO,CAC5C,IAAMO,EAAS,KAAK,OAAOP,CAAU,EACrC,OAAK6B,EAGE,KAAK,UAAUtB,EAAQ,KAAM,CAAC,EAF5B,KAAK,UAAUA,CAAM,CAGhC,CAEO,UAAW,CAChB,OAAO,KAAK,KAAK,CACnB,CACF,EC3MO,IAAMuB,GAAU,SC4BvB,IAAMC,GAAiBC,GACrBA,EAAE,OAAS,EACPC,GAAmBD,GACvBA,EAAE,OAAS,EACPE,GAAqBF,GACzBA,EAAE,OAAS,EACPG,GAAkBH,GACtBA,EAAE,OAAS,EAEAI,GAAN,KAAa,CAAb,cACL,KAAQ,SAAW,IAAIC,GACvB,KAAQ,QAA6B,CAAC,EACtC,KAAQ,OAAwB,CAAC,EACjC,KAAQ,QAAyB,CAAC,EAClC,KAAQ,SAA4B,CAAC,EACrC,KAAQ,WAAyB,CAAE,OAAAC,GAAQ,SAAAC,GAAU,OAAAC,EAAO,EAC5D,KAAQ,SAAW,IAAI,IAEvB,IAAI,SAAU,CACZ,OAAOC,EACT,CAEA,QAAQC,EAAiC,CACvC,IAAMC,EAAmB,IAAI,IAAoB,KAAK,OAAO,EAE7DD,EAAc,QAASE,GAAW,CAChC,GAAIA,EAAO,iBACT,QAAWC,KAAsBD,EAAO,gBACtC,GAAI,CAACD,EAAiB,IAAIE,CAAkB,EAE1C,MAAMC,EAKZ,IAAIC,EACJ,GAAIhB,GAAca,CAAM,EAAG,CACzB,GAAI,KAAK,OAAO,SAASA,CAAM,EAC7B,MAAMI,EAER,KAAK,OAAO,KAAKJ,CAAM,CACzB,SAAWX,GAAgBW,CAAM,EAAG,CAClC,GAAI,KAAK,SAAS,SAASA,CAAM,EAC/B,MAAMI,EAER,KAAK,SAAS,KAAKJ,CAAM,EACzBG,EAAoBH,EAAO,YAC7B,SAAWT,GAAeS,CAAM,EAAG,CACjC,GAAM,KAAK,QAAQA,EAAO,IAAI,EAC5B,MAAMI,EAER,KAAK,QAAQJ,EAAO,IAAI,EAAIA,CAC9B,SAAWV,GAAkBU,CAAM,EAAG,CACpC,GAAI,KAAK,QAAQ,SAASA,CAAM,EAC9B,MAAMI,EAER,KAAK,QAAQ,KAAKJ,CAAM,EACxBG,EAAoBH,EAAO,YAC7B,KACE,OAAMK,EAGR,GAAIF,EAAmB,CACrB,IAAMG,EAAO,KACbH,EAAkB,CAChB,IAAI,SAAU,CACZ,OAAOG,EAAK,QACd,EACA,QAAS,KAAK,QACd,WAAY,KAAK,WACjB,aAAc,KAAK,aAAa,KAAK,IAAI,EACzC,QAAS,KAAK,QAAQ,KAAK,IAAI,CACjC,CAAC,CACH,CAEAP,EAAiB,IAAIC,CAAM,CAC7B,CAAC,EAED,KAAK,aAAa,SAAS,IAAI,CACjC,CAEQ,QAAQO,EAAkB,CAChC,IAAMC,EAAa,KAAK,SAAS,IAAID,CAAO,EAC5C,GAAIC,EAAY,CACd,QAAWC,KAAWD,EAAW,IAC/BC,EAAQ,EAEV,KAAK,SAAS,OAAOF,CAAO,CAC9B,CACF,CAEA,aAAaG,EAAsB,CACjC,IAAMC,EAAgB,IAAI,IAE1B,KAAK,QAAQ,QAAQ,CAACvB,EAAGwB,IAAO,CAC9B,KAAK,YAAYF,EAAcG,GAAO,CAC/BD,GAAI,KAAK,QAAQC,CAAE,EAExB,QAAWC,KAAUD,EAAG,QAAS,CAC/B,IAAME,EAAW,GAAGF,EAAG,QAAQC,CAAM,CAAC,IAAM,GACxCE,EAAeD,EAEnB,GAAI,CAACD,EAAO,WAAW1B,EAAE,IAAI,EAAG,SAQhC,GANKyB,EAAG,GAAG,SACTA,EAAG,GAAKI,GAAiBJ,CAAE,GAG7BF,EAAc,MAAM,EAEhBvB,EAAE,KAAM,CACV,IAAM8B,EAAeL,EAAG,QAAQ,YAAY,EAE5C,GAAI,CADY,CAAC,GAAGzB,EAAE,IAAI,EAAE,KAAM+B,GAAMD,EAAa,MAAMC,CAAC,CAAC,EAE3D,MAAMjB,CAEV,CAEA,IAAIkB,EAASN,EAAO,MAAM1B,EAAE,KAAK,MAAM,EACnC,CAACiC,EAAK,GAAGC,CAAoB,EAAIF,EAAO,MAAM,GAAG,EACrD,GAAIhC,EAAE,OAASiC,EAAI,OAAS,EAE1B,MAAME,EAER,GAAInC,EAAE,SAAWiC,EAAI,SAAW,EAE9B,MAAME,EAEJF,EAAI,SACNA,EAAMA,EAAI,CAAC,EAAE,YAAY,EAAIA,EAAI,MAAM,CAAC,GAG1C,IAAMG,EAAeF,EAAqB,IAAKG,GAAM,CACnD,GAAM,CAACC,EAAO,GAAGC,CAAI,EAAIF,EAAE,MAAM,GAAG,EACpC,MAAO,CAAE,MAAAC,EAAO,KAAAC,CAAK,CACvB,CAAC,EACD,GAAIvC,EAAE,UACJ,QAAWwC,KAAYJ,EACrB,GAAI,CAACpC,EAAE,SAAS,IAAIwC,EAAS,KAAK,EAEhC,MAAM1B,EAIZ,IAAM2B,EAAO,IAAI,IACjB,QAAWD,KAAYJ,EACrBK,EAAK,IAAID,EAAS,MAAOA,EAAS,IAAI,EAGxC,GAAIxC,EAAE,OAAS4B,EAAa,OAE1B,MAAMO,EAER,GAAInC,EAAE,WAAa,CAAC4B,EAAa,OAE/B,MAAMO,EAGR,IAAMO,EAAa,OAEbC,EAAS,CACb,GAAI3C,EAAE,QAAQ,KAAO,CAAC,EACtB,GAAG,KAAK,OACR,GAAIA,EAAE,QAAQ,MAAQ,CAAC,CACzB,EACA,QAAW4C,KAASD,EAAQ,CAC1B,GAAIpB,EAAc,IAAIqB,CAAK,EAAG,SAC9BrB,EAAc,IAAIqB,CAAK,EAEvB,IAAMC,EAAkBjB,EAAa,MAAMc,CAAU,EAC/CI,EAAyB,CAAC,EAEhCD,EAAgB,QAASE,GAAQ,CAC/B,IAAIC,EAAUD,EACRE,EAAU,CAAC,GAAGD,EAAQ,SAASJ,EAAM,MAAM,CAAC,EAClD,GAAIK,EAAQ,OACV,QAAWC,KAASD,EAAS,CAC3B,GAAI,CAACC,EAAM,OAAQ,SACnB,GAAM,CAAE,OAAAC,CAAO,EAAID,EACb,CAAE,MAAAE,EAAM,EAAID,EAClBH,EAAUA,EAAQ,QAAQI,GAAOR,EAAM,MAAMO,CAAM,CAAC,CACtD,CAEFL,EAAa,KAAKE,CAAO,CAC3B,CAAC,EAEDpB,EAAekB,EAAa,KAAK;AAAA,CAAK,CACxC,CAEA,IAAM5B,EAAO,KACPmC,EAAwB,CAC5B,IAAI,SAAU,CACZ,OAAOnC,EAAK,QACd,EACA,aAAc,KAAK,aAAa,KAAK,IAAI,EACzC,QAAS,KAAK,QAAQ,KAAK,IAAI,EAC/B,QAAS,KAAK,QACd,WAAY,KAAK,WACjB,GAAAO,EACA,OAAAC,EACA,IAAAO,EACA,SAAUN,EACV,MAAOC,EACP,KAAM,IAAM,CACV,MAAM0B,EACR,EACA,KAAMb,CACR,EAEA,GAAI,CAACzC,EAAE,YAAYqD,CAAG,GAAK,CAACrD,EAAE,OAAS4B,EAAa,OAAQ,CAC1D,IAAM2B,EAAa3B,EAChB,MAAMc,CAAU,EAChB,IAAKc,GAAMA,EAAE,KAAK,CAAC,EACnB,OAAQA,GAAMA,EAAE,MAAM,EACzBD,EAAWA,EAAW,OAAS,CAAC,EAAI,UAClCA,EAAWA,EAAW,OAAS,CAAC,CAClC,GACA,IAAME,EAAIF,EAAW,IAAKC,GAAM,KAAKA,CAAC,EAAE,EAAE,KAAK;AAAA,CAAK,EAC9CE,EAAY,OAAOD,CAAC;AAAA,EAAoEA,EAAE,WAC9F,IACA,KACF,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GACD,GAAI,CACF,IAAME,EAAgB3D,EAAE,UAAY,CAAC,EAC/B4D,EAAK,IAAI,SACb,MACA,GAAGD,EACHD,CACF,EACAL,EAAI,KAAOO,CACb,OAASC,EAAG,CACV,IAAMC,EAAM,IAAI,MAAM,GAAGD,CAAC;AAAA;AAAA,EAAWH,CAAS,EAAE,EAChD,QAAQ,MAAMI,CAAG,EACjB,QACF,CACF,CAEA,IAAMzC,EAAUrB,EAAE,OAAOqD,CAAG,EACxBhC,IACG,KAAK,SAAS,IAAII,CAAE,GACvB,KAAK,SAAS,IAAIA,EAAI,CACpB,GAAIA,EAAG,GACP,IAAK,IAAI,GACX,CAAC,EAEH,KAAK,SAAS,IAAIA,CAAE,EAAG,IAAI,IAAIJ,CAAO,EAE1C,CACF,CAAC,CACH,CAAC,CACH,CAEQ,YACNF,EACA4C,EACAC,EAAgB,EAChB,CACA,GACE,CAAC7C,GACD,EAAEA,aAAmB,aAAeA,aAAmB,YAEvD,OAAO,KAOT,IAJA4C,EAAS5C,CAAO,EAEhB6C,EAAgB,EAChB7C,EAAUA,EAAQ,kBACXA,GACL,KAAK,YAAYA,EAAS4C,EAAUC,GAAe,EACnD7C,EAAUA,EAAQ,kBAEtB,CACF,ECnSA,IAAM8C,GAAK,IAAIC,GACfD,GAAG,KACCE,GACAC,GACAC,GACAC,GACAC,GACAC,EACJ,EAEO,IAAMC,GAAWR,GClBxBS,GAAS,KAAK",
  "names": ["DATASTAR", "DATASTAR_EVENT", "DATASTAR_REQUEST", "executeScriptAttributes", "FragmentMergeModes", "fragmentMergeMode", "EventTypes", "err", "code", "DATASTAR", "ERR_BAD_ARGS", "ERR_ALREADY_EXISTS", "ERR_NOT_FOUND", "ERR_NOT_ALLOWED", "ERR_METHOD_NOT_ALLOWED", "ERR_SERVICE_UNAVAILABLE", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "line", "field", "valueOffset", "value", "retry", "a", "b", "res", "EventStreamContentType", "DefaultRetryInterval", "LastEventId", "fetchEventSource", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "openWhenHidden", "inputFetch", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "rest", "resolve", "reject", "retries", "headers", "curRequestController", "onVisibilityChange", "create", "retryInterval", "retryTimer", "dispose", "fetch", "onopen", "response", "getBytes", "getLines", "getMessages", "id", "retry", "err", "interval", "ERR_SERVICE_UNAVAILABLE", "innerErr", "DATASTAR_SSE_EVENT", "DATASTAR", "SETTLING_CLASS", "SWAPPING_CLASS", "STARTED", "FINISHED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "isWrongContent", "err", "dispatchSSE", "type", "argsRaw", "DATASTAR_SSE_EVENT", "sendSSERequest", "method", "ctx", "url", "args", "ERR_BAD_ARGS", "onlyRemoteSignals", "headers", "DATASTAR_REQUEST", "signals", "elID", "signalsJSON", "STARTED", "urlInstance", "req", "evt", "DATASTAR", "argsRawLines", "lines", "line", "colonIndex", "key", "argLines", "value", "FINISHED", "queryParams", "revisedURL", "fetchEventSource", "DeleteSSE", "sendSSERequest", "GetSSE", "sendSSERequest", "PatchSSE", "sendSSERequest", "PostSSE", "sendSSERequest", "PutSSE", "sendSSERequest", "Clipboard", "_", "text", "ERR_NOT_ALLOWED", "Increment", "ctx", "singalKeyPath", "delta", "signal", "SetAll", "ctx", "regexp", "newValue", "re", "name", "signal", "ToggleAll", "ctx", "regexp", "re", "name", "signal", "ClampFit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "ClampFitInt", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "Fit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "FitInt", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "INDICATOR_CLASS", "DATASTAR", "INDICATOR_LOADING_CLASS", "Indicator", "ctx", "value", "signals", "el", "signal", "watcher", "event", "type", "elID", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "Computed", "ctx", "signals", "key", "expr", "computed", "c", "IF_MISSING", "MergeSignals", "ctx", "el", "expr", "mods", "possibleMergeValues", "Star", "kebabize", "str", "$", "ofs", "isBoolString", "dataURIRegex", "updateModelEvents", "Bind", "ctx", "el", "value", "expr", "key", "signals", "effect", "setFromSignal", "fromElementToSignal", "isTwoWayBinding", "signalName", "tnl", "signalDefault", "isInput", "type", "isCheckbox", "isSelect", "isRadio", "isFile", "hasValue", "v", "vStr", "input", "select", "opt", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "ERR_BAD_ARGS", "match", "mimeName", "nameName", "current", "selectedValues", "ERR_METHOD_NOT_ALLOWED", "kebabKey", "kebabize", "event", "setElementFromSignalDisposer", "Class", "ctx", "classes", "k", "v", "classNames", "argsToMs", "args", "arg", "argsHas", "defaultValue", "debounce", "callback", "wait", "leading", "trailing", "timer", "resetTimer", "args", "throttle", "waiting", "knownOnModifiers", "lastSignalsMarshalled", "On", "ctx", "el", "key", "expr", "target", "callback", "evt", "debounceArgs", "wait", "argsToMs", "leading", "argsHas", "trailing", "debounce", "throttleArgs", "throttle", "evtListOpts", "attrName", "eventValues", "cb", "attr", "valid", "lowerAttr", "ERR_BAD_ARGS", "eventName", "kebabize", "rafId", "raf", "onlyRemoteSignals", "current", "called", "e", "targetHTML", "isEl", "Ref", "el", "value", "signals", "Text", "ctx", "el", "expr", "effect", "ERR_BAD_ARGS", "res", "SESSION", "LOCAL", "REMOTE", "Persist", "ctx", "signals", "expr", "key", "DATASTAR", "expression", "keys", "parts", "part", "lastMarshalled", "storageType", "useRemote", "signalsUpdateHandler", "_", "marshalled", "DATASTAR_EVENT", "marshalledSignals", "unmarshalledSignals", "ReplaceUrl", "ctx", "expr", "effect", "value", "baseUrl", "url", "ONCE", "HALF", "FULL", "Intersection", "ctx", "mods", "options", "observer", "entries", "entry", "consistentUniqID", "el", "hash", "hashUpdate", "n", "hashUpdateFromStr", "str", "c", "i", "e", "DATASTAR", "scrollIntoView", "opts", "shouldFocus", "ERR_NOT_FOUND", "SMOOTH", "INSTANT", "AUTO", "HSTART", "HCENTER", "HEND", "HNEAREST", "VSTART", "VCENTER", "VEND", "VNEAREST", "FOCUS", "CENTER", "START", "END", "NEAREST", "ScrollIntoView", "el", "mods", "rawKey", "opts", "scrollIntoView", "NONE", "DISPLAY", "Show", "ctx", "expr", "s", "effect", "docWithViewTransitionAPI", "supportsViewTransitions", "VIEW_TRANSITION", "ViewTransition", "hasViewTransitionMeta", "node", "meta", "ctx", "supportsViewTransitions", "el", "expr", "name", "elVTASTyle", "validJSIdentifier", "validNestedJSIdentifier", "SignalsGetMacro", "groups", "key", "SignalsSetMacro", "value", "ActionsMacro", "action", "args", "withCtx", "x", "argsJoined", "ExecuteScript", "EventTypes", "datastarSSEEventWatcher", "autoRemoveRaw", "attributesRaw", "executeScriptAttributes", "script", "autoRemove", "isBoolString", "ERR_BAD_ARGS", "scriptEl", "attr", "pivot", "key", "value", "generatedByIdiomorphId", "idiomorph", "oldNode", "newContent", "config", "parsedContent", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "bestMatch", "findBestNodeMatch", "ERR_NOT_FOUND", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "insertSiblings", "ERR_BAD_ARGS", "isSoftMatch", "FragmentMergeModes", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "from", "to", "type", "fromAttribute", "toAttribute", "syncAttribute", "fromValue", "toValue", "attributeName", "fAttr", "tAttr", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "newNode", "newElt", "resolver", "promise", "resolve", "removedElement", "noOp", "createIdMap", "elt", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "parser", "contentWithSvgsRemoved", "content", "Element", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "populateIdMapForNode", "idMap", "nodeParent", "idElements", "current", "oldContent", "MergeFragments", "EventTypes", "ctx", "fragmentContainer", "datastarSSEEventWatcher", "fragmentsRaw", "selector", "mergeMode", "fragmentMergeMode", "settleDurationRaw", "useViewTransitionRaw", "settleDuration", "useViewTransition", "isBoolString", "fragment", "ERR_BAD_ARGS", "selectorOrID", "allTargets", "supportsViewTransitions", "docWithViewTransitionAPI", "applyToTargets", "capturedTargets", "initialTarget", "SWAPPING_CLASS", "originalHTML", "modifiedTarget", "FragmentMergeModes", "result", "idiomorph", "oldNode", "_", "attrName", "value", "revisedHTML", "SETTLING_CLASS", "MergeSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "signals", "onlyIfMissing", "isBoolString", "possibleMergeSignals", "RemoveFragments", "EventTypes", "datastarSSEEventWatcher", "selector", "settleDurationRaw", "useViewTransitionRaw", "ERR_BAD_ARGS", "settleDuration", "useViewTransition", "isBoolString", "removeTargets", "applyToTargets", "target", "SWAPPING_CLASS", "supportsViewTransitions", "docWithViewTransitionAPI", "RemoveSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "pathsRaw", "paths", "p", "ERR_BAD_ARGS", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "ERR_BAD_ARGS", "startBatch", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "OUTDATED", "NOTIFIED", "RUNNING", "HAS_ERROR", "err", "computed", "cleanupEffect", "cleanup", "DISPOSED", "disposeEffect", "endEffect", "Effect", "finish", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "walkNested", "cb", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "dotDelimitedPath", "subSignals", "s", "current", "dotDelimitedPaths", "path", "other", "shouldIndent", "VERSION", "isMacroPlugin", "p", "isWatcherPlugin", "isAttributePlugin", "isActionPlugin", "Engine", "SignalsRoot", "signal", "computed", "effect", "VERSION", "pluginsToLoad", "allLoadedPlugins", "plugin", "requiredPluginType", "ERR_NOT_ALLOWED", "globalInitializer", "ERR_ALREADY_EXISTS", "ERR_NOT_FOUND", "that", "element", "removalSet", "removal", "rootElement", "appliedMacros", "pi", "el", "rawKey", "rawValue", "valueRevised", "consistentUniqID", "lowerCaseTag", "r", "keyRaw", "key", "modifiersWithArgsArr", "ERR_BAD_ARGS", "modifiersArr", "m", "label", "args", "modifier", "mods", "splitRegex", "macros", "macro", "expressionParts", "revisedParts", "exp", "revised", "matches", "match", "groups", "whole", "ctx", "ERR_METHOD_NOT_ALLOWED", "statements", "s", "j", "fnContent", "argumentNames", "fn", "e", "err", "callback", "siblingOffset", "ds", "Engine", "Star", "ActionsMacro", "SignalsSetMacro", "SignalsGetMacro", "MergeSignals", "Computed", "Datastar", "Datastar"]
}
