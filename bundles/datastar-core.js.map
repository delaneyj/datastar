{
  "version": 3,
  "sources": ["../code/ts/library/src/plugins/official/attributes/core/computed.ts", "../code/ts/library/src/plugins/official/attributes/core/star.ts", "../code/ts/library/src/utils/signals.ts", "../code/ts/library/src/plugins/official/attributes/core/store.ts", "../code/ts/library/src/engine/consts.ts", "../code/ts/library/src/utils/regex.ts", "../code/ts/library/src/plugins/official/preprocessors/core/actions.ts", "../code/ts/library/src/plugins/official/preprocessors/core/signals.ts", "../code/ts/library/src/engine/errors.ts", "../code/ts/library/src/utils/dom.ts", "../code/ts/library/src/vendored/preact-core.ts", "../code/ts/library/src/vendored/deepsignal.ts", "../code/ts/library/src/vendored/ts-merge-patch.ts", "../code/ts/library/src/engine/version.ts", "../code/ts/library/src/engine/engine.ts", "../code/ts/library/src/engine/index.ts", "../code/ts/library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// Authors: Delaney Gillilan\n// Icon: fluent:draw-text-24-filled\n// Slug: Create a computed signal\n// Description: This attribute creates a computed signal that updates when its dependencies change.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Computed: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"computed\",\n    mustNotEmptyKey: true,\n    onLoad: (ctx) => {\n        const store = ctx.store();\n        store[ctx.key] = ctx.reactivity.computed(() => {\n            return ctx.expressionFn(ctx);\n        });\n\n        return () => {\n            const store = ctx.store();\n            delete store[ctx.key];\n        };\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:rocket\n// Slug: Star\n// Description: Sage advice for the weary traveler\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Star: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"star\",\n    onLoad: () => {\n        alert(\"YOU ARE PROBABLY OVERCOMPLICATING IT\");\n    },\n};\n", "export function remoteSignals(obj: Object): Object {\n    const res: Record<string, any> = {};\n\n    for (const [k, v] of Object.entries(obj)) {\n        if (k.startsWith(\"_\")) {\n            continue;\n        } else if (typeof v === \"object\" && !Array.isArray(v)) {\n            res[k] = remoteSignals(v); // recurse\n        } else {\n            res[k] = v;\n        }\n    }\n\n    return res;\n}\n\nexport function storeFromPossibleContents(\n    currentStore: any,\n    contents: any,\n    hasIfMissing: boolean,\n) {\n    const actual: any = {};\n\n    if (!hasIfMissing) {\n        Object.assign(actual, contents);\n    } else {\n        for (const key in contents) {\n            const currentValue = currentStore[key]?.value;\n            if (currentValue === undefined || currentValue === null) {\n                actual[key] = contents[key];\n            }\n        }\n    }\n\n    return actual;\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:home-storage\n// Slug: Store signals into a singleton per page\n// Description: This action stores signals into a singleton per page. This is useful for storing signals that are used across multiple components.\n\nimport {\n    AttributeContext,\n    AttributePlugin,\n    RegexpGroups,\n} from \"../../../../engine\";\nimport { storeFromPossibleContents } from \"../../../../utils/signals\";\n\n// Setup the global store\nexport const Store: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"store\",\n    removeNewLines: true,\n    preprocessors: {\n        pre: [\n            {\n                pluginType: \"preprocessor\",\n                name: \"store\",\n                regexp: /(?<whole>.+)/g,\n                replacer: (groups: RegexpGroups) => {\n                    const { whole } = groups;\n                    return `Object.assign({...ctx.store()}, ${whole})`;\n                },\n            },\n        ],\n    },\n    allowedModifiers: new Set([\"ifmissing\"]),\n    onLoad: (ctx: AttributeContext) => {\n        const possibleMergeSignals = ctx.expressionFn(ctx);\n        const actualMergeSignals = storeFromPossibleContents(\n            ctx.store(),\n            possibleMergeSignals,\n            ctx.modifiers.has(\"ifmissing\"),\n        );\n        ctx.mergeSignals(actualMergeSignals);\n\n        delete ctx.el.dataset[ctx.rawKey];\n    },\n};\n", "// This is auto-generated by Datastar. DO NOT EDIT.\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"datastar-request\";\nexport const VERSION = \"0.20.0-beta-3\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during merges. Allows for CSS transitions to complete.\nexport const DefaultSettleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing from the store?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals into the store.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals from the store.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import { DATASTAR } from \"../engine/consts\";\n\nexport const validJSIdentifier = `[a-zA-Z_$]+`;\nexport const validNestedJSIdentifier = validJSIdentifier + `[0-9a-zA-Z_$.]*`;\n\nexport function wholePrefixSuffix(\n    rune: string,\n    prefix: string,\n    suffix: string,\n    nestable = true,\n) {\n    const identifier = nestable ? validNestedJSIdentifier : validJSIdentifier;\n    return new RegExp(\n        `(?<whole>${rune}(?<${prefix}>${identifier})${suffix})`,\n        `g`,\n    );\n}\n\nexport const isDatastarGeneratedID = (el: Element) =>\n    el.id.match(`^${DATASTAR}-`) !== null;\n", "import { PreprocessorPlugin, RegexpGroups } from \"../../../../engine\";\nimport { wholePrefixSuffix } from \"../../../../utils/regex\";\n\n// Replacing $action(args) with ctx.actions.action(ctx, args)\nexport const ActionsProcessor: PreprocessorPlugin = {\n    name: \"action\",\n    pluginType: \"preprocessor\",\n    regexp: wholePrefixSuffix(\n        \"\\\\$\",\n        \"action\",\n        \"(?<call>\\\\((?<args>.*)\\\\))\",\n        false,\n    ),\n    replacer: ({ action, args }: RegexpGroups) => {\n        const withCtx = [`ctx`];\n        if (args) {\n            withCtx.push(...args.split(\",\").map((x) => x.trim()));\n        }\n        const argsJoined = withCtx.join(\",\");\n        return `ctx.actions.${action}.method(${argsJoined})`;\n    },\n};\n", "import { PreprocessorPlugin, RegexpGroups } from \"../../../../engine\";\nimport { wholePrefixSuffix } from \"../../../../utils/regex\";\n\n// Replacing $signal with ctx.store.signal.value`\nexport const SignalsProcessor: PreprocessorPlugin = {\n    name: \"signal\",\n    pluginType: \"preprocessor\",\n    regexp: wholePrefixSuffix(\"\\\\$\", \"signal\", \"(?<method>\\\\([^\\\\)]*\\\\))?\"),\n    replacer: (groups: RegexpGroups) => {\n        const { signal, method } = groups;\n        const prefix = `ctx.store()`;\n        if (!method?.length) {\n            return `${prefix}.${signal}.value`;\n        }\n        const parts = signal.split(\".\");\n        const methodName = parts.pop();\n        const nestedSignal = parts.join(\".\");\n        return `${prefix}.${nestedSignal}.value.${methodName}${method}`;\n    },\n};\n", "import { DATASTAR } from \"./consts\";\n\nconst err = (code: number) => {\n    const e = new Error();\n    e.name = `${DATASTAR}${code}`;\n    return e;\n};\n\nexport const ERR_BAD_ARGS = err(400);\nexport const ERR_ALREADY_EXISTS = err(409);\nexport const ERR_NOT_FOUND = err(404);\nexport const ERR_NOT_ALLOWED = err(403);\nexport const ERR_METHOD_NOT_ALLOWED = err(405);\nexport const ERR_SERVICE_UNAVAILABLE = err(503);\n", "import { ERR_BAD_ARGS, ERR_NOT_FOUND } from \"../engine/errors\";\nimport { HTMLorSVGElement } from \"./types\";\n\nexport function elemToSelector(\n    elm: Element | Window | Document | string | null,\n) {\n    if (!elm) return \"null\";\n    if (typeof elm === \"string\") return elm;\n    if (elm instanceof Window) return \"Window\";\n    if (elm instanceof Document) return \"Document\";\n\n    if (elm.tagName === \"BODY\") return \"BODY\";\n    const names = new Array<string>();\n    while (elm.parentElement && elm.tagName !== \"BODY\") {\n        if (elm.id) {\n            const idAttr = elm.getAttribute(\"id\");\n            if (!idAttr) {\n                // Element has an ID but no ID attribute\n                throw ERR_BAD_ARGS;\n            }\n            names.unshift(\"#\" + idAttr); // getAttribute, because `elm.id` could also return a child element with name \"id\"\n            break; // Because ID should be unique, no more is needed. Remove the break, if you always want a full path.\n        } else {\n            let c = 1,\n                e = elm;\n            for (; e.previousElementSibling; e = e.previousElementSibling, c++);\n            names.unshift(elm.tagName + \":nth-child(\" + c + \")\");\n        }\n        elm = elm.parentElement;\n    }\n    return names.join(\">\");\n}\n\nexport function nodeHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n        return null;\n    }\n    return node;\n}\n\nexport function scrollIntoView(\n    el: HTMLElement | SVGElement,\n    opts: ScrollIntoViewOptions,\n    shouldFocus = true,\n) {\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        // Element is not an HTMLElement or SVGElement\n        throw ERR_NOT_FOUND;\n    }\n    if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n\n    el.scrollIntoView(opts);\n    if (shouldFocus) el.focus();\n}\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n\nimport { ERR_BAD_ARGS } from \"../engine/errors\";\n\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal;\n  _prevSource?: Node;\n  _nextSource?: Node;\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect;\n  _prevTarget?: Node;\n  _nextTarget?: Node;\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number;\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node;\n};\n\nfunction startBatch() {\n  batchDepth++;\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--;\n    return;\n  }\n\n  let error: unknown;\n  let hasError = false;\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect;\n    batchedEffect = undefined;\n\n    batchIteration++;\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect;\n      effect._nextBatchedEffect = undefined;\n      effect._flags &= ~NOTIFIED;\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback();\n        } catch (err) {\n          if (!hasError) {\n            error = err;\n            hasError = true;\n          }\n        }\n      }\n      effect = next;\n    }\n  }\n  batchIteration = 0;\n  batchDepth--;\n\n  if (hasError) {\n    throw error;\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn();\n  }\n  /*@__INLINE__**/ startBatch();\n  try {\n    return fn();\n  } finally {\n    endBatch();\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return fn();\n  } finally {\n    evalContext = prevContext;\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined;\n  }\n\n  let node = signal._node;\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    };\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node;\n    }\n    evalContext._sources = node;\n    signal._node = node;\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node);\n    }\n    return node;\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0;\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource;\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource;\n      }\n\n      node._prevSource = evalContext._sources;\n      node._nextSource = undefined;\n\n      evalContext._sources!._nextSource = node;\n      evalContext._sources = node;\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node;\n  }\n  return undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown;\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number;\n\n  /** @internal */\n  _node?: Node;\n\n  /** @internal */\n  _targets?: Node;\n\n  constructor(value?: T);\n\n  /** @internal */\n  _refresh(): boolean;\n\n  /** @internal */\n  _subscribe(node: Node): void;\n\n  /** @internal */\n  _unsubscribe(node: Node): void;\n\n  subscribe(fn: (value: T) => void): () => void;\n\n  valueOf(): T;\n\n  toString(): string;\n\n  toJSON(): T;\n\n  peek(): T;\n\n  brand: typeof BRAND_SYMBOL;\n\n  get value(): T;\n  set value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value;\n  this._version = 0;\n  this._node = undefined;\n  this._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n  return true;\n};\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets;\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node;\n    }\n    this._targets = node;\n  }\n};\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget;\n    const next = node._nextTarget;\n    if (prev !== undefined) {\n      prev._nextTarget = next;\n      node._prevTarget = undefined;\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev;\n      node._nextTarget = undefined;\n    }\n    if (node === this._targets) {\n      this._targets = next;\n    }\n  }\n};\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value;\n\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      fn(value);\n    } finally {\n      evalContext = prevContext;\n    }\n  });\n};\n\nSignal.prototype.valueOf = function () {\n  return this.value;\n};\n\nSignal.prototype.toString = function () {\n  return this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n  return this.value;\n};\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return this.value;\n  } finally {\n    evalContext = prevContext;\n  }\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n  get(this: Signal) {\n    const node = addDependency(this);\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    return this._value;\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        // Cycle detected\n        throw ERR_BAD_ARGS;\n      }\n\n      this._value = value;\n      this._version++;\n      globalVersion++;\n\n      /**@__INLINE__*/ startBatch();\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify();\n        }\n      } finally {\n        endBatch();\n      }\n    }\n  },\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true;\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node;\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode;\n    }\n    node._source._node = node;\n    node._version = -1;\n\n    if (node._nextSource === undefined) {\n      target._sources = node;\n      break;\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources;\n  let head = undefined;\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource;\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node);\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource;\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev;\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node;\n    }\n\n    node._source._node = node._rollbackNode;\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined;\n    }\n\n    node = prev;\n  }\n\n  target._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n  _fn: () => T;\n  _sources?: Node;\n  _globalVersion: number;\n  _flags: number;\n\n  constructor(fn: () => T);\n\n  _notify(): void;\n  get value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined);\n\n  this._fn = fn;\n  this._sources = undefined;\n  this._globalVersion = globalVersion - 1;\n  this._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED;\n\n  if (this._flags & RUNNING) {\n    return false;\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true;\n  }\n  this._flags &= ~OUTDATED;\n\n  if (this._globalVersion === globalVersion) {\n    return true;\n  }\n  this._globalVersion = globalVersion;\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING;\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING;\n    return true;\n  }\n\n  const prevContext = evalContext;\n  try {\n    prepareSources(this);\n    evalContext = this;\n    const value = this._fn();\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value;\n      this._flags &= ~HAS_ERROR;\n      this._version++;\n    }\n  } catch (err) {\n    this._value = err;\n    this._flags |= HAS_ERROR;\n    this._version++;\n  }\n  evalContext = prevContext;\n  cleanupSources(this);\n  this._flags &= ~RUNNING;\n  return true;\n};\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING;\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node);\n    }\n  }\n  Signal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node);\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING;\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node);\n      }\n    }\n  }\n};\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED;\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify();\n    }\n  }\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw ERR_BAD_ARGS;\n    }\n    const node = addDependency(this);\n    this._refresh();\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    if (this._flags & HAS_ERROR) {\n      throw this._value;\n    }\n    return this._value;\n  },\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T;\n  peek(): T;\n\n  subscribe(fn: (value: T) => void): () => void;\n  valueOf(): T;\n  toString(): string;\n  toJSON(): T;\n  brand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup;\n  effect._cleanup = undefined;\n\n  if (typeof cleanup === \"function\") {\n    /*@__INLINE__**/ startBatch();\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      cleanup!();\n    } catch (err) {\n      effect._flags &= ~RUNNING;\n      effect._flags |= DISPOSED;\n      disposeEffect(effect);\n      throw err;\n    } finally {\n      evalContext = prevContext;\n      endBatch();\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node);\n  }\n  effect._fn = undefined;\n  effect._sources = undefined;\n\n  cleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    // Out-of-order effect\n    throw ERR_BAD_ARGS;\n  }\n  cleanupSources(this);\n  evalContext = prevContext;\n\n  this._flags &= ~RUNNING;\n  if (this._flags & DISPOSED) {\n    disposeEffect(this);\n  }\n  endBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n  _fn?: EffectFn;\n  _cleanup?: () => void;\n  _sources?: Node;\n  _nextBatchedEffect?: Effect;\n  _flags: number;\n\n  constructor(fn: EffectFn);\n\n  _callback(): void;\n  _start(): () => void;\n  _notify(): void;\n  _dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn;\n  this._cleanup = undefined;\n  this._sources = undefined;\n  this._nextBatchedEffect = undefined;\n  this._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start();\n  try {\n    if (this._flags & DISPOSED) return;\n    if (this._fn === undefined) return;\n\n    const cleanup = this._fn();\n    if (typeof cleanup === \"function\") {\n      this._cleanup = cleanup!;\n    }\n  } finally {\n    finish();\n  }\n};\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    // Cycle detected\n    throw ERR_BAD_ARGS;\n  }\n  this._flags |= RUNNING;\n  this._flags &= ~DISPOSED;\n  cleanupEffect(this);\n  prepareSources(this);\n\n  /*@__INLINE__**/ startBatch();\n  const prevContext = evalContext;\n  evalContext = this;\n  return endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED;\n    this._nextBatchedEffect = batchedEffect;\n    batchedEffect = this;\n  }\n};\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED;\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this);\n  }\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn);\n  try {\n    effect._callback();\n  } catch (err) {\n    effect._dispose();\n    throw err;\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect);\n}\n\nexport { batch, computed, effect, Signal, untracked };\nexport type { ReadonlySignal };\n", "// From https://github.com/EthanStandel/deepsignal/blob/main/packages/core/src/core.ts\nimport { ERR_NOT_ALLOWED } from \"../engine/errors\";\nimport { batch, Signal, signal } from \"./preact-core\";\n\nexport type AtomicState =\n  | Array<unknown>\n  | ((...args: unknown[]) => unknown)\n  | string\n  | boolean\n  | number\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type DeepState = {\n  [key: string]: (() => unknown) | AtomicState | DeepState;\n};\n\nexport type ReadOnlyDeep<T> = {\n  readonly [P in keyof T]: ReadOnlyDeep<T[P]>;\n};\n\nexport interface DeepSignalAccessors<T extends DeepState> {\n  value: ReadOnlyDeep<T>;\n  peek: () => ReadOnlyDeep<T>;\n}\n\nexport type DeepSignalType<T extends DeepState> =\n  & DeepSignalAccessors<T>\n  & {\n    [K in keyof T]: T[K] extends AtomicState ? Signal<T[K]>\n      : T[K] extends DeepState ? DeepSignalType<T[K]>\n      : Signal<T[K]>;\n  };\n\nexport class DeepSignal<T extends DeepState> implements DeepSignalAccessors<T> {\n  get value(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>);\n  }\n\n  set value(payload: ReadOnlyDeep<T>) {\n    batch(() => setValue(this as DeepSignalType<T>, payload));\n  }\n\n  peek(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>, { peek: true });\n  }\n}\n\nexport const deepSignal = <T extends DeepState>(\n  initialValue: T,\n): DeepSignalType<T> =>\n  Object.assign(\n    new DeepSignal(),\n    Object.entries(initialValue).reduce(\n      (acc, [key, value]) => {\n        if ([\"value\", \"peek\"].some((iKey) => iKey === key)) {\n          // console.error(`${key} is a reserved property name`)\n          throw ERR_NOT_ALLOWED;\n        } else if (\n          typeof value !== \"object\" || value === null || Array.isArray(value)\n        ) {\n          acc[key] = signal(value);\n        } else {\n          acc[key] = deepSignal(value);\n        }\n        return acc;\n      },\n      {} as { [key: string]: unknown },\n    ),\n  ) as DeepSignalType<T>;\n\nconst setValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  payload: U,\n): void =>\n  Object.keys(payload).forEach((\n    key: keyof U,\n  ) => (deepSignal[key].value = payload[key]));\n\nconst getValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  { peek = false }: { peek?: boolean } = {},\n): ReadOnlyDeep<U> =>\n  Object.entries(deepSignal).reduce(\n    (acc, [key, value]) => {\n      if (value instanceof Signal) {\n        acc[key] = peek ? value.peek() : value.value;\n      } else if (value instanceof DeepSignal) {\n        acc[key] = getValue(value as DeepSignalType<DeepState>, { peek });\n      }\n      return acc;\n    },\n    {} as { [key: string]: unknown },\n  ) as ReadOnlyDeep<U>;\n", "// From https://github.com/riagominota/ts-merge-patch/blob/main/src/index.ts\n\ntype mpObj<T> = { [k in keyof T | string | number | symbol]: any };\nexport function apply<L, R>(\n  target: mpObj<L>,\n  patchItem: mpObj<R>,\n): Partial<L> & Partial<R>;\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): R;\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): {};\nexport function apply<L, R>(target: mpObj<L>, patchItem: null): null;\nexport function apply<L, R>(target: mpObj<L>, patchItem: string): string;\nexport function apply<L, R>(target: mpObj<L>, patchItem: number): number;\nexport function apply<L, R>(target: mpObj<L>, patchItem: undefined): undefined;\nexport function apply<L, R>(target: mpObj<L>, patchItem: R[]): R[];\n\nexport function apply(target: any, patchItem: any): any {\n  /**\n   * If the patch is anything other than an object,\n   * the result will always be to replace\n   * the entire target with the entire patch.\n   */\n  if (\n    typeof patchItem !== \"object\" || Array.isArray(patchItem) || !patchItem\n  ) {\n    return JSON.parse(JSON.stringify(patchItem)); //return new instance of variable\n  }\n\n  if (\n    typeof patchItem === \"object\" &&\n    patchItem.toJSON !== undefined &&\n    typeof patchItem.toJSON === \"function\"\n  ) {\n    return patchItem.toJSON();\n  }\n  /** Also, it is not possible to\n   * patch part of a target that is not an object,\n   * such as to replace just some of the values in an array.\n   */\n  let targetResult = target;\n  if (typeof target !== \"object\") {\n    //Target is empty/not an object, so basically becomes patch, minus any null valued sections (becomes {} + patch)\n    targetResult = { ...patchItem };\n  }\n\n  Object.keys(patchItem).forEach((k) => {\n    if (!targetResult.hasOwnProperty(k)) targetResult[k] = patchItem[k]; //This ensure the key exists and TS can't throw a wobbly over an undefined key\n    if (patchItem[k] === null) {\n      delete targetResult[k];\n    } else {\n      targetResult[k] = apply(targetResult[k], patchItem[k]);\n    }\n  });\n  return targetResult;\n}\n", "export const VERSION = '0.20.0-beta-3';\n", "import { nodeHTMLorSVGElement } from \"../utils/dom\";\nimport { HTMLorSVGElement } from \"../utils/types\";\nimport { DeepSignal, deepSignal, DeepState } from \"../vendored/deepsignal\";\nimport { computed, effect, Signal, signal } from \"../vendored/preact-core\";\nimport { apply } from \"../vendored/ts-merge-patch\";\nimport { DATASTAR } from \"./consts\";\n\nimport {\n    ERR_ALREADY_EXISTS,\n    ERR_BAD_ARGS,\n    ERR_METHOD_NOT_ALLOWED,\n    ERR_NOT_ALLOWED,\n    ERR_NOT_FOUND,\n} from \"./errors\";\nimport {\n    ActionPlugin,\n    ActionPlugins,\n    AttribtueExpressionFunction,\n    AttributeContext,\n    AttributePlugin,\n    DatastarPlugin,\n    InitContext,\n    OnRemovalFn,\n    PreprocessorPlugin,\n    Reactivity,\n    WatcherPlugin,\n} from \"./types\";\nimport { VERSION } from \"./version\";\n\nconst isPreprocessorPlugin = (p: DatastarPlugin): p is PreprocessorPlugin =>\n    p.pluginType === \"preprocessor\";\nconst isWatcherPlugin = (p: DatastarPlugin): p is WatcherPlugin =>\n    p.pluginType === \"watcher\";\nconst isAttributePlugin = (p: DatastarPlugin): p is AttributePlugin =>\n    p.pluginType === \"attribute\";\nconst isActionPlugin = (p: DatastarPlugin): p is ActionPlugin =>\n    p.pluginType === \"action\";\n\nexport class Engine {\n    plugins: AttributePlugin[] = [];\n    store: DeepSignal<any> = deepSignal({});\n    preprocessors = new Array<PreprocessorPlugin>();\n    actions: ActionPlugins = {};\n    watchers = new Array<WatcherPlugin>();\n    refs: Record<string, HTMLElement> = {};\n    reactivity: Reactivity = {\n        signal,\n        computed,\n        effect,\n    };\n    parentID = \"\";\n    missingIDNext = 0;\n    removals = new Map<Element, { id: string; set: Set<OnRemovalFn> }>();\n    mergeRemovals = new Array<OnRemovalFn>();\n\n    get version() {\n        return VERSION;\n    }\n\n    load(...pluginsToLoad: DatastarPlugin[]) {\n        const allLoadedPlugins = new Set<DatastarPlugin>(this.plugins);\n\n        pluginsToLoad.forEach((plugin) => {\n            if (plugin.requiredPlugins) {\n                for (\n                    const requiredPluginType of plugin\n                        .requiredPlugins\n                ) {\n                    if (\n                        !allLoadedPlugins.has(requiredPluginType)\n                    ) {\n                        // requires other plugin to be loaded\n                        throw ERR_NOT_ALLOWED;\n                    }\n                }\n            }\n\n            let globalInitializer: ((ctx: InitContext) => void) | undefined;\n            if (isPreprocessorPlugin(plugin)) {\n                if (this.preprocessors.includes(plugin)) {\n                    throw ERR_ALREADY_EXISTS;\n                }\n                this.preprocessors.push(plugin);\n            } else if (isWatcherPlugin(plugin)) {\n                if (this.watchers.includes(plugin)) {\n                    throw ERR_ALREADY_EXISTS;\n                }\n                this.watchers.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else if (isActionPlugin(plugin)) {\n                if (!!this.actions[plugin.name]) {\n                    throw ERR_ALREADY_EXISTS;\n                }\n                this.actions[plugin.name] = plugin;\n            } else if (isAttributePlugin(plugin)) {\n                if (this.plugins.includes(plugin)) {\n                    throw ERR_ALREADY_EXISTS;\n                }\n                this.plugins.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else {\n                throw ERR_NOT_FOUND;\n            }\n\n            if (globalInitializer) {\n                globalInitializer({\n                    store: () => this.store,\n                    upsertSignal: this.upsertSignal\n                        .bind(this),\n                    mergeSignals: this.mergeSignals.bind(this),\n                    removeSignals: this.removeSignals.bind(this),\n                    actions: this.actions,\n                    reactivity: this.reactivity,\n                    applyPlugins: this.applyPlugins.bind(this),\n                    cleanup: this.cleanup.bind(\n                        this,\n                    ),\n                });\n            }\n\n            allLoadedPlugins.add(plugin);\n        });\n\n        this.applyPlugins(document.body);\n    }\n\n    private cleanup(element: Element) {\n        const removalSet = this.removals.get(element);\n        if (removalSet) {\n            for (const removal of removalSet.set) {\n                removal();\n            }\n            this.removals.delete(element);\n        }\n    }\n\n    lastMarshalledStore = \"\";\n    private mergeSignals<T extends object>(mergeSignals: T) {\n        this.mergeRemovals.forEach((removal) => removal());\n        this.mergeRemovals = this.mergeRemovals.slice(0);\n\n        const revisedStore = apply(this.store.value, mergeSignals) as DeepState;\n        this.store = deepSignal(revisedStore);\n\n        const marshalledStore = JSON.stringify(this.store.value);\n        if (marshalledStore === this.lastMarshalledStore) return;\n    }\n\n    private removeSignals(...keys: string[]) {\n        const revisedStore = { ...this.store.value };\n        let found = false;\n        for (const key of keys) {\n            const parts = key.split(\".\");\n            let currentID = parts[0];\n            let subStore = revisedStore;\n            for (let i = 1; i < parts.length; i++) {\n                const part = parts[i];\n                if (!subStore[currentID]) {\n                    subStore[currentID] = {};\n                }\n                subStore = subStore[currentID];\n                currentID = part;\n            }\n            delete subStore[currentID];\n            found = true;\n        }\n        if (!found) return;\n        this.store = deepSignal(revisedStore);\n        this.applyPlugins(document.body);\n    }\n\n    private upsertSignal<T>(path: string, value: T) {\n        const parts = path.split(\".\");\n        let subStore = this.store as any;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subStore[part]) {\n                subStore[part] = {};\n            }\n            subStore = subStore[part];\n        }\n        const last = parts[parts.length - 1];\n\n        const current = subStore[last];\n        if (!!current) return current;\n\n        const signal = this.reactivity.signal(value);\n        subStore[last] = signal;\n\n        return signal;\n    }\n\n    private applyPlugins(rootElement: Element) {\n        const appliedProcessors = new Set<PreprocessorPlugin>();\n\n        this.plugins.forEach((p, pi) => {\n            this.walkDownDOM(rootElement, (el) => {\n                if (!pi) this.cleanup(el);\n\n                for (const rawKey in el.dataset) {\n                    const rawExpression = `${el.dataset[rawKey]}` || \"\";\n                    let expression = rawExpression;\n\n                    if (!rawKey.startsWith(p.name)) continue;\n\n                    if (el.id.length === 0) {\n                        el.id = `${DATASTAR}-${this.parentID}-${this\n                            .missingIDNext++}`;\n                    }\n\n                    appliedProcessors.clear();\n\n                    if (p.allowedTagRegexps) {\n                        const lowerCaseTag = el.tagName.toLowerCase();\n                        const allowed = [...p.allowedTagRegexps].some((r) =>\n                            lowerCaseTag.match(r)\n                        );\n                        if (!allowed) {\n                            throw ERR_NOT_ALLOWED;\n                        }\n                    }\n\n                    let keyRaw = rawKey.slice(p.name.length);\n                    let [key, ...modifiersWithArgsArr] = keyRaw.split(\".\");\n                    if (p.mustHaveEmptyKey && key.length > 0) {\n                        // must have empty key\n                        throw ERR_BAD_ARGS;\n                    }\n                    if (p.mustNotEmptyKey && key.length === 0) {\n                        // must have non-empty key\n                        throw ERR_BAD_ARGS;\n                    }\n                    if (key.length) {\n                        key = key[0].toLowerCase() + key.slice(1);\n                    }\n\n                    const modifiersArr = modifiersWithArgsArr.map((m) => {\n                        const [label, ...args] = m.split(\"_\");\n                        return { label, args };\n                    });\n                    if (p.allowedModifiers) {\n                        for (const modifier of modifiersArr) {\n                            if (!p.allowedModifiers.has(modifier.label)) {\n                                // modifier not allowed\n                                throw ERR_NOT_ALLOWED;\n                            }\n                        }\n                    }\n                    const modifiers = new Map<string, string[]>();\n                    for (const modifier of modifiersArr) {\n                        modifiers.set(modifier.label, modifier.args);\n                    }\n\n                    if (p.mustHaveEmptyExpression && expression.length) {\n                        // must have empty expression\n                        throw ERR_BAD_ARGS;\n                    }\n                    if (p.mustNotEmptyExpression && !expression.length) {\n                        // must have non-empty expression\n                        throw ERR_BAD_ARGS;\n                    }\n\n                    const splitRegex = /;|\\n/;\n\n                    if (p.removeNewLines) {\n                        expression = expression\n                            .split(\"\\n\")\n                            .map((p: string) => p.trim())\n                            .join(\" \");\n                    }\n\n                    const processors = [\n                        ...(p.preprocessors?.pre || []),\n                        ...this.preprocessors,\n                        ...(p.preprocessors?.post || []),\n                    ];\n                    for (const processor of processors) {\n                        if (appliedProcessors.has(processor)) continue;\n                        appliedProcessors.add(processor);\n\n                        const expressionParts = expression.split(splitRegex);\n                        const revisedParts: string[] = [];\n\n                        expressionParts.forEach((exp) => {\n                            let revised = exp;\n                            const matches = [\n                                ...revised.matchAll(processor.regexp),\n                            ];\n                            if (matches.length) {\n                                for (const match of matches) {\n                                    if (!match.groups) continue;\n                                    const { groups } = match;\n                                    const { whole } = groups;\n                                    revised = revised.replace(\n                                        whole,\n                                        processor.replacer(groups),\n                                    );\n                                }\n                            }\n                            revisedParts.push(revised);\n                        });\n                        // })\n\n                        expression = revisedParts.join(\"; \");\n                    }\n\n                    const ctx: AttributeContext = {\n                        store: () => this.store,\n                        mergeSignals: this.mergeSignals.bind(this),\n                        upsertSignal: this.upsertSignal\n                            .bind(this),\n                        removeSignals: this.removeSignals.bind(this),\n                        applyPlugins: this.applyPlugins.bind(this),\n                        cleanup: this.cleanup\n                            .bind(this),\n                        walkSignals: this.walkSignals.bind(this),\n                        actions: this.actions,\n                        reactivity: this.reactivity,\n                        el,\n                        rawKey,\n                        key,\n                        rawExpression,\n                        expression,\n                        expressionFn: () => {\n                            throw ERR_METHOD_NOT_ALLOWED;\n                        },\n                        modifiers,\n                    };\n\n                    if (\n                        !p.bypassExpressionFunctionCreation?.(ctx) &&\n                        !p.mustHaveEmptyExpression && expression.length\n                    ) {\n                        const statements = expression\n                            .split(splitRegex)\n                            .map((s) => s.trim())\n                            .filter((s) => s.length);\n                        statements[statements.length - 1] = `return ${\n                            statements[statements.length - 1]\n                        }`;\n                        const joined = statements.map((s) => `  ${s}`).join(\n                            \";\\n\",\n                        );\n                        const fnContent = `\n  try {\n    const _datastarExpression = () => {\n  ${joined}\n    }\n    const _datastarReturnVal = _datastarExpression()\n    return _datastarReturnVal\n  } catch (e) {\n   const msg = \\`\n  Error evaluating Datastar expression:\n  ${joined.replaceAll(\"`\", \"\\\\`\")}\n\n  Error: \\${e.message}\n\n  Check if the expression is valid before raising an issue.\n  \\`.trim()\n   console.error(msg)\n   debugger\n  }\n              `;\n\n                        try {\n                            const argumentNames = p.argumentNames || [];\n                            const fn = new Function(\n                                \"ctx\",\n                                ...argumentNames,\n                                fnContent,\n                            ) as AttribtueExpressionFunction;\n                            ctx.expressionFn = fn;\n                        } catch (e) {\n                            const err = new Error(`${e}\\nwith\\n${fnContent}`);\n                            console.error(err);\n                            debugger;\n                        }\n                    }\n\n                    const removal = p.onLoad(ctx);\n                    if (removal) {\n                        if (!this.removals.has(el)) {\n                            this.removals.set(el, {\n                                id: el.id,\n                                set: new Set(),\n                            });\n                        }\n                        this.removals.get(el)!.set.add(removal);\n                    }\n                }\n            });\n        });\n    }\n\n    private walkSignalsStore(\n        store: any,\n        callback: (name: string, signal: Signal<any>) => void,\n    ) {\n        const keys = Object.keys(store);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const value = store[key];\n            const isSignal = value instanceof Signal;\n            const hasChildren = typeof value === \"object\" &&\n                Object.keys(value).length > 0;\n\n            if (isSignal) {\n                callback(key, value);\n                continue;\n            }\n\n            if (!hasChildren) continue;\n\n            this.walkSignalsStore(value, callback);\n        }\n    }\n\n    private walkSignals(callback: (name: string, signal: Signal<any>) => void) {\n        this.walkSignalsStore(this.store, callback);\n    }\n\n    private walkDownDOM(\n        element: Element | null,\n        callback: (el: HTMLorSVGElement) => void,\n        siblingOffset = 0,\n    ) {\n        if (!element) return;\n        const el = nodeHTMLorSVGElement(element);\n        if (!el) return;\n\n        callback(el);\n\n        siblingOffset = 0;\n        element = element.firstElementChild;\n        while (element) {\n            this.walkDownDOM(element, callback, siblingOffset++);\n            element = element.nextElementSibling;\n        }\n    }\n}\n", "import { Computed } from \"../plugins/official/attributes/core/computed\";\nimport { Star } from \"../plugins/official/attributes/core/star\";\nimport { Store } from \"../plugins/official/attributes/core/store\";\nimport { ActionsProcessor } from \"../plugins/official/preprocessors/core/actions\";\nimport { SignalsProcessor } from \"../plugins/official/preprocessors/core/signals\";\nimport { Engine } from \"./engine\";\n\nexport { VERSION } from \"./consts\";\n\nexport type * from \"./types\";\n\nconst ds = new Engine();\nds.load(\n    ActionsProcessor,\n    SignalsProcessor,\n    Store,\n    Computed,\n    Star,\n);\n\nexport const Datastar = ds;\n", "import { Datastar } from \"../engine\";\n\nDatastar.load();\n"],
  "mappings": "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",
  "names": ["Computed", "ctx", "store", "Star", "storeFromPossibleContents", "currentStore", "contents", "hasIfMissing", "actual", "key", "currentValue", "Store", "groups", "whole", "ctx", "possibleMergeSignals", "actualMergeSignals", "storeFromPossibleContents", "DATASTAR", "FragmentMergeModes", "DefaultFragmentMergeMode", "validJSIdentifier", "validNestedJSIdentifier", "wholePrefixSuffix", "rune", "prefix", "suffix", "nestable", "identifier", "ActionsProcessor", "wholePrefixSuffix", "action", "args", "withCtx", "x", "argsJoined", "SignalsProcessor", "wholePrefixSuffix", "groups", "signal", "method", "prefix", "parts", "methodName", "nestedSignal", "err", "code", "DATASTAR", "ERR_BAD_ARGS", "ERR_ALREADY_EXISTS", "ERR_NOT_FOUND", "ERR_NOT_ALLOWED", "ERR_METHOD_NOT_ALLOWED", "ERR_SERVICE_UNAVAILABLE", "nodeHTMLorSVGElement", "node", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "batch", "fn", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "ERR_BAD_ARGS", "startBatch", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "OUTDATED", "NOTIFIED", "RUNNING", "HAS_ERROR", "err", "computed", "cleanupEffect", "cleanup", "DISPOSED", "disposeEffect", "endEffect", "Effect", "finish", "DeepSignal", "getValue", "payload", "batch", "setValue", "deepSignal", "initialValue", "acc", "key", "value", "iKey", "ERR_NOT_ALLOWED", "signal", "peek", "Signal", "apply", "target", "patchItem", "targetResult", "k", "VERSION", "isPreprocessorPlugin", "p", "isWatcherPlugin", "isAttributePlugin", "isActionPlugin", "Engine", "deepSignal", "signal", "computed", "effect", "VERSION", "pluginsToLoad", "allLoadedPlugins", "plugin", "requiredPluginType", "ERR_NOT_ALLOWED", "globalInitializer", "ERR_ALREADY_EXISTS", "ERR_NOT_FOUND", "element", "removalSet", "removal", "mergeSignals", "revisedStore", "apply", "keys", "found", "key", "parts", "currentID", "subStore", "i", "part", "path", "value", "last", "current", "rootElement", "appliedProcessors", "pi", "el", "rawKey", "rawExpression", "expression", "DATASTAR", "lowerCaseTag", "r", "keyRaw", "modifiersWithArgsArr", "ERR_BAD_ARGS", "modifiersArr", "m", "label", "args", "modifier", "modifiers", "splitRegex", "processors", "processor", "expressionParts", "revisedParts", "exp", "revised", "matches", "match", "groups", "whole", "ctx", "ERR_METHOD_NOT_ALLOWED", "statements", "s", "joined", "fnContent", "argumentNames", "fn", "e", "err", "store", "callback", "isSignal", "Signal", "hasChildren", "siblingOffset", "nodeHTMLorSVGElement", "ds", "Engine", "ActionsProcessor", "SignalsProcessor", "Store", "Computed", "Star", "Datastar", "Datastar"]
}
