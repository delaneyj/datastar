{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/errors.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/plugins/official/core/macros/signals.ts", "../library/src/utils/dom.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/nestedSignals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/vendored/fetch-event-source.ts", "../library/src/plugins/official/backend/shared.ts", "../library/src/plugins/official/backend/actions/sse.ts", "../library/src/plugins/official/backend/attributes/indicator.ts", "../library/src/plugins/official/backend/watchers/executeScript.ts", "../library/src/utils/view-transtions.ts", "../library/src/vendored/idiomorph.ts", "../library/src/plugins/official/backend/watchers/mergeFragments.ts", "../library/src/plugins/official/backend/watchers/mergeSignals.ts", "../library/src/plugins/official/backend/watchers/removeFragments.ts", "../library/src/plugins/official/backend/watchers/removeSignals.ts", "../library/src/plugins/official/browser/actions/clipboard.ts", "../library/src/plugins/official/browser/attributes/intersects.ts", "../library/src/plugins/official/browser/attributes/persist.ts", "../library/src/plugins/official/browser/attributes/replaceUrl.ts", "../library/src/plugins/official/browser/attributes/scrollIntoView.ts", "../library/src/plugins/official/browser/attributes/show.ts", "../library/src/plugins/official/browser/attributes/viewTransition.ts", "../library/src/plugins/official/dom/attributes/attributes.ts", "../library/src/plugins/official/dom/attributes/bind.ts", "../library/src/plugins/official/dom/attributes/class.ts", "../library/src/utils/arguments.ts", "../library/src/utils/timing.ts", "../library/src/plugins/official/dom/attributes/on.ts", "../library/src/plugins/official/dom/attributes/ref.ts", "../library/src/plugins/official/dom/attributes/text.ts", "../library/src/plugins/official/logic/actions/fit.ts", "../library/src/plugins/official/logic/actions/setAll.ts", "../library/src/plugins/official/logic/actions/toggleAll.ts", "../library/src/bundles/datastar.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\nexport const VERSION = \"0.20.1\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during merges. Allows for CSS transitions to complete.\nexport const DefaultSettleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import { DATASTAR } from \"./consts\";\n\nconst url = `https://data-star.dev/errors`;\n\nexport const hasValNonExpr = /([\\w0-9.]+)\\.value/gm;\n\n// Error codes use the format `{A-Z}{1-9}` (exluding `I` and `O`). Each file takes a letter, and each error within the file takes a number.\nexport enum ErrorCodes {\n    // Engine\n    RequiredPluginNotLoaded = \"A1\",\n    PluginAlreadyLoaded = \"A2\",\n    InvalidPluginType = \"A3\",\n    GenRXFunctionNotImplemented = \"A4\",\n    GeneratingExpressionFailed = \"A5\",\n    // ServerSentEvents\n    NoUrlProvided = \"B1\",\n    InvalidContentType = \"B2\",\n    SseFailed = \"B3\",\n    // Indicator\n    IndicatorKeyNotAllowed = \"C1\",\n    IndicatorValueNotProvided = \"C2\",\n    // ExecuteScript\n    NoScriptProvided = \"D1\",\n    // MergeFragments\n    NoFragmentsFound = \"E1\",\n    NoTargetsFound = \"E2\",\n    MorphFailed = \"E3\",\n    InvalidMergeMode = \"E4\",\n    // RemoveFragments\n    NoSelectorProvided = \"F1\",\n    // RemoveSignals\n    NoPathsProvided = \"G1\",\n    // Clipboard\n    ClipboardNotAvailable = \"H1\",\n    // Intersects\n    IntersectsKeyNotAllowed = \"J1\",\n    // Persist\n    NotImplementedError = \"K1\",\n    // ReplaceUrl\n    ReplaceUrlKeyNotAllowed = \"L1\",\n    ReplaceUrlValueNotProvided = \"L2\",\n    // ScrollIntoView\n    ScrollIntoViewKeyNotAllowed = \"M1\",\n    ScrollIntoViewValueNotAllowed = \"M2\",\n    NotHtmlSvgElement = \"M3\",\n    // Show\n    ShowKeyNotAllowed = \"N1\",\n    ShowValueNotProvided = \"N2\",\n    // Computed\n    ComputedKeyNotProvided = \"P1\",\n    // Bind\n    InvalidExpression = \"Q1\",\n    InvalidFileResultType = \"Q2\",\n    InvalidDataUri = \"Q3\",\n    UnsupportedSignalType = \"Q4\",\n    // On\n    InvalidValue = \"R1\",\n    // Ref\n    RefKeyNotAllowed = \"S1\",\n    RefValueNotProvided = \"S2\",\n    // Idiomorph (vendored)\n    NoBestMatchFound = \"Y1\",\n    InvalidMorphStyle = \"Y2\",\n    NoParentElementFound = \"Y3\",\n    NewElementCouldNotBeCreated = \"Y4\",\n    NoTemporaryNodeFound = \"Y5\",\n    NoContentFound = \"Y6\",\n    // Preact Core (vendored)\n    BatchError = \"Z1\",\n    SignalCycleDetected = \"Z2\",\n    GetComputedError = \"Z3\",\n    CleanupEffectError = \"Z4\",\n    EndEffectError = \"Z5\",\n    EffectError = \"Z6\",\n}\n\nexport const dsErr = (code: string, args?: any) => {\n    const e = new Error();\n    e.name = `${DATASTAR}${code}`;\n    const fullURL = `${url}/code?${new URLSearchParams(args)}`;\n    e.message = `${DATASTAR}${code}, for more info see ${fullURL}`;\n    return e;\n};\n", "import { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nconst name = \"computed\";\nexport const Computed: AttributePlugin = {\n    type: PluginType.Attribute,\n    name,\n    purge: true,\n    onLoad: ({ key, signals, genRX }) => {\n        const rx = genRX();\n        if (!key.length) {\n            throw dsErr(ErrorCodes.ComputedKeyNotProvided);\n        }\n        signals.setComputed(key, rx);\n    },\n};\n", "export const isBoolString = (str: string) => str.trim() === \"true\";\n\nexport const kebabize = (str: string) =>\n    str.replace(\n        /[A-Z]+(?![a-z])|[A-Z]/g,\n        ($, ofs) => (ofs ? \"-\" : \"\") + $.toLowerCase(),\n    );\n\nexport const jsStrToObject = (raw: string) => {\n    return (new Function(`return Object.assign({}, ${raw})`))();\n};\n", "import {\n    AttributePlugin,\n    NestedValues,\n    PluginType,\n} from \"../../../../engine/types\";\nimport { jsStrToObject } from \"../../../../utils/text\";\n\nexport const Signals: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"signals\",\n    purge: true,\n    onLoad: (ctx) => {\n        const { key, genRX, signals } = ctx;\n        if (key != \"\") {\n            signals.setValue(key, genRX()());\n        } else {\n            const obj = jsStrToObject(ctx.value);\n            ctx.value = JSON.stringify(obj);\n            signals.merge(genRX()<NestedValues>());\n        }\n    },\n};\n", "import { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nexport const Star: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"star\",\n    onLoad: () => {\n        alert(\"YOU ARE PROBABLY OVERCOMPLICATING IT\");\n    },\n};\n", "import { MacroPlugin, PluginType } from \"../../../../engine/types\";\n\nexport const SignalValueMacro: MacroPlugin = {\n    name: \"signalValue\",\n    type: PluginType.Macro,\n    fn: (original: string) => {\n        const validJS = /(?<path>[\\w0-9.]*)((\\.value))/gm;\n        const sub = `ctx.signals.signal('$1').value`;\n        return original.replaceAll(validJS, sub);\n    },\n};\n", "import { DATASTAR } from \"../engine/consts\";\n\nexport function elUniqId(el: Element) {\n    if (el.id) return el.id;\n    let hash = 0;\n    const hashUpdate = (n: number) => {\n        hash = ((hash << 5) - hash) + n;\n        return hash & hash;\n    };\n    const hashUpdateFromStr = (str: string) =>\n        str.split(\"\").forEach((c) => hashUpdate(c.charCodeAt(0)));\n\n    while (el.parentNode) {\n        if (el.id) {\n            hashUpdateFromStr(`${el.id}`);\n            break;\n        } else {\n            if (el === el.ownerDocument.documentElement) {\n                hashUpdateFromStr(el.tagName);\n            } else {\n                for (\n                    let i = 1, e = el;\n                    e.previousElementSibling;\n                    e = e.previousElementSibling, i++\n                ) {\n                    hashUpdate(i);\n                }\n                el = el.parentNode as Element;\n            }\n        }\n        el = el.parentNode as Element;\n    }\n    return DATASTAR + hash;\n}", "// An named symbol/brand for detecting Signal instances even when they weren't\n\nimport { dsErr, ErrorCodes } from \"../engine/errors\";\nimport { OnRemovalFn } from \"../engine/types\";\n\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n    // A source whose value the target depends on.\n    _source: Signal;\n    _prevSource?: Node;\n    _nextSource?: Node;\n\n    // A target that depends on the source and should be notified when the source changes.\n    _target: Computed | Effect;\n    _prevTarget?: Node;\n    _nextTarget?: Node;\n\n    // The version number of the source that target has last seen. We use version numbers\n    // instead of storing the source value, because source values can take arbitrary amount\n    // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n    // Use the special value -1 to mark potentially unused but recyclable nodes.\n    _version: number;\n\n    // Used to remember & roll back the source's previous `._node` value when entering &\n    // exiting a new evaluation context.\n    _rollbackNode?: Node;\n};\n\nfunction startBatch() {\n    batchDepth++;\n}\n\nfunction endBatch() {\n    if (batchDepth > 1) {\n        batchDepth--;\n        return;\n    }\n\n    let error: unknown;\n    let hasError = false;\n\n    while (batchedEffect !== undefined) {\n        let effect: Effect | undefined = batchedEffect;\n        batchedEffect = undefined;\n\n        batchIteration++;\n\n        while (effect !== undefined) {\n            const next: Effect | undefined = effect._nextBatchedEffect;\n            effect._nextBatchedEffect = undefined;\n            effect._flags &= ~NOTIFIED;\n\n            if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n                try {\n                    effect._callback();\n                } catch (err) {\n                    if (!hasError) {\n                        error = err;\n                        hasError = true;\n                    }\n                }\n            }\n            effect = next;\n        }\n    }\n    batchIteration = 0;\n    batchDepth--;\n\n    if (hasError) {\n        throw dsErr(ErrorCodes.BatchError, error);\n    }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n    if (batchDepth > 0) {\n        return fn();\n    }\n    /*@__INLINE__**/ startBatch();\n    try {\n        return fn();\n    } finally {\n        endBatch();\n    }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n        return fn();\n    } finally {\n        evalContext = prevContext;\n    }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n    if (evalContext === undefined) {\n        return undefined;\n    }\n\n    let node = signal._node;\n    if (node === undefined || node._target !== evalContext) {\n        /**\n         * `signal` is a new dependency. Create a new dependency node, and set it\n         * as the tail of the current context's dependency list. e.g:\n         *\n         * { A <-> B       }\n         *         \u2191     \u2191\n         *        tail  node (new)\n         *               \u2193\n         * { A <-> B <-> C }\n         *               \u2191\n         *              tail (evalContext._sources)\n         */\n        node = {\n            _version: 0,\n            _source: signal,\n            _prevSource: evalContext._sources,\n            _nextSource: undefined,\n            _target: evalContext,\n            _prevTarget: undefined,\n            _nextTarget: undefined,\n            _rollbackNode: node,\n        };\n\n        if (evalContext._sources !== undefined) {\n            evalContext._sources._nextSource = node;\n        }\n        evalContext._sources = node;\n        signal._node = node;\n\n        // Subscribe to change notifications from this dependency if we're in an effect\n        // OR evaluating a computed signal that in turn has subscribers.\n        if (evalContext._flags & TRACKING) {\n            signal._subscribe(node);\n        }\n        return node;\n    } else if (node._version === -1) {\n        // `signal` is an existing dependency from a previous evaluation. Reuse it.\n        node._version = 0;\n\n        /**\n         * If `node` is not already the current tail of the dependency list (i.e.\n         * there is a next node in the list), then make the `node` the new tail. e.g:\n         *\n         * { A <-> B <-> C <-> D }\n         *         \u2191           \u2191\n         *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n         *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n         *               \u2193     \u2193\n         * { A <-> C <-> D <-> B }\n         *                     \u2191\n         *                    tail (evalContext._sources)\n         */\n        if (node._nextSource !== undefined) {\n            node._nextSource._prevSource = node._prevSource;\n\n            if (node._prevSource !== undefined) {\n                node._prevSource._nextSource = node._nextSource;\n            }\n\n            node._prevSource = evalContext._sources;\n            node._nextSource = undefined;\n\n            evalContext._sources!._nextSource = node;\n            evalContext._sources = node;\n        }\n\n        // We can assume that the currently evaluated effect / computed signal is already\n        // subscribed to change notifications from `signal` if needed.\n        return node;\n    }\n    return undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n    /** @internal */\n    _value: unknown;\n\n    /**\n     * @internal\n     * Version numbers should always be >= 0, because the special value -1 is used\n     * by Nodes to signify potentially unused but recyclable nodes.\n     */\n    _version: number;\n\n    /** @internal */\n    _node?: Node;\n\n    /** @internal */\n    _targets?: Node;\n\n    constructor(value?: T);\n\n    /** @internal */\n    _refresh(): boolean;\n\n    /** @internal */\n    _subscribe(node: Node): void;\n\n    /** @internal */\n    _unsubscribe(node: Node): void;\n\n    subscribe(fn: (value: T) => void): () => void;\n\n    valueOf(): T;\n\n    toString(): string;\n\n    toJSON(): T;\n\n    peek(): T;\n\n    brand: typeof BRAND_SYMBOL;\n\n    get value(): T;\n    set value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n    this._value = value;\n    this._version = 0;\n    this._node = undefined;\n    this._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n    return true;\n};\n\nSignal.prototype._subscribe = function (node) {\n    if (this._targets !== node && node._prevTarget === undefined) {\n        node._nextTarget = this._targets;\n        if (this._targets !== undefined) {\n            this._targets._prevTarget = node;\n        }\n        this._targets = node;\n    }\n};\n\nSignal.prototype._unsubscribe = function (node) {\n    // Only run the unsubscribe step if the signal has any subscribers to begin with.\n    if (this._targets !== undefined) {\n        const prev = node._prevTarget;\n        const next = node._nextTarget;\n        if (prev !== undefined) {\n            prev._nextTarget = next;\n            node._prevTarget = undefined;\n        }\n        if (next !== undefined) {\n            next._prevTarget = prev;\n            node._nextTarget = undefined;\n        }\n        if (node === this._targets) {\n            this._targets = next;\n        }\n    }\n};\n\nSignal.prototype.subscribe = function (fn) {\n    return effect(() => {\n        const value = this.value;\n\n        const prevContext = evalContext;\n        evalContext = undefined;\n        try {\n            fn(value);\n        } finally {\n            evalContext = prevContext;\n        }\n    });\n};\n\nSignal.prototype.valueOf = function () {\n    return this.value;\n};\n\nSignal.prototype.toString = function () {\n    return this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n    return this.value;\n};\n\nSignal.prototype.peek = function () {\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n        return this.value;\n    } finally {\n        evalContext = prevContext;\n    }\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n    get(this: Signal) {\n        const node = addDependency(this);\n        if (node !== undefined) {\n            node._version = this._version;\n        }\n        return this._value;\n    },\n    set(this: Signal, value) {\n        if (value !== this._value) {\n            if (batchIteration > 100) {\n                throw dsErr(ErrorCodes.SignalCycleDetected);\n            }\n\n            this._value = value;\n            this._version++;\n            globalVersion++;\n\n            /**@__INLINE__*/ startBatch();\n            try {\n                for (\n                    let node = this._targets;\n                    node !== undefined;\n                    node = node._nextTarget\n                ) {\n                    node._target._notify();\n                }\n            } finally {\n                endBatch();\n            }\n        }\n    },\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n    return new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n    // Check the dependencies for changed values. The dependency list is already\n    // in order of use. Therefore if multiple dependencies have changed values, only\n    // the first used dependency is re-evaluated at this point.\n    for (\n        let node = target._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        // If there's a new version of the dependency before or after refreshing,\n        // or the dependency has something blocking it from refreshing at all (e.g. a\n        // dependency cycle), then we need to recompute.\n        if (\n            node._source._version !== node._version ||\n            !node._source._refresh() ||\n            node._source._version !== node._version\n        ) {\n            return true;\n        }\n    }\n    // If none of the dependencies have changed values since last recompute then\n    // there's no need to recompute.\n    return false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n    /**\n     * 1. Mark all current sources as re-usable nodes (version: -1)\n     * 2. Set a rollback node if the current node is being used in a different context\n     * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n     *\n     *    { undefined <- A <-> B <-> C -> undefined }\n     *                   \u2191           \u2191\n     *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     * target._sources = A; (node is head)  \u2502\n     *                   \u2193                  \u2502\n     * target._sources = C; (node is tail) \u2500\u2518\n     */\n    for (\n        let node = target._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        const rollbackNode = node._source._node;\n        if (rollbackNode !== undefined) {\n            node._rollbackNode = rollbackNode;\n        }\n        node._source._node = node;\n        node._version = -1;\n\n        if (node._nextSource === undefined) {\n            target._sources = node;\n            break;\n        }\n    }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n    let node = target._sources;\n    let head: Node | undefined = undefined;\n\n    /**\n     * At this point 'target._sources' points to the tail of the doubly-linked list.\n     * It contains all existing sources + new sources in order of use.\n     * Iterate backwards until we find the head node while dropping old dependencies.\n     */\n    while (node !== undefined) {\n        const prev = node._prevSource;\n\n        /**\n         * The node was not re-used, unsubscribe from its change notifications and remove itself\n         * from the doubly-linked list. e.g:\n         *\n         * { A <-> B <-> C }\n         *         \u2193\n         *    { A <-> C }\n         */\n        if (node._version === -1) {\n            node._source._unsubscribe(node);\n\n            if (prev !== undefined) {\n                prev._nextSource = node._nextSource;\n            }\n            if (node._nextSource !== undefined) {\n                node._nextSource._prevSource = prev;\n            }\n        } else {\n            /**\n             * The new head is the last node seen which wasn't removed/unsubscribed\n             * from the doubly-linked list. e.g:\n             *\n             * { A <-> B <-> C }\n             *   \u2191     \u2191     \u2191\n             *   \u2502     \u2502     \u2514 head = node\n             *   \u2502     \u2514 head = node\n             *   \u2514 head = node\n             */\n            head = node;\n        }\n\n        node._source._node = node._rollbackNode;\n        if (node._rollbackNode !== undefined) {\n            node._rollbackNode = undefined;\n        }\n\n        node = prev;\n    }\n\n    target._sources = head;\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n    _fn: () => T;\n    _sources?: Node;\n    _globalVersion: number;\n    _flags: number;\n\n    constructor(fn: () => T);\n\n    _notify(): void;\n    get value(): T;\n}\n\nexport function Computed(this: Computed, fn: () => unknown) {\n    Signal.call(this, undefined);\n\n    this._fn = fn;\n    this._sources = undefined;\n    this._globalVersion = globalVersion - 1;\n    this._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n    this._flags &= ~NOTIFIED;\n\n    if (this._flags & RUNNING) {\n        return false;\n    }\n\n    // If this computed signal has subscribed to updates from its dependencies\n    // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n    // flag not set), then the computed value can't have changed.\n    if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n        return true;\n    }\n    this._flags &= ~OUTDATED;\n\n    if (this._globalVersion === globalVersion) {\n        return true;\n    }\n    this._globalVersion = globalVersion;\n\n    // Mark this computed signal running before checking the dependencies for value\n    // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n    this._flags |= RUNNING;\n    if (this._version > 0 && !needsToRecompute(this)) {\n        this._flags &= ~RUNNING;\n        return true;\n    }\n\n    const prevContext = evalContext;\n    try {\n        prepareSources(this);\n        evalContext = this;\n        const value = this._fn();\n        if (\n            this._flags & HAS_ERROR ||\n            this._value !== value ||\n            this._version === 0\n        ) {\n            this._value = value;\n            this._flags &= ~HAS_ERROR;\n            this._version++;\n        }\n    } catch (err) {\n        this._value = err;\n        this._flags |= HAS_ERROR;\n        this._version++;\n    }\n    evalContext = prevContext;\n    cleanupSources(this);\n    this._flags &= ~RUNNING;\n    return true;\n};\n\nComputed.prototype._subscribe = function (node) {\n    if (this._targets === undefined) {\n        this._flags |= OUTDATED | TRACKING;\n\n        // A computed signal subscribes lazily to its dependencies when it\n        // gets its first subscriber.\n        for (\n            let node = this._sources;\n            node !== undefined;\n            node = node._nextSource\n        ) {\n            node._source._subscribe(node);\n        }\n    }\n    Signal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n    // Only run the unsubscribe step if the computed signal has any subscribers.\n    if (this._targets !== undefined) {\n        Signal.prototype._unsubscribe.call(this, node);\n\n        // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n        // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n        if (this._targets === undefined) {\n            this._flags &= ~TRACKING;\n\n            for (\n                let node = this._sources;\n                node !== undefined;\n                node = node._nextSource\n            ) {\n                node._source._unsubscribe(node);\n            }\n        }\n    }\n};\n\nComputed.prototype._notify = function () {\n    if (!(this._flags & NOTIFIED)) {\n        this._flags |= OUTDATED | NOTIFIED;\n\n        for (\n            let node = this._targets;\n            node !== undefined;\n            node = node._nextTarget\n        ) {\n            node._target._notify();\n        }\n    }\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n    get(this: Computed) {\n        if (this._flags & RUNNING) {\n            // Cycle detected\n            throw dsErr(ErrorCodes.SignalCycleDetected);\n        }\n        const node = addDependency(this);\n        this._refresh();\n        if (node !== undefined) {\n            node._version = this._version;\n        }\n        if (this._flags & HAS_ERROR) {\n            throw dsErr(ErrorCodes.GetComputedError, { value: this._value });\n        }\n        return this._value;\n    },\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n    readonly value: T;\n    peek(): T;\n\n    subscribe(fn: (value: T) => void): () => void;\n    valueOf(): T;\n    toString(): string;\n    toJSON(): T;\n    brand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n    return new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n    const cleanup = effect._cleanup;\n    effect._cleanup = undefined;\n\n    if (typeof cleanup === \"function\") {\n        /*@__INLINE__**/ startBatch();\n\n        // Run cleanup functions always outside of any context.\n        const prevContext = evalContext;\n        evalContext = undefined;\n        try {\n            cleanup!();\n        } catch (error) {\n            effect._flags &= ~RUNNING;\n            effect._flags |= DISPOSED;\n            disposeEffect(effect);\n            throw dsErr(ErrorCodes.CleanupEffectError, { error });\n        } finally {\n            evalContext = prevContext;\n            endBatch();\n        }\n    }\n}\n\nfunction disposeEffect(effect: Effect) {\n    for (\n        let node = effect._sources;\n        node !== undefined;\n        node = node._nextSource\n    ) {\n        node._source._unsubscribe(node);\n    }\n    effect._fn = undefined;\n    effect._sources = undefined;\n\n    cleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n    if (evalContext !== this) {\n        throw dsErr(ErrorCodes.EndEffectError);\n    }\n    cleanupSources(this);\n    evalContext = prevContext;\n\n    this._flags &= ~RUNNING;\n    if (this._flags & DISPOSED) {\n        disposeEffect(this);\n    }\n    endBatch();\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>;\n\ndeclare class Effect {\n    _fn?: EffectFn;\n    _cleanup?: () => void;\n    _sources?: Node;\n    _nextBatchedEffect?: Effect;\n    _flags: number;\n\n    constructor(fn: EffectFn);\n\n    _callback(): void;\n    _start(): () => void;\n    _notify(): void;\n    _dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n    this._fn = fn;\n    this._cleanup = undefined;\n    this._sources = undefined;\n    this._nextBatchedEffect = undefined;\n    this._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n    const finish = this._start();\n    try {\n        if (this._flags & DISPOSED) return;\n        if (this._fn === undefined) return;\n\n        const cleanup = this._fn();\n        if (typeof cleanup === \"function\") {\n            this._cleanup = cleanup!;\n        }\n    } finally {\n        finish();\n    }\n};\n\nEffect.prototype._start = function () {\n    if (this._flags & RUNNING) {\n        throw dsErr(ErrorCodes.SignalCycleDetected);\n    }\n    this._flags |= RUNNING;\n    this._flags &= ~DISPOSED;\n    cleanupEffect(this);\n    prepareSources(this);\n\n    /*@__INLINE__**/ startBatch();\n    const prevContext = evalContext;\n    evalContext = this;\n    return endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n    if (!(this._flags & NOTIFIED)) {\n        this._flags |= NOTIFIED;\n        this._nextBatchedEffect = batchedEffect;\n        batchedEffect = this;\n    }\n};\n\nEffect.prototype._dispose = function () {\n    this._flags |= DISPOSED;\n\n    if (!(this._flags & RUNNING)) {\n        disposeEffect(this);\n    }\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n    const effect = new Effect(fn);\n    try {\n        effect._callback();\n    } catch (error) {\n        effect._dispose();\n        throw dsErr(ErrorCodes.EffectError, { error });\n    }\n    // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n    // because bound functions seem to be just as fast and take up a lot less memory.\n    return effect._dispose.bind(effect);\n}\n\nexport { batch, computed, effect, Signal, untracked };\nexport type { ReadonlySignal };\n", "import { Computed, computed, Signal } from \"../vendored/preact-core\";\nimport { NestedSignal, NestedValues } from \"./types\";\n\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n    signal: NestedSignal,\n    onlyPublic = false,\n): Record<string, any> {\n    const kv: Record<string, any> = {};\n    for (const key in signal) {\n        if (signal.hasOwnProperty(key)) {\n            const value = signal[key];\n            if (value instanceof Signal) {\n                if (onlyPublic && key.startsWith(\"_\")) {\n                    continue;\n                }\n                kv[key] = value.value;\n            } else {\n                kv[key] = nestedValues(value);\n            }\n        }\n    }\n    return kv;\n}\n\nfunction mergeNested(\n    target: NestedValues,\n    values: NestedValues,\n    onlyIfMissing = false,\n): void {\n    for (const key in values) {\n        if (values.hasOwnProperty(key)) {\n            const value = values[key];\n            if (value instanceof Object && !Array.isArray(value)) {\n                if (!target[key]) {\n                    target[key] = {};\n                }\n                mergeNested(\n                    target[key] as NestedValues,\n                    value as NestedValues,\n                    onlyIfMissing,\n                );\n            } else {\n                if (onlyIfMissing && target[key]) {\n                    continue;\n                }\n                target[key] = new Signal(value);\n            }\n        }\n    }\n}\n\nfunction walkNestedSignal(\n    signal: NestedSignal,\n    cb: (dotDeliminatedB: string, signal: Signal<any>) => void,\n): void {\n    for (const key in signal) {\n        if (signal.hasOwnProperty(key)) {\n            const value = signal[key];\n            if (value instanceof Signal) {\n                cb(key, value);\n            } else {\n                walkNestedSignal(value as NestedSignal, cb);\n            }\n        }\n    }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n    const subset: NestedValues = {};\n    for (const key of keys) {\n        const parts = key.split(\".\");\n        let subOriginal = original;\n        let subSubset = subset;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subOriginal[part]) {\n                return {};\n            }\n            if (!subSubset[part]) {\n                subSubset[part] = {};\n            }\n            subOriginal = subOriginal[part] as NestedValues;\n            subSubset = subSubset[part] as NestedValues;\n        }\n        const last = parts[parts.length - 1];\n        subSubset[last] = subOriginal[last];\n    }\n    return subset;\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n    nv: NestedValues,\n    cb: (path: string, value: any) => void,\n) {\n    for (const key in nv) {\n        if (nv.hasOwnProperty(key)) {\n            const value = nv[key];\n            if (value instanceof Object && !Array.isArray(value)) {\n                walkNestedValues(value, (path, value) => {\n                    cb(`${key}.${path}`, value);\n                });\n            } else {\n                cb(key, value);\n            }\n        }\n    }\n}\n\nexport class SignalsRoot {\n    private _signals: NestedSignal = {};\n\n    constructor() {}\n\n    exists(dotDelimitedPath: string): boolean {\n        return !!this.signal(dotDelimitedPath);\n    }\n\n    signal(dotDelimitedPath: string): Signal<any> | null {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                return null;\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n        return subSignals[last] as Signal<any>;\n    }\n\n    setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                subSignals[part] = {};\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n        subSignals[last] = signal;\n    }\n\n    setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n        const signal = computed(() => fn()) as Computed;\n        this.setSignal(dotDelimitedPath, signal);\n    }\n\n    value<T>(dotDelimitedPath: string): T {\n        const signal = this.signal(dotDelimitedPath);\n        return signal?.value;\n    }\n\n    setValue<T>(dotDelimitedPath: string, value: T) {\n        const s = this.upsert(dotDelimitedPath, value);\n        s.value = value;\n    }\n\n    upsert<T>(dotDelimitedPath: string, value: T) {\n        const parts = dotDelimitedPath.split(\".\");\n        let subSignals = this._signals;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subSignals[part]) {\n                subSignals[part] = {};\n            }\n            subSignals = subSignals[part] as NestedSignal;\n        }\n        const last = parts[parts.length - 1];\n\n        const current = subSignals[last];\n        if (!!current) return current as Signal<T>;\n\n        const signal = new Signal(value);\n        subSignals[last] = signal;\n\n        return signal;\n    }\n\n    remove(...dotDelimitedPaths: string[]) {\n        for (const path of dotDelimitedPaths) {\n            const parts = path.split(\".\");\n            let subSignals = this._signals;\n            for (let i = 0; i < parts.length - 1; i++) {\n                const part = parts[i];\n                if (!subSignals[part]) {\n                    return;\n                }\n                subSignals = subSignals[part] as NestedSignal;\n            }\n            const last = parts[parts.length - 1];\n            delete subSignals[last];\n        }\n    }\n\n    merge(other: NestedValues, onlyIfMissing = false) {\n        mergeNested(this._signals, other, onlyIfMissing);\n    }\n\n    subset(...keys: string[]): NestedValues {\n        return nestedSubset(this.values(), ...keys);\n    }\n\n    walk(cb: (name: string, signal: Signal<any>) => void) {\n        walkNestedSignal(this._signals, cb);\n    }\n\n    values(onlyPublic = false): NestedValues {\n        return nestedValues(this._signals, onlyPublic);\n    }\n\n    JSON(shouldIndent = true, onlyPublic = false) {\n        const values = this.values(onlyPublic);\n        if (!shouldIndent) {\n            return JSON.stringify(values);\n        }\n        return JSON.stringify(values, null, 2);\n    }\n\n    public toString() {\n        return this.JSON();\n    }\n}\n", "import { elUniqId } from \"../utils/dom\";\nimport { effect } from \"../vendored/preact-core\";\nimport { VERSION } from \"./consts\";\nimport { dsErr, ErrorCodes } from \"./errors\";\nimport { SignalsRoot } from \"./nestedSignals\";\nimport {\n    ActionPlugin,\n    ActionPlugins,\n    AttributePlugin,\n    DatastarPlugin,\n    GlobalInitializer,\n    HTMLorSVGElement,\n    MacroPlugin,\n    Modifiers,\n    OnRemovalFn,\n    PluginType,\n    RemovalEntry,\n    RuntimeContext,\n    RuntimeExpressionFunction,\n    WatcherPlugin,\n} from \"./types\";\n\nexport class Engine {\n    private _signals = new SignalsRoot();\n    private plugins: AttributePlugin[] = [];\n    private macros: MacroPlugin[] = [];\n    private actions: ActionPlugins = {};\n    private watchers: WatcherPlugin[] = [];\n    private removals = new Map<Element, RemovalEntry>();\n\n    get version() {\n        return VERSION;\n    }\n\n    public load(...pluginsToLoad: DatastarPlugin[]) {\n        pluginsToLoad.forEach((plugin) => {\n            let globalInitializer: GlobalInitializer | undefined;\n            switch (plugin.type) {\n                case PluginType.Macro:\n                    this.macros.push(plugin as MacroPlugin);\n                    break;\n                case PluginType.Watcher:\n                    const wp = plugin as WatcherPlugin;\n                    this.watchers.push(wp);\n                    globalInitializer = wp.onGlobalInit;\n                    break;\n                case PluginType.Action:\n                    this.actions[plugin.name] = plugin as ActionPlugin;\n                    break;\n                case PluginType.Attribute:\n                    const ap = plugin as AttributePlugin;\n                    this.plugins.push(ap);\n                    globalInitializer = ap.onGlobalInit;\n                    break;\n                default:\n                    throw dsErr(ErrorCodes.InvalidPluginType, {\n                        name: plugin.name,\n                        type: plugin.type,\n                    });\n            }\n            if (globalInitializer) {\n                const that = this; // I hate javascript\n                globalInitializer({\n                    get signals() {\n                        return that._signals;\n                    },\n                    effect: (cb: () => void): OnRemovalFn => effect(cb),\n                    actions: this.actions,\n                    apply: this.apply.bind(this),\n                    cleanup: this.cleanup.bind(this),\n                });\n            }\n        });\n        this.apply(document.body);\n    }\n\n    private cleanup(element: Element) {\n        const removalSet = this.removals.get(element);\n        if (removalSet) {\n            for (const removal of removalSet.set) {\n                removal();\n            }\n            this.removals.delete(element);\n        }\n    }\n\n    private apply(rootElement: Element) {\n        const appliedMacros = new Set<MacroPlugin>();\n        this.plugins.forEach((p, pi) => {\n            this.walkDownDOM(rootElement, (el) => {\n                if (!pi) this.cleanup(el);\n\n                for (const rawKey in el.dataset) {\n                    const rawValue = `${el.dataset[rawKey]}` || \"\";\n                    let value = rawValue;\n\n                    if (!rawKey.startsWith(p.name)) continue;\n                    if (!el.id.length) el.id = elUniqId(el);\n\n                    appliedMacros.clear();\n                    const keyRaw = rawKey.slice(p.name.length);\n                    let [key, ...modifiersWithArgsArr] = keyRaw.split(\".\");\n                    if (key.length) {\n                        key = key[0].toLowerCase() + key.slice(1);\n                    }\n                    const mods: Modifiers = new Map<string, Set<string>>();\n                    modifiersWithArgsArr.forEach((m) => {\n                        const [label, ...args] = m.split(\"_\");\n                        mods.set(label, new Set(args));\n                    });\n\n                    const macros = [\n                        ...(p.macros?.pre || []),\n                        ...this.macros,\n                        ...(p.macros?.post || []),\n                    ];\n                    for (const macro of macros) {\n                        if (appliedMacros.has(macro)) continue;\n                        appliedMacros.add(macro);\n                        value = macro.fn(value);\n                    }\n\n                    const { actions, apply, cleanup } = this;\n                    const that = this; // I hate javascript\n                    let ctx: RuntimeContext;\n                    ctx = {\n                        get signals() {\n                            return that._signals;\n                        },\n                        effect: (cb: () => void): OnRemovalFn => effect(cb),\n                        apply: apply.bind(this),\n                        cleanup: cleanup.bind(this),\n                        actions,\n                        genRX: () => this.genRX(ctx, ...p.argNames || []),\n                        el,\n                        rawKey,\n                        rawValue,\n                        key,\n                        value,\n                        mods,\n                    };\n\n                    const removal = p.onLoad(ctx);\n                    if (removal) {\n                        if (!this.removals.has(el)) {\n                            this.removals.set(el, {\n                                id: el.id,\n                                set: new Set(),\n                            });\n                        }\n                        this.removals.get(el)!.set.add(removal);\n                    }\n\n                    if (!!p?.purge) delete el.dataset[rawKey];\n                }\n            });\n        });\n    }\n\n    private genRX(\n        ctx: RuntimeContext,\n        ...argNames: string[]\n    ): RuntimeExpressionFunction {\n        const stmts = ctx.value.split(/;|\\n/).map((s) => s.trim()).filter((s) =>\n            s != \"\"\n        );\n        const lastIdx = stmts.length - 1;\n        const last = stmts[lastIdx];\n        if (!last.startsWith(\"return\")) {\n            stmts[lastIdx] = `return ${stmts[lastIdx]};`;\n        }\n        const userExpression = stmts.join(\"\\n\");\n\n        const fnCall = /(\\w*)\\(/gm;\n        const matches = userExpression.matchAll(fnCall);\n        const methodsCalled = new Set<string>();\n        for (const match of matches) {\n            methodsCalled.add(match[1]);\n        }\n        // Action names\n        const an = Object.keys(this.actions).filter((i) =>\n            methodsCalled.has(i)\n        );\n        // Action lines\n        const al = an.map((a) => `const ${a} = ctx.actions.${a}.fn;`);\n        const fnContent = `${al.join(\"\\n\")}\\n${userExpression}`;\n\n        // Add ctx to action calls\n        let fnWithCtx = fnContent.trim();\n        an.forEach((a) => {\n            fnWithCtx = fnWithCtx.replaceAll(a + \"(\", a + \"(ctx,\");\n        });\n\n        try {\n            const argumentNames = argNames || [];\n            const fn = new Function(\"ctx\", ...argumentNames, fnWithCtx);\n            return (...args: any[]) => fn(ctx, ...args);\n        } catch (error) {\n            throw dsErr(ErrorCodes.GeneratingExpressionFailed, {\n                error,\n                fnContent,\n            });\n        }\n    }\n\n    private walkDownDOM(\n        element: Element | null,\n        callback: (el: HTMLorSVGElement) => void,\n    ) {\n        if (\n            !element ||\n            !(element instanceof HTMLElement || element instanceof SVGElement)\n        ) return null;\n        callback(element);\n        element = element.firstElementChild;\n        while (element) {\n            this.walkDownDOM(element, callback);\n            element = element.nextElementSibling;\n        }\n    }\n}\n", "import { Computed } from \"../plugins/official/core/attributes/computed\";\nimport { Signals } from \"../plugins/official/core/attributes/signals\";\nimport { Star } from \"../plugins/official/core/attributes/star\";\nimport { SignalValueMacro } from \"../plugins/official/core/macros/signals\";\nimport { Engine } from \"./engine\";\n\nconst ds = new Engine();\nds.load(\n    Star,\n    SignalValueMacro,\n    Signals,\n    Computed,\n);\nexport const Datastar = ds;\n", "import { dsErr } from \"../engine/errors\";\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n    /** The event ID to set the EventSource object's last event ID value. */\n    id: string;\n    /** A string identifying the type of event described. */\n    event: string;\n    /** The event data */\n    data: string;\n    /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n    retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n    stream: ReadableStream<Uint8Array>,\n    onChunk: (arr: Uint8Array) => void,\n) {\n    const reader = stream.getReader();\n    let result: ReadableStreamReadResult<Uint8Array>;\n    while (!(result = await reader.read()).done) {\n        onChunk(result.value);\n    }\n}\n\nconst enum ControlChars {\n    NewLine = 10,\n    CarriageReturn = 13,\n    Space = 32,\n    Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n    onLine: (line: Uint8Array, fieldLength: number) => void,\n) {\n    let buffer: Uint8Array | undefined;\n    let position: number; // current read position\n    let fieldLength: number; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr: Uint8Array) {\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        } else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === ControlChars.NewLine) {\n                    lineStart = ++position; // skip to next char\n                }\n\n                discardTrailingNewline = false;\n            }\n\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case ControlChars.Colon:\n                        if (fieldLength === -1) { // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case ControlChars.CarriageReturn:\n                        discardTrailingNewline = true;\n                    case ControlChars.NewLine:\n                        lineEnd = position;\n                        break;\n                }\n            }\n\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        } else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n    onId: (id: string) => void,\n    onRetry: (retry: number) => void,\n    onMessage?: (msg: EventSourceMessage) => void,\n) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n\n    // return a function that can process each incoming line buffer:\n    return function onLine(line: Uint8Array, fieldLength: number) {\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        } else if (fieldLength > 0) { // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength +\n                (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data\n                        ? message.data + \"\\n\" + value\n                        : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId(message.id = value);\n                    break;\n                case \"retry\":\n                    const retry = parseInt(value, 10);\n                    if (!isNaN(retry)) { // per spec, ignore non-integers\n                        onRetry(message.retry = retry);\n                    }\n                    break;\n            }\n        }\n    };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\n\nexport const EventStreamContentType = \"text/event-stream\";\n\nconst DefaultRetryInterval = 1000;\nconst LastEventId = \"last-event-id\";\n\nexport interface FetchEventSourceInit extends RequestInit {\n    /**\n     * The request headers. FetchEventSource only supports the Record<string,string> format.\n     */\n    headers?: Record<string, string>;\n\n    /**\n     * Called when a response is received. Use this to validate that the response\n     * actually matches what you expect (and throw if it doesn't.) If not provided,\n     * will default to a basic validation to ensure the content-type is text/event-stream.\n     */\n    onopen?: (response: Response) => Promise<void>;\n\n    /**\n     * Called when a message is received. NOTE: Unlike the default browser\n     * EventSource.onmessage, this callback is called for _all_ events,\n     * even ones with a custom `event` field.\n     */\n    onmessage?: (ev: EventSourceMessage) => void;\n\n    /**\n     * Called when a response finishes. If you don't expect the server to kill\n     * the connection, you can throw an exception here and retry using onerror.\n     */\n    onclose?: () => void;\n\n    /**\n     * Called when there is any error making the request / processing messages /\n     * handling callbacks etc. Use this to control the retry strategy: if the\n     * error is fatal, rethrow the error inside the callback to stop the entire\n     * operation. Otherwise, you can return an interval (in milliseconds) after\n     * which the request will automatically retry (with the last-event-id).\n     * If this callback is not specified, or it returns undefined, fetchEventSource\n     * will treat every error as retriable and will try again after 1 second.\n     */\n    onerror?: (err: any) => number | null | undefined | void;\n\n    /**\n     * If true, will keep the request open even if the document is hidden.\n     * By default, fetchEventSource will close the request and reopen it\n     * automatically when the document becomes visible again.\n     */\n    openWhenHidden?: boolean;\n\n    /** The Fetch function to use. Defaults to window.fetch */\n    fetch?: typeof fetch;\n\n    /** The scaler for the retry interval. Defaults to 2 */\n    retryScaler?: number;\n\n    /** The maximum retry interval in milliseconds. Defaults to 30_000 */\n    retryMaxWaitMs?: number;\n\n    /** The maximum number of retries before giving up. Defaults to 10 */\n    retryMaxCount?: number;\n}\n\nexport function fetchEventSource(input: RequestInfo, {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    ...rest\n}: FetchEventSourceInit) {\n    return new Promise<void>((resolve, reject) => {\n        let retries = 0;\n\n        // make a copy of the input headers since we may modify it below:\n        const headers = { ...inputHeaders };\n        if (!headers.accept) {\n            headers.accept = EventStreamContentType;\n        }\n\n        let curRequestController: AbortController;\n        function onVisibilityChange() {\n            curRequestController.abort(); // close existing request on every visibility change\n            if (!document.hidden) {\n                create(); // page is now visible again, recreate request.\n            }\n        }\n\n        if (!openWhenHidden) {\n            document.addEventListener(\"visibilitychange\", onVisibilityChange);\n        }\n\n        let retryInterval = DefaultRetryInterval;\n        let retryTimer = 0;\n        function dispose() {\n            document.removeEventListener(\n                \"visibilitychange\",\n                onVisibilityChange,\n            );\n            window.clearTimeout(retryTimer);\n            curRequestController.abort();\n        }\n\n        // if the incoming signal aborts, dispose resources and resolve:\n        inputSignal?.addEventListener(\"abort\", () => {\n            dispose();\n            resolve(); // don't waste time constructing/logging errors\n        });\n\n        const fetch = inputFetch ?? window.fetch;\n        const onopen = inputOnOpen ??\n            function defaultOnOpen(\n                // response: Response\n            ) {};\n\n        async function create() {\n            curRequestController = new AbortController();\n            try {\n                const response = await fetch(input, {\n                    ...rest,\n                    headers,\n                    signal: curRequestController.signal,\n                });\n\n                await onopen(response);\n\n                await getBytes(\n                    response.body!,\n                    getLines(getMessages((id) => {\n                        if (id) {\n                            // signals the id and send it back on the next retry:\n                            headers[LastEventId] = id;\n                        } else {\n                            // don't send the last-event-id header anymore:\n                            delete headers[LastEventId];\n                        }\n                    }, (retry) => {\n                        retryInterval = retry;\n                    }, onmessage)),\n                );\n\n                onclose?.();\n                dispose();\n                resolve();\n            } catch (err) {\n                if (!curRequestController.signal.aborted) {\n                    // if we haven't aborted the request ourselves:\n                    try {\n                        // check if we need to retry:\n                        const interval: any = onerror?.(err) ?? retryInterval;\n                        window.clearTimeout(retryTimer);\n                        retryTimer = window.setTimeout(create, interval);\n                        retryInterval *= retryScaler; // exponential backoff\n                        retryInterval = Math.min(retryInterval, retryMaxWaitMs);\n                        retries++;\n                        if (retries >= retryMaxCount) {\n                            // we should not retry anymore:\n                            dispose();\n                            // Max retries hit, check your server or network connection\n                            reject(\n                                dsErr(\"SSE_MAX_RETRIES\", {\n                                    retryInterval,\n                                    retryMaxCount,\n                                    ...rest,\n                                }),\n                            );\n                        } else {\n                            console.error(\n                                `Datastar failed to reach ${rest.method}:${input.toString()} retry in ${interval}ms`,\n                            );\n                        }\n                    } catch (innerErr) {\n                        // we should not retry anymore:\n                        dispose();\n                        reject(innerErr);\n                    }\n                }\n            }\n        }\n\n        create();\n    });\n}\n", "import { DATASTAR } from \"../../../engine/consts\";\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`;\nexport const SETTLING_CLASS = `${DATASTAR}-settling`;\nexport const SWAPPING_CLASS = `${DATASTAR}-swapping`;\nexport const STARTED = \"started\";\nexport const FINISHED = \"finished\";\n\nexport interface DatastarSSEEvent {\n    type: string;\n    argsRaw: Record<string, string>;\n}\n\nexport interface CustomEventMap {\n    \"datastar-sse\": CustomEvent<DatastarSSEEvent>;\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n    this: Document,\n    ev: CustomEventMap[K],\n) => void;\n\ndeclare global {\n    interface Document { //adds definition to Document, but you can do the same with HTMLElement\n        addEventListener<K extends keyof CustomEventMap>(\n            type: K,\n            listener: WatcherFn<K>,\n        ): void;\n        removeEventListener<K extends keyof CustomEventMap>(\n            type: K,\n            listener: WatcherFn<K>,\n        ): void;\n        dispatchEvent<K extends keyof CustomEventMap>(\n            ev: CustomEventMap[K],\n        ): void;\n    }\n}\n\nexport function datastarSSEEventWatcher(\n    // ctx: InitContext,\n    eventType: string,\n    fn: (argsRaw: Record<string, string>) => void,\n) {\n    document.addEventListener(\n        DATASTAR_SSE_EVENT,\n        (event: CustomEvent<DatastarSSEEvent>) => {\n            if (event.detail.type != eventType) return;\n            const { argsRaw } = event.detail;\n            fn(argsRaw);\n        },\n    );\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { DATASTAR, DATASTAR_REQUEST } from \"../../../../engine/consts\";\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { ActionPlugin, PluginType } from \"../../../../engine/types\";\nimport {\n    fetchEventSource,\n    FetchEventSourceInit,\n} from \"../../../../vendored/fetch-event-source\";\nimport {\n    DATASTAR_SSE_EVENT,\n    DatastarSSEEvent,\n    FINISHED,\n    STARTED,\n} from \"../shared\";\n\ntype METHOD = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n\nfunction dispatchSSE(type: string, argsRaw: Record<string, string>) {\n    document.dispatchEvent(\n        new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n            detail: { type, argsRaw },\n        }),\n    );\n}\n\nconst isWrongContent = (err: any) => `${err}`.includes(`text/event-stream`);\n\nexport type SSEArgs = {\n    method: METHOD;\n    headers?: Record<string, string>;\n    onlyRemote?: boolean;\n};\n\nexport const ServerSentEvents: ActionPlugin = {\n    type: PluginType.Action,\n    name: \"sse\",\n    fn: async (\n        ctx,\n        url: string,\n        args: SSEArgs = { method: \"GET\", headers: {}, onlyRemote: true },\n    ) => {\n        const { el: { id: elId }, signals } = ctx;\n        const { headers: userHeaders, onlyRemote } = args;\n        const method = args.method.toUpperCase();\n        try {\n            dispatchSSE(STARTED, { elId });\n            if (!!!url?.length) {\n                throw dsErr(ErrorCodes.NoUrlProvided);\n            }\n\n            const headers = Object.assign({\n                \"Content-Type\": \"application/json\",\n                [DATASTAR_REQUEST]: true,\n            }, userHeaders);\n\n            const req: FetchEventSourceInit = {\n                method,\n                headers,\n                onmessage: (evt) => {\n                    if (!evt.event.startsWith(DATASTAR)) {\n                        return;\n                    }\n                    const type = evt.event;\n                    const argsRawLines: Record<string, string[]> = {};\n\n                    const lines = evt.data.split(\"\\n\");\n                    for (const line of lines) {\n                        const colonIndex = line.indexOf(\" \");\n                        const key = line.slice(0, colonIndex);\n                        let argLines = argsRawLines[key];\n                        if (!argLines) {\n                            argLines = [];\n                            argsRawLines[key] = argLines;\n                        }\n                        const value = line.slice(colonIndex + 1).trim();\n                        argLines.push(value);\n                    }\n\n                    const argsRaw: Record<string, string> = {};\n                    for (const [key, lines] of Object.entries(argsRawLines)) {\n                        argsRaw[key] = lines.join(\"\\n\");\n                    }\n\n                    // if you aren't seeing your event you can debug by using this line in the console\n                    // document.addEventListener(\"datastar-sse\",(e) => console.log(e));\n                    dispatchSSE(type, argsRaw);\n                },\n                onerror: (error) => {\n                    if (isWrongContent(error)) {\n                        // don't retry if the content-type is wrong\n                        throw dsErr(ErrorCodes.InvalidContentType, { url, error });\n                    }\n                    // do nothing and it will retry\n                    if (error) {\n                        console.error(error.message);\n                    }\n                },\n            };\n\n            const urlInstance = new URL(url, window.location.origin);\n            const json = signals.JSON(false, onlyRemote);\n            if (method === \"GET\") {\n                const queryParams = new URLSearchParams(urlInstance.search);\n                queryParams.set(DATASTAR, json);\n                urlInstance.search = queryParams.toString();\n            } else {\n                req.body = json;\n            }\n\n            try {\n                await fetchEventSource(urlInstance.toString(), req);\n            } catch (error) {\n                if (!isWrongContent(error)) {\n                    throw dsErr(ErrorCodes.SseFailed, { method, url, error });\n                }\n                // exit gracefully and do nothing if the content-type is wrong\n                // this can happen if the client is sending a request\n                // where no response is expected, and they haven't\n                // set the content-type to text/event-stream\n            }\n        } finally {\n            dispatchSSE(FINISHED, { elId });\n        }\n    },\n};\n", "// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport { DATASTAR } from \"../../../../engine/consts\";\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\nimport {\n    DATASTAR_SSE_EVENT,\n    DatastarSSEEvent,\n    FINISHED,\n    STARTED,\n} from \"../shared\";\n\nexport const INDICATOR_CLASS = `${DATASTAR}-indicator`;\nexport const INDICATOR_LOADING_CLASS = `${INDICATOR_CLASS}-loading`;\n\nexport const Indicator: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"indicator\",\n    onLoad: ({ value, signals, el, key }) => {\n        if (key.length) {\n            throw dsErr(ErrorCodes.IndicatorKeyNotAllowed);\n        }\n        if (!value.length) {\n            throw dsErr(ErrorCodes.IndicatorValueNotProvided);\n        }\n\n        const signal = signals.upsert(value, false);\n        const watcher = (event: CustomEvent<DatastarSSEEvent>) => {\n            const {\n                type,\n                argsRaw: { elId },\n            } = event.detail;\n            if (elId !== el.id) return;\n            switch (type) {\n                case STARTED:\n                    signal.value = true;\n                    break;\n                case FINISHED:\n                    signal.value = false;\n                    break;\n            }\n        };\n        document.addEventListener(DATASTAR_SSE_EVENT, watcher);\n\n        return () => {\n            document.removeEventListener(DATASTAR_SSE_EVENT, watcher);\n        };\n    },\n};\n", "// Icon: tabler:file-type-js\n// Slug: Execute JavaScript using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n    DefaultExecuteScriptAttributes,\n    DefaultExecuteScriptAutoRemove,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { PluginType, WatcherPlugin } from \"../../../../engine/types\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport { datastarSSEEventWatcher } from \"../shared\";\n\nexport const ExecuteScript: WatcherPlugin = {\n    type: PluginType.Watcher,\n    name: EventTypes.ExecuteScript,\n    onGlobalInit: async () => {\n        datastarSSEEventWatcher(\n            EventTypes.ExecuteScript,\n            ({\n                autoRemove: autoRemoveRaw = `${DefaultExecuteScriptAutoRemove}`,\n                attributes: attributesRaw = DefaultExecuteScriptAttributes,\n                script,\n            }) => {\n                const autoRemove = isBoolString(autoRemoveRaw);\n                if (!script?.length) {\n                    throw dsErr(ErrorCodes.NoScriptProvided);\n                }\n                const scriptEl = document.createElement(\"script\");\n                attributesRaw.split(\"\\n\").forEach((attr) => {\n                    const pivot = attr.indexOf(\" \");\n                    const key = pivot ? attr.slice(0, pivot) : attr;\n                    const value = pivot ? attr.slice(pivot) : \"\";\n                    scriptEl.setAttribute(key.trim(), value.trim());\n                });\n                scriptEl.text = script;\n                document.head.appendChild(scriptEl);\n                if (autoRemove) {\n                    scriptEl.remove();\n                }\n            },\n        );\n    },\n};\n", "export interface DocumentSupportingViewTransitionAPI {\n    startViewTransition(\n        updateCallback: () => Promise<void> | void,\n    ): IViewTransition;\n}\n\nexport interface IViewTransition {\n    finished: Promise<void>;\n    ready: Promise<void>;\n    updateCallbackDone: Promise<void>;\n    skipTransition(): void;\n}\n\nexport const docWithViewTransitionAPI =\n    document as unknown as DocumentSupportingViewTransitionAPI;\nexport const supportsViewTransitions = !!docWithViewTransitionAPI\n    .startViewTransition;\n", "import { FragmentMergeModes } from \"../engine/consts\";\nimport { dsErr, ErrorCodes } from \"../engine/errors\";\n\nconst generatedByIdiomorphId = new WeakSet();\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(\n    oldNode: Document | Element,\n    newContent: string | Element,\n    config = {},\n) {\n    if (oldNode instanceof Document) {\n        oldNode = oldNode.documentElement;\n    }\n\n    let parsedContent: Element;\n    if (typeof newContent === \"string\") {\n        parsedContent = parseContent(newContent) as Element;\n    } else {\n        parsedContent = newContent;\n    }\n\n    const normalizedContent = normalizeContent(parsedContent);\n    const ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n}\n\nfunction morphNormalizedContent(\n    oldNode: Element,\n    normalizedNewContent: Element,\n    ctx: any,\n) {\n    if (ctx.head.block) {\n        const oldHead = oldNode.querySelector(\"head\");\n        const newHead = normalizedNewContent.querySelector(\"head\");\n        if (oldHead && newHead) {\n            const promises = handleHeadElement(newHead, oldHead, ctx);\n            // when head promises resolve, call morph again, ignoring the head tag\n            Promise.all(promises).then(() => {\n                morphNormalizedContent(\n                    oldNode,\n                    normalizedNewContent,\n                    Object.assign(ctx, {\n                        head: {\n                            block: false,\n                            ignore: true,\n                        },\n                    }),\n                );\n            });\n            return;\n        }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n        // innerHTML, so we are only updating the children\n        morphChildren(normalizedNewContent, oldNode, ctx);\n        return oldNode.children;\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n        // otherwise find the best element match in the new content, morph that, and merge its siblings\n        // into either side of the best match\n        const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n        if (!bestMatch) {\n            throw dsErr(ErrorCodes.NoBestMatchFound, {\n                old: oldNode,\n                new: normalizedNewContent,\n            });\n        }\n\n        // stash the siblings that will need to be inserted on either side of the best match\n        const previousSibling = bestMatch?.previousSibling as Element;\n        const nextSibling = bestMatch?.nextSibling as Element;\n\n        // morph it\n        const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n        if (bestMatch) {\n            // if there was a best match, merge the siblings in too and return the\n            // whole bunch\n            return insertSiblings(previousSibling, morphedNode, nextSibling);\n        } else {\n            // otherwise nothing was added to the DOM\n            return [];\n        }\n    } else {\n        throw dsErr(ErrorCodes.InvalidMorphStyle, { style: ctx.morphStyle });\n    }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n    } else if (newContent == null) {\n        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return;\n\n        oldNode.remove();\n        ctx.callbacks.afterNodeRemoved(oldNode);\n        return;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return;\n        if (ctx.callbacks.beforeNodeAdded(newContent) === false) return;\n\n        if (!oldNode.parentElement) {\n            throw dsErr(ErrorCodes.NoParentElementFound, { oldNode });\n        }\n        oldNode.parentElement.replaceChild(newContent, oldNode);\n        ctx.callbacks.afterNodeAdded(newContent);\n        ctx.callbacks.afterNodeRemoved(oldNode);\n        return newContent;\n    } else {\n        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n            return;\n        }\n\n        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n            // ignore the head element\n        } else if (\n            newContent instanceof HTMLHeadElement &&\n            oldNode instanceof HTMLHeadElement &&\n            ctx.head.style !== FragmentMergeModes.Morph\n        ) {\n            handleHeadElement(newContent, oldNode, ctx);\n        } else {\n            syncNodeFrom(newContent, oldNode);\n            morphChildren(newContent, oldNode, ctx);\n        }\n        ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n        return oldNode;\n    }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n    let nextNewChild = newParent.firstChild as Element | null;\n    let insertionPoint = oldParent.firstChild as Element | null;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n        newChild = nextNewChild;\n        nextNewChild = newChild.nextSibling as Element | null;\n\n        // if we are at the end of the exiting parent's children, just append\n        if (insertionPoint == null) {\n            if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n            oldParent.appendChild(newChild);\n            ctx.callbacks.afterNodeAdded(newChild);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // if the current node has an id set match then morph\n        if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n            morphOldNodeTo(insertionPoint, newChild, ctx);\n            insertionPoint = insertionPoint.nextSibling as Element | null;\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // otherwise search forward in the existing old children for an id set match\n        let idSetMatch = findIdSetMatch(\n            newParent,\n            oldParent,\n            newChild,\n            insertionPoint,\n            ctx,\n        );\n\n        // if we found a potential match, remove the nodes until that point and morph\n        if (idSetMatch) {\n            insertionPoint = removeNodesBetween(\n                insertionPoint,\n                idSetMatch,\n                ctx,\n            );\n            morphOldNodeTo(idSetMatch, newChild, ctx);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // no id set match found, so scan forward for a soft match for the current node\n        let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx);\n\n        // if we found a soft match for the current node, morph\n        if (softMatch) {\n            insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n            morphOldNodeTo(softMatch, newChild, ctx);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // abandon all hope of morphing, just insert the new child before the insertion point\n        // and move on\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n        removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n        let tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling as Element | null;\n        removeNode(tempNode, ctx);\n    }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n        for (const fromAttribute of from.attributes) {\n            const toAttribute = to.getAttribute(fromAttribute.name);\n            if (toAttribute !== fromAttribute.value) {\n                to.setAttribute(fromAttribute.name, fromAttribute.value);\n            }\n        }\n        for (const toAttribute of to.attributes) {\n            if (!from.hasAttribute(toAttribute.name)) {\n                to.removeAttribute(toAttribute.name);\n            }\n        }\n    }\n\n    // sync text nodes\n    if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n        if (to.nodeValue !== from.nodeValue) {\n            to.nodeValue = from.nodeValue;\n        }\n    }\n\n    // NB: many bothans died to bring us information:\n    //\n    // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n    // sync input value\n    if (\n        from instanceof HTMLInputElement && to instanceof HTMLInputElement &&\n        from.type !== \"file\"\n    ) {\n        to.value = from.value || \"\";\n        syncAttribute(from, to, \"value\");\n\n        // sync boolean attributes\n        syncAttribute(from, to, \"checked\");\n        syncAttribute(from, to, \"disabled\");\n    } else if (from instanceof HTMLOptionElement) {\n        syncAttribute(from, to, \"selected\");\n    } else if (\n        from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement\n    ) {\n        const fromValue = from.value;\n        const toValue = to.value;\n        if (fromValue !== toValue) {\n            to.value = fromValue;\n        }\n        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n            to.firstChild.nodeValue = fromValue;\n        }\n    }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n    const fAttr = from.getAttribute(attributeName);\n    const tAttr = to.getAttribute(attributeName);\n\n    if (fAttr !== tAttr) {\n        if (fAttr) {\n            to.setAttribute(attributeName, fAttr);\n        } else {\n            to.removeAttribute(attributeName);\n        }\n    }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(\n    newHeadTag: HTMLHeadElement,\n    currentHead: HTMLHeadElement,\n    ctx: any,\n) {\n    const added = [];\n    const removed = [];\n    const preserved = [];\n    const nodesToAppend = [];\n\n    const headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    const srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n        // If the current head element is in the map\n        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n        if (inNewContent || isPreserved) {\n            if (isReAppended) {\n                // remove the current version and let the new version replace it and re-execute\n                removed.push(currentHeadElt);\n            } else {\n                // this element already exists and should not be re-appended, so remove it from\n                // the new content map, preserving it in the DOM\n                srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                preserved.push(currentHeadElt);\n            }\n        } else {\n            if (headMergeStyle === FragmentMergeModes.Append) {\n                // we are appending and this existing element is not new content\n                // so if and only if it is marked for re-append do we do anything\n                if (isReAppended) {\n                    removed.push(currentHeadElt);\n                    nodesToAppend.push(currentHeadElt);\n                }\n            } else {\n                // if this is a merge, we remove this content since it is not in the new head\n                if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                    removed.push(currentHeadElt);\n                }\n            }\n        }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    // console.log('to append: ', nodesToAppend)\n\n    const promises = [];\n    for (const newNode of nodesToAppend) {\n        // console.log('adding: ', newNode)\n        const newElt = document.createRange().createContextualFragment(\n            newNode.outerHTML,\n        ).firstChild as Element | null;\n        if (!newElt) {\n            throw dsErr(ErrorCodes.NewElementCouldNotBeCreated, { newNode });\n        }\n        // console.log(newElt)\n        if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n            if (newElt.hasAttribute(\"href\") || newElt.hasAttribute(\"src\")) {\n                let resolver: (value: unknown) => void;\n                const promise = new Promise((resolve) => {\n                    resolver = resolve;\n                });\n                newElt.addEventListener(\"load\", function () {\n                    resolver(undefined);\n                });\n                promises.push(promise);\n            }\n            currentHead.appendChild(newElt);\n            ctx.callbacks.afterNodeAdded(newElt);\n            added.push(newElt);\n        }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n            currentHead.removeChild(removedElement);\n            ctx.callbacks.afterNodeRemoved(removedElement);\n        }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n        added: added,\n        kept: preserved,\n        removed: removed,\n    });\n    return promises;\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() { }\n\nfunction createMorphContext(\n    oldNode: Element,\n    newContent: Element,\n    config: any,\n) {\n    return {\n        target: oldNode,\n        newContent: newContent,\n        config: config,\n        morphStyle: config.morphStyle,\n        ignoreActive: config.ignoreActive,\n        idMap: createIdMap(oldNode, newContent),\n        deadIds: new Set(),\n        callbacks: Object.assign(\n            {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n            },\n            config.callbacks,\n        ),\n        head: Object.assign(\n            {\n                style: \"merge\",\n                shouldPreserve: (elt: Element) =>\n                    elt.getAttribute(\"im-preserve\") === \"true\",\n                shouldReAppend: (elt: Element) =>\n                    elt.getAttribute(\"im-re-append\") === \"true\",\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            },\n            config.head,\n        ),\n    };\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n    if (!node1 || !node2) return false;\n\n    if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n        if (node1?.id?.length && node1.id === node2.id) return true;\n\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n    }\n    return false;\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n    if (!node1 || !node2) return false;\n\n    return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n}\n\nfunction removeNodesBetween(\n    startInclusive: Element,\n    endExclusive: Element,\n    ctx: any,\n) {\n    while (startInclusive !== endExclusive) {\n        const tempNode = startInclusive;\n        startInclusive = startInclusive?.nextSibling as Element;\n        if (!tempNode) {\n            throw dsErr(ErrorCodes.NoTemporaryNodeFound, { startInclusive, endExclusive });\n        }\n        removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling as Element | null;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(\n    newContent: Element,\n    oldParent: Element,\n    newChild: Element,\n    insertionPoint: Element,\n    ctx: any,\n) {\n    // max id matches we are willing to discard in our search\n    const newChildPotentialIdCount = getIdIntersectionCount(\n        ctx,\n        newChild,\n        oldParent,\n    );\n\n    let potentialMatch: Element | null = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n        potentialMatch = insertionPoint;\n        // if there is a possibility of an id match, scan forward\n        // keep track of the potential id match count we are discarding (the\n        // newChildPotentialIdCount must be greater than this to make it likely\n        // worth it)\n        let otherMatchCount = 0;\n        while (potentialMatch != null) {\n            // If we have an id match, return the current potential match\n            if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                return potentialMatch;\n            }\n\n            // computer the other potential matches of this new content\n            otherMatchCount += getIdIntersectionCount(\n                ctx,\n                potentialMatch,\n                newContent,\n            );\n            if (otherMatchCount > newChildPotentialIdCount) {\n                // if we have more potential id matches in _other_ content, we\n                // do not have a good candidate for an id match, so return null\n                return null;\n            }\n\n            // advanced to the next old content child\n            potentialMatch = potentialMatch.nextSibling as Element | null;\n        }\n    }\n    return potentialMatch;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(\n    newContent: Element,\n    newChild: Element,\n    insertionPoint: Element,\n    ctx: any,\n) {\n    let potentialSoftMatch = insertionPoint as Element | null;\n    let nextSibling = newChild.nextSibling as Element | null;\n\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch && nextSibling) {\n        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n            // the current potential soft match has a potential id set match with the remaining new\n            // content so bail out of looking\n            return null;\n        }\n\n        // if we have a soft match with the current node, return it\n        if (isSoftMatch(newChild, potentialSoftMatch)) {\n            return potentialSoftMatch;\n        }\n\n        if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n            // the next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling as Element | null;\n\n            // If there are two future soft matches, bail to allow the siblings to soft match\n            // so that we don't consume future soft matches for the sake of the current node\n            if (siblingSoftMatchCount >= 2) {\n                return null;\n            }\n        }\n\n        // advanced to the next old content child\n        potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null;\n    }\n\n    return potentialSoftMatch;\n}\n\nconst parser = new DOMParser();\nfunction parseContent(newContent: string) {\n    // remove svgs to avoid false-positive matches on head, etc.\n    const contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n        const content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n            generatedByIdiomorphId.add(content);\n            return content;\n        } else {\n            // otherwise return the html element as the parent container\n            let Element = content.firstChild;\n            if (Element) {\n                generatedByIdiomorphId.add(Element);\n                return Element as Element;\n            } else {\n                return null;\n            }\n        }\n    } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        const responseDoc = parser.parseFromString(\n            `<body><template>${newContent}</template></body>`,\n            \"text/html\",\n        );\n        const content = responseDoc.body.querySelector(\"template\")?.content;\n        if (!content) {\n            throw dsErr(ErrorCodes.NoContentFound, { newContent });\n        }\n        generatedByIdiomorphId.add(content);\n        return content;\n    }\n}\n\nfunction normalizeContent(newContent: Element) {\n    if (newContent == null) {\n        // noinspection UnnecessaryLocalVariableJS\n        const dummyParent = document.createElement(\"div\");\n        return dummyParent;\n    } else if (generatedByIdiomorphId.has(newContent)) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return newContent;\n    } else if (newContent instanceof Node) {\n        // a single node is added as a child to a dummy parent\n        const dummyParent = document.createElement(\"div\");\n        dummyParent.append(newContent);\n        return dummyParent;\n    } else {\n        // all nodes in the array or Element collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n            dummyParent.append(elt);\n        }\n        return dummyParent;\n    }\n}\n\nfunction insertSiblings(\n    previousSibling?: Element,\n    morphedNode?: Element,\n    nextSibling?: Element,\n) {\n    const stack = [];\n    const added = [];\n    while (previousSibling) {\n        stack.push(previousSibling);\n        previousSibling = previousSibling.previousSibling as Element;\n    }\n    while (stack.length > 0) {\n        const node = stack.pop()!;\n        added.push(node); // push added preceding siblings on in order and insert\n        morphedNode?.parentElement?.insertBefore(node, morphedNode);\n    }\n    added.push(morphedNode);\n    while (nextSibling) {\n        stack.push(nextSibling);\n        added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n        nextSibling = nextSibling.nextSibling as Element;\n    }\n    while (stack.length) {\n        morphedNode?.parentElement?.insertBefore(\n            stack.pop()!,\n            morphedNode.nextSibling,\n        );\n    }\n    return added;\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n    let currentElement = newContent.firstChild as Element | null;\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n        let newScore = scoreElement(currentElement, oldNode, ctx);\n        if (newScore > score) {\n            bestElement = currentElement;\n            score = newScore;\n        }\n        currentElement = currentElement.nextSibling as Element | null;\n    }\n    return bestElement;\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n    if (isSoftMatch(node1, node2)) {\n        return 0.5 + getIdIntersectionCount(ctx, node1, node2);\n    }\n    return 0;\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n    removeIdsFromConsideration(ctx, tempNode);\n    if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n    tempNode.remove();\n    ctx.callbacks.afterNodeRemoved(tempNode);\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n    return !ctx.deadIds.has(id);\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n    return ctx.idMap.get(targetNode)?.has(id) || false;\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n    const idSet = ctx.idMap.get(node);\n    if (!idSet) return;\n    for (const id of idSet) {\n        ctx.deadIds.add(id);\n    }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n    const sourceSet = ctx.idMap.get(node1);\n    if (!sourceSet) return 0;\n\n    let matchCount = 0;\n    for (const id of sourceSet) {\n        // a potential match is an id in the source and potentialIdsSet, but\n        // that has not already been merged into the DOM\n        if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n            ++matchCount;\n        }\n    }\n    return matchCount;\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n    const nodeParent = node.parentElement;\n    // find all elements with an id property\n    const idElements = node.querySelectorAll(\"[id]\");\n    for (const elt of idElements) {\n        let current = elt as Element | null;\n        // walk up the parent hierarchy of that element, adding the id\n        // of element to the parent's id set\n        while (current !== nodeParent && !!current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the  map\n            if (idSet == null) {\n                idSet = new Set();\n                idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n            current = current.parentElement;\n        }\n    }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n    const idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n}\n", "// Icon: material-symbols:cloud-download\n// Slug: Merge fragments into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n    DefaultFragmentMergeMode,\n    DefaultFragmentsUseViewTransitions,\n    DefaultSettleDurationMs,\n    EventTypes,\n    FragmentMergeModes,\n} from \"../../../../engine/consts\";\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport {\n    InitContext,\n    PluginType,\n    WatcherPlugin,\n} from \"../../../../engine/types\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport {\n    docWithViewTransitionAPI,\n    supportsViewTransitions,\n} from \"../../../../utils/view-transtions\";\nimport { idiomorph } from \"../../../../vendored/idiomorph\";\nimport {\n    datastarSSEEventWatcher,\n    SETTLING_CLASS,\n    SWAPPING_CLASS,\n} from \"../shared\";\n\nexport const MergeFragments: WatcherPlugin = {\n    type: PluginType.Watcher,\n    name: EventTypes.MergeFragments,\n    onGlobalInit: async (ctx) => {\n        const fragmentContainer = document.createElement(\"template\");\n        datastarSSEEventWatcher(\n            EventTypes.MergeFragments,\n            ({\n                fragments: fragmentsRaw = \"<div></div>\",\n                selector = \"\",\n                mergeMode = DefaultFragmentMergeMode,\n                settleDuration: settleDurationRaw =\n                    `${DefaultSettleDurationMs}`,\n                useViewTransition: useViewTransitionRaw =\n                    `${DefaultFragmentsUseViewTransitions}`,\n            }) => {\n                const settleDuration = parseInt(settleDurationRaw);\n                const useViewTransition = isBoolString(useViewTransitionRaw);\n\n                fragmentContainer.innerHTML = fragmentsRaw.trim();\n                const fragments = [...fragmentContainer.content.children];\n                fragments.forEach((fragment) => {\n                    if (!(fragment instanceof Element)) {\n                        throw dsErr(ErrorCodes.NoFragmentsFound);\n                    }\n\n                    const selectorOrID = selector ||\n                        `#${fragment.getAttribute(\"id\")}`;\n                    const targets = [\n                        ...document.querySelectorAll(selectorOrID) ||\n                            [],\n                    ];\n                    if (!targets.length) {\n                        throw dsErr(ErrorCodes.NoTargetsFound, { selectorOrID });\n                    }\n\n                    if (supportsViewTransitions && useViewTransition) {\n                        docWithViewTransitionAPI.startViewTransition(() =>\n                            applyToTargets(\n                                ctx,\n                                mergeMode,\n                                settleDuration,\n                                fragment,\n                                targets,\n                            )\n                        );\n                    } else {\n                        applyToTargets(\n                            ctx,\n                            mergeMode,\n                            settleDuration,\n                            fragment,\n                            targets,\n                        );\n                    }\n                });\n            },\n        );\n    },\n};\n\nfunction applyToTargets(\n    ctx: InitContext,\n    mergeMode: string,\n    settleDuration: number,\n    fragment: Element,\n    capturedTargets: Element[],\n) {\n    for (const initialTarget of capturedTargets) {\n        initialTarget.classList.add(SWAPPING_CLASS);\n        const originalHTML = initialTarget.outerHTML;\n        let modifiedTarget = initialTarget;\n        switch (mergeMode) {\n            case FragmentMergeModes.Morph:\n                const result = idiomorph(modifiedTarget, fragment, {\n                    callbacks: {\n                        beforeNodeRemoved: (oldNode: Element, _: Element) => {\n                            ctx.cleanup(oldNode);\n                            return true;\n                        },\n                    },\n                });\n                if (!result?.length) {\n                    throw dsErr(ErrorCodes.MorphFailed);\n                }\n                modifiedTarget = result[0] as Element;\n                break;\n            case FragmentMergeModes.Inner:\n                // Replace the contents of the target element with the response\n                modifiedTarget.innerHTML = fragment.innerHTML;\n                break;\n            case FragmentMergeModes.Outer:\n                // Replace the entire target element with the response\n                modifiedTarget.replaceWith(fragment);\n                break;\n            case FragmentMergeModes.Prepend:\n                // Insert the response before the first child of the target element\n                modifiedTarget.prepend(fragment);\n                break;\n            case FragmentMergeModes.Append:\n                // Insert the response after the last child of the target element\n                modifiedTarget.append(fragment);\n                break;\n            case FragmentMergeModes.Before:\n                // Insert the response before the target element\n                modifiedTarget.before(fragment);\n                break;\n            case FragmentMergeModes.After:\n                // Insert the response after the target element\n                modifiedTarget.after(fragment);\n                break;\n            case FragmentMergeModes.UpsertAttributes:\n                // Upsert the attributes of the target element\n                fragment.getAttributeNames().forEach((attrName) => {\n                    const value = fragment.getAttribute(attrName)!;\n                    modifiedTarget.setAttribute(attrName, value);\n                });\n                break;\n            default:\n                throw dsErr(ErrorCodes.InvalidMergeMode, { mergeMode });\n        }\n        ctx.cleanup(modifiedTarget);\n\n        const cl = modifiedTarget.classList;\n        cl.add(SWAPPING_CLASS);\n\n        ctx.apply(document.body);\n\n        setTimeout(() => {\n            initialTarget.classList.remove(SWAPPING_CLASS);\n            cl.remove(SWAPPING_CLASS);\n        }, settleDuration);\n\n        const revisedHTML = modifiedTarget.outerHTML;\n\n        if (originalHTML !== revisedHTML) {\n            cl.add(SETTLING_CLASS);\n            setTimeout(() => {\n                cl.remove(SETTLING_CLASS);\n            }, settleDuration);\n        }\n    }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Merge signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n    DefaultMergeSignalsOnlyIfMissing,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { PluginType, WatcherPlugin } from \"../../../../engine/types\";\nimport { isBoolString, jsStrToObject } from \"../../../../utils/text\";\nimport { datastarSSEEventWatcher } from \"../shared\";\n\nexport const MergeSignals: WatcherPlugin = {\n    type: PluginType.Watcher,\n    name: EventTypes.MergeSignals,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(\n            EventTypes.MergeSignals,\n            ({\n                signals: raw = \"{}\",\n                onlyIfMissing: onlyIfMissingRaw =\n                    `${DefaultMergeSignalsOnlyIfMissing}`,\n            }) => {\n                const { signals } = ctx;\n                const onlyIfMissing = isBoolString(onlyIfMissingRaw);\n                signals.merge(jsStrToObject(raw), onlyIfMissing);\n                ctx.apply(document.body);\n            },\n        );\n    },\n};\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Remove fragments from the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n    DefaultFragmentsUseViewTransitions,\n    DefaultSettleDurationMs,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { PluginType, WatcherPlugin } from \"../../../../engine/types\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport {\n    docWithViewTransitionAPI,\n    supportsViewTransitions,\n} from \"../../../../utils/view-transtions\";\nimport { datastarSSEEventWatcher, SWAPPING_CLASS } from \"../shared\";\n\nexport const RemoveFragments: WatcherPlugin = {\n    type: PluginType.Watcher,\n    name: EventTypes.RemoveFragments,\n    onGlobalInit: async () => {\n        datastarSSEEventWatcher(\n            EventTypes.RemoveFragments,\n            ({\n                selector,\n                settleDuration: settleDurationRaw = `${DefaultSettleDurationMs}`,\n                useViewTransition: useViewTransitionRaw = `${DefaultFragmentsUseViewTransitions}`,\n            }) => {\n                if (!!!selector.length) {\n                    throw dsErr(ErrorCodes.NoSelectorProvided);\n                }\n\n                const settleDuration = parseInt(settleDurationRaw);\n                const useViewTransition = isBoolString(useViewTransitionRaw);\n                const removeTargets = document.querySelectorAll(selector);\n\n                const applyToTargets = () => {\n                    for (const target of removeTargets) {\n                        target.classList.add(SWAPPING_CLASS);\n                    }\n\n                    setTimeout(() => {\n                        for (const target of removeTargets) {\n                            target.remove();\n                        }\n                    }, settleDuration);\n                };\n\n                if (supportsViewTransitions && useViewTransition) {\n                    docWithViewTransitionAPI.startViewTransition(() =>\n                        applyToTargets()\n                    );\n                } else {\n                    applyToTargets();\n                }\n            },\n        );\n    },\n};\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Remove signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { EventTypes } from \"../../../../engine/consts\";\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { PluginType, WatcherPlugin } from \"../../../../engine/types\";\nimport { datastarSSEEventWatcher } from \"../shared\";\n\nexport const RemoveSignals: WatcherPlugin = {\n    type: PluginType.Watcher,\n    name: EventTypes.RemoveSignals,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(\n            EventTypes.RemoveSignals,\n            ({ paths: pathsRaw = \"\" }) => {\n                const paths = pathsRaw.split(\"\\n\").map((p) => p.trim());\n                if (!!!paths?.length) {\n                    throw dsErr(ErrorCodes.NoPathsProvided);\n                }\n                ctx.signals.remove(...paths);\n                ctx.apply(document.body);\n            },\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:clipboard\n// Slug: Copy text to the clipboard\n// Description: This action copies text to the clipboard using the Clipboard API.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { ActionPlugin, PluginType } from \"../../../../engine/types\";\n\nexport const Clipboard: ActionPlugin = {\n    type: PluginType.Action,\n    name: \"clipboard\",\n    fn: (_, text) => {\n        if (!navigator.clipboard) {\n            throw dsErr(ErrorCodes.ClipboardNotAvailable);\n        }\n        navigator.clipboard.writeText(text);\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Run expression when element intersects with viewport\n// Description: An attribute that runs an expression when the element intersects with the viewport.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nconst ONCE = \"once\";\nconst HALF = \"half\";\nconst FULL = \"full\";\n\n// Run expression when element intersects with viewport\nexport const Intersects: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"intersects\",\n    mods: new Set([ONCE, HALF, FULL]),\n    onLoad: ({ el, key, rawKey, mods, genRX }) => {\n        if (key.length) {\n            throw dsErr(ErrorCodes.IntersectsKeyNotAllowed);\n        }\n        \n        const options = { threshold: 0 };\n        if (mods.has(FULL)) options.threshold = 1;\n        else if (mods.has(HALF)) options.threshold = 0.5;\n\n        const rx = genRX();\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    rx();\n                    if (mods.has(ONCE)) {\n                        observer.disconnect();\n                        delete el.dataset[rawKey];\n                    }\n                }\n            });\n        }, options);\n\n        observer.observe(el);\n        return () => observer.disconnect();\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:floppy-variant\n// Slug: Persist data to local storage or session storage\n// Description: This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nconst SESSION = \"session\";\nconst LOCAL = \"local\";\nconst REMOTE = \"remote\";\n\nexport const Persist: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"persist\",\n    mods: new Set([LOCAL, SESSION, REMOTE]),\n    onLoad: () => {\n        throw dsErr(ErrorCodes.NotImplementedError);\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: carbon:url\n// Slug: Replace the current URL with a new URL\n// Description: This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nexport const ReplaceUrl: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"replaceUrl\",\n    onLoad: ({ key, value, effect, genRX }) => {\n        if (key.length) {\n            throw dsErr(ErrorCodes.ReplaceUrlKeyNotAllowed);\n        }\n        if (!value.length) {\n            throw dsErr(ErrorCodes.ReplaceUrlValueNotProvided);\n        }\n        const rx = genRX();\n        return effect(() => {\n            const url = rx<string>();\n            const baseUrl = window.location.href;\n            const fullUrl = new URL(url, baseUrl).toString();\n            window.history.replaceState({}, \"\", fullUrl);\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: hugeicons:mouse-scroll-01\n// Slug: Scroll an element into view\n// Description: This attribute scrolls the element into view.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nconst SMOOTH = \"smooth\";\nconst INSTANT = \"instant\";\nconst AUTO = \"auto\";\nconst HSTART = \"hstart\";\nconst HCENTER = \"hcenter\";\nconst HEND = \"hend\";\nconst HNEAREST = \"hnearest\";\nconst VSTART = \"vstart\";\nconst VCENTER = \"vcenter\";\nconst VEND = \"vend\";\nconst VNEAREST = \"vnearest\";\nconst FOCUS = \"focus\";\n\nconst CENTER = \"center\";\nconst START = \"start\";\nconst END = \"end\";\nconst NEAREST = \"nearest\";\n\n// Scrolls the element into view\nexport const ScrollIntoView: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"scrollIntoView\",\n    mods: new Set([\n        SMOOTH,\n        INSTANT,\n        AUTO,\n        HSTART,\n        HCENTER,\n        HEND,\n        HNEAREST,\n        VSTART,\n        VCENTER,\n        VEND,\n        VNEAREST,\n        FOCUS,\n    ]),\n\n    onLoad: ({ el, mods, key, value, rawKey }) => {\n        if (key.length) {\n            throw dsErr(ErrorCodes.ScrollIntoViewKeyNotAllowed);\n        }\n        if (value.length) {\n            throw dsErr(ErrorCodes.ScrollIntoViewValueNotAllowed);\n        }\n\n        if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n        const opts: ScrollIntoViewOptions = {\n            behavior: SMOOTH,\n            block: CENTER,\n            inline: CENTER,\n        };\n        if (mods.has(SMOOTH)) opts.behavior = SMOOTH;\n        if (mods.has(INSTANT)) opts.behavior = INSTANT;\n        if (mods.has(AUTO)) opts.behavior = AUTO;\n        if (mods.has(HSTART)) opts.inline = START;\n        if (mods.has(HCENTER)) opts.inline = CENTER;\n        if (mods.has(HEND)) opts.inline = END;\n        if (mods.has(HNEAREST)) opts.inline = NEAREST;\n        if (mods.has(VSTART)) opts.block = START;\n        if (mods.has(VCENTER)) opts.block = CENTER;\n        if (mods.has(VEND)) opts.block = END;\n        if (mods.has(VNEAREST)) opts.block = NEAREST;\n\n        if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n            throw dsErr(ErrorCodes.NotHtmlSvgElement, el);\n        }\n        if (!el.tabIndex) {\n            el.setAttribute(\"tabindex\", \"0\");\n        }\n\n        el.scrollIntoView(opts);\n        if (mods.has(\"focus\")) {\n            el.focus();\n        }\n\n        delete el.dataset[rawKey];\n        return () => { };\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nconst NONE = \"none\";\nconst DISPLAY = \"display\";\n\nexport const Show: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"show\",\n    onLoad: (\n        { el: { style: s }, key, value, genRX, effect },\n    ) => {\n        if (key.length) {\n            throw dsErr(ErrorCodes.ShowKeyNotAllowed);\n        }\n        if (!value.length) {\n            throw dsErr(ErrorCodes.ShowValueNotProvided);\n        }\n\n        const rx = genRX();\n        return effect(async () => {\n            const shouldShow = rx<boolean>();\n            if (shouldShow) {\n                if (s.display === NONE) {\n                    s.removeProperty(DISPLAY);\n                }\n            } else {\n                s.setProperty(DISPLAY, NONE);\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:masked-transitions\n// Slug: Setup view transitions\n// Description: This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.\n\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\nimport { supportsViewTransitions } from \"../../../../utils/view-transtions\";\n\nconst VIEW_TRANSITION = \"view-transition\";\n\nexport const ViewTransition: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: VIEW_TRANSITION,\n    onGlobalInit() {\n        let hasViewTransitionMeta = false;\n        document.head.childNodes.forEach((node) => {\n            if (\n                node instanceof HTMLMetaElement && node.name === VIEW_TRANSITION\n            ) {\n                hasViewTransitionMeta = true;\n            }\n        });\n\n        if (!hasViewTransitionMeta) {\n            const meta = document.createElement(\"meta\");\n            meta.name = VIEW_TRANSITION;\n            meta.content = \"same-origin\";\n            document.head.appendChild(meta);\n        }\n    },\n    onLoad: ({ effect, el, genRX }) => {\n        if (!supportsViewTransitions) {\n            console.error(\"Browser does not support view transitions\");\n            return;\n        }\n        const rx = genRX();\n        return effect(() => {\n            const name = rx<string>();\n            if (!name?.length) return;\n            const elVTASTyle = el.style as unknown as CSSStyleDeclaration;\n            elVTASTyle.viewTransitionName = name;\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\nimport { kebabize } from \"../../../../utils/text\";\n\nexport const Attributes: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"attributes\",\n    onLoad: ({ el, genRX, key, effect, signals }) => {\n        const rx = genRX();\n\n        if (key === \"\") {\n            const binds = rx<Record<string, string>>();\n\n            Object.keys(binds).forEach((key) => signals.upsert(key, \"\"));\n\n            return effect(async () => {\n                for (const [attr, path] of Object.entries(binds)) {\n                    const val = signals.signal(path)!.value;\n                    el.setAttribute(attr, val);\n                }\n            });\n        } else {\n            key = kebabize(key);\n            return effect(async () => {\n                const value = rx();\n                let v: string;\n                if (typeof value === \"string\") {\n                    v = value;\n                } else {\n                    v = JSON.stringify(value);\n                }\n                if (!v || v === \"false\" || v === \"null\" || v === \"undefined\") {\n                    el.removeAttribute(key);\n                } else {\n                    el.setAttribute(key, v);\n                }\n            });\n        }\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/;\nconst updateEvents = [\"change\", \"input\", \"keydown\"];\n\nexport const Bind: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"bind\",\n    onLoad: (ctx) => {\n        const { el, value, key, signals, effect } = ctx;\n\n        if (key != \"\") throw dsErr(ErrorCodes.RefKeyNotAllowed); // BEN!\n\n        let setFromSignal = () => {};\n        let el2sig = () => {};\n\n        const signalName = value;\n\n        // I better be tied to a signal\n        if (typeof signalName !== \"string\") {\n            throw dsErr(ErrorCodes.InvalidExpression);\n        }\n\n        const tnl = el.tagName.toLowerCase();\n        let signalDefault: string | boolean | number | File = \"\";\n        const isInput = tnl.includes(\"input\");\n        const type = el.getAttribute(\"type\");\n        const isCheckbox = tnl.includes(\"checkbox\") ||\n            (isInput && type === \"checkbox\");\n        if (isCheckbox) {\n            signalDefault = false;\n        }\n        const isNumber = isInput && type === \"number\";\n        if (isNumber) {\n            signalDefault = 0;\n        }\n        const isSelect = tnl.includes(\"select\");\n        const isRadio = tnl.includes(\"radio\") ||\n            (isInput && type === \"radio\");\n        const isFile = isInput && type === \"file\";\n        if (isFile) {\n            // can't set a default value for a file input, yet\n        }\n        if (isRadio) {\n            const name = el.getAttribute(\"name\");\n            if (!name?.length) {\n                el.setAttribute(\"name\", signalName);\n            }\n        }\n\n        signals.upsert(signalName, signalDefault);\n\n        setFromSignal = () => {\n            const hasValue = \"value\" in el;\n            const v = signals.value(signalName);\n            const vStr = `${v}`;\n            if (isCheckbox || isRadio) {\n                const input = el as HTMLInputElement;\n                if (isCheckbox) {\n                    input.checked = !!v || v === \"true\";\n                } else if (isRadio) {\n                    // evaluate the value as string to handle any type casting\n                    // automatically since the attribute has to be a string anyways\n                    input.checked = vStr === input.value;\n                }\n            } else if (isFile) {\n                // File input reading from a signal is not supported yet\n            } else if (isSelect) {\n                const select = el as HTMLSelectElement;\n                if (select.multiple) {\n                    Array.from(select.options).forEach((opt) => {\n                        if (opt?.disabled) return;\n                        if (Array.isArray(v) || typeof v === \"string\") {\n                            opt.selected = v.includes(opt.value);\n                        } else if (typeof v === \"number\") {\n                            opt.selected = v === Number(opt.value);\n                        } else {\n                            opt.selected = v as boolean;\n                        }\n                    });\n                } else {\n                    select.value = vStr;\n                }\n            } else if (hasValue) {\n                el.value = vStr;\n            } else {\n                el.setAttribute(\"value\", vStr);\n            }\n        };\n\n        el2sig = async () => {\n            if (isFile) {\n                const files = [...((el as HTMLInputElement)?.files || [])],\n                    allContents: string[] = [],\n                    allMimes: string[] = [],\n                    allNames: string[] = [];\n\n                await Promise.all(\n                    files.map((f) => {\n                        return new Promise<void>((resolve) => {\n                            const reader = new FileReader();\n                            reader.onload = () => {\n                                if (typeof reader.result !== \"string\") {\n                                    throw dsErr(\n                                        ErrorCodes.InvalidFileResultType,\n                                        {\n                                            type: typeof reader.result,\n                                        },\n                                    );\n                                }\n                                const match = reader.result.match(\n                                    dataURIRegex,\n                                );\n                                if (!match?.groups) {\n                                    throw dsErr(ErrorCodes.InvalidDataUri, {\n                                        result: reader.result,\n                                    });\n                                }\n                                allContents.push(match.groups.contents);\n                                allMimes.push(match.groups.mime);\n                                allNames.push(f.name);\n                            };\n                            reader.onloadend = () => resolve(void 0);\n                            reader.readAsDataURL(f);\n                        });\n                    }),\n                );\n\n                signals.setValue(signalName, allContents);\n                const mimeName = `${signalName}Mimes`,\n                    nameName = `${signalName}Names`;\n                if (mimeName in signals) {\n                    signals.upsert(mimeName, allMimes);\n                }\n                if (nameName in signals) {\n                    signals.upsert(nameName, allNames);\n                }\n                return;\n            }\n\n            const current = signals.value(signalName);\n            const input = (el as HTMLInputElement) || (el as HTMLElement);\n\n            if (typeof current === \"number\") {\n                const v = Number(\n                    input.value || input.getAttribute(\"value\"),\n                );\n                signals.setValue(signalName, v);\n            } else if (typeof current === \"string\") {\n                const v = input.value || input.getAttribute(\"value\") || \"\";\n                signals.setValue(signalName, v);\n            } else if (typeof current === \"boolean\") {\n                if (isCheckbox) {\n                    const v = input.checked ||\n                        input.getAttribute(\"checked\") === \"true\";\n                    signals.setValue(signalName, v);\n                } else {\n                    const v = Boolean(\n                        input.value || input.getAttribute(\"value\"),\n                    );\n                    signals.setValue(signalName, v);\n                }\n            } else if (typeof current === \"undefined\") {\n            } else if (Array.isArray(current)) {\n                // check if the input is a select element\n                if (isSelect) {\n                    const select = el as HTMLSelectElement;\n                    const selectedOptions = [...select.selectedOptions];\n                    const selectedValues = selectedOptions\n                        .filter((opt) => opt.selected)\n                        .map((opt) => opt.value);\n                    signals.setValue(signalName, selectedValues);\n                } else {\n                    // assume it's a comma-separated string\n                    const v = JSON.stringify(input.value.split(\",\"));\n                    signals.setValue(signalName, v);\n                }\n                console.log(input.value);\n            } else {\n                throw dsErr(ErrorCodes.UnsupportedSignalType, {\n                    current: typeof current,\n                });\n            }\n        };\n\n        updateEvents.forEach((event) => el.addEventListener(event, el2sig));\n        const elSigClean = effect(() => setFromSignal());\n\n        return () => {\n            elSigClean();\n            updateEvents.forEach((event) => {\n                el.removeEventListener(event, el2sig);\n            });\n        };\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\nimport { kebabize } from \"../../../../utils/text\";\n\nexport const Class: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"class\",\n    onLoad: ({ key, el, genRX, effect }) => {\n        const cl = el.classList;\n        const rx = genRX();\n        return effect(() => {\n            if (key === \"\") {\n                const classes: Object = rx<Record<string, boolean>>();\n                for (const [k, v] of Object.entries(classes)) {\n                    const classNames = k.split(\" \");\n                    if (v) {\n                        cl.add(...classNames);\n                    } else {\n                        cl.remove(...classNames);\n                    }\n                }\n            } else {\n                const shouldInclude = rx<boolean>();\n                const cls = kebabize(key);\n                if (shouldInclude) {\n                    cl.add(cls);\n                } else {\n                    cl.remove(cls);\n                }\n            }\n        });\n    },\n};\n", "export function argsMs(args: Set<string>) {\n    if (!args || args.size <= 0) return 0;\n    for (const arg of args) {\n        if (arg.endsWith(\"ms\")) {\n            return Number(arg.replace(\"ms\", \"\"));\n        } else if (arg.endsWith(\"s\")) {\n            return Number(arg.replace(\"s\", \"\")) * 1000;\n        }\n        try {\n            return parseFloat(arg);\n        } catch (e) {}\n    }\n    return 0;\n}\n\nexport function argsHas(\n    args: Set<string>,\n    arg: string,\n    defaultValue = false,\n) {\n    if (!args) return defaultValue;\n    return args.has(arg);\n}\n", "export type TimerHandler = (...args: any[]) => void;\n\nexport function debounce(\n    callback: TimerHandler,\n    wait: number,\n    leading = false,\n    trailing = true,\n): TimerHandler {\n    let timer = -1;\n\n    const resetTimer = () => timer && clearTimeout(timer);\n\n    return function wrapper(...args: any[]) {\n        resetTimer();\n\n        if (leading && !timer) {\n            callback(...args);\n        }\n\n        timer = setTimeout(() => {\n            if (trailing) {\n                callback(...args);\n            }\n            resetTimer();\n        }, wait);\n    };\n}\n\nexport function throttle(\n    callback: TimerHandler,\n    wait: number,\n    leading = true,\n    trailing = false,\n): TimerHandler {\n    let waiting = false;\n\n    return function wrapper(...args: any[]) {\n        if (waiting) return;\n\n        if (leading) {\n            callback(...args);\n        }\n\n        waiting = true;\n        setTimeout(() => {\n            waiting = false;\n            if (trailing) {\n                callback(...args);\n            }\n        }, wait);\n    };\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This action adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\nimport { argsHas, argsMs } from \"../../../../utils/arguments\";\nimport { kebabize } from \"../../../../utils/text\";\nimport { debounce, throttle } from \"../../../../utils/timing\";\n\nconst knownOnModifiers = new Set([\n    \"window\",\n    \"once\",\n    \"passive\",\n    \"capture\",\n    \"debounce\",\n    \"throttle\",\n    \"remote\",\n    \"outside\",\n]);\n\nexport const On: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"on\",\n    argNames: [\"evt\"],\n    onLoad: ({ el, key, genRX, mods, signals, effect }) => {\n        const rx = genRX();\n        let target: Element | Window | Document = el;\n        if (mods.has(\"window\")) target = window;\n\n        let callback = (evt?: Event) => rx(evt);\n\n        const debounceArgs = mods.get(\"debounce\");\n        if (debounceArgs) {\n            const wait = argsMs(debounceArgs);\n            const leading = argsHas(debounceArgs, \"leading\", false);\n            const trailing = !argsHas(debounceArgs, \"noTrail\", false);\n            callback = debounce(callback, wait, leading, trailing);\n        }\n\n        const throttleArgs = mods.get(\"throttle\");\n        if (throttleArgs) {\n            const wait = argsMs(throttleArgs);\n            const leading = !argsHas(throttleArgs, \"noLeading\", false);\n            const trailing = argsHas(throttleArgs, \"trail\", false);\n            callback = throttle(callback, wait, leading, trailing);\n        }\n\n        const evtListOpts: AddEventListenerOptions = {\n            capture: true,\n            passive: false,\n            once: false,\n        };\n        if (!mods.has(\"capture\")) evtListOpts.capture = false;\n        if (mods.has(\"passive\")) evtListOpts.passive = true;\n        if (mods.has(\"once\")) evtListOpts.once = true;\n\n        const unknownModifierKeys = [...mods.keys()].filter(\n            (key) => !knownOnModifiers.has(key),\n        );\n\n        unknownModifierKeys.forEach((attrName) => {\n            const eventValues = mods.get(attrName) || [];\n            const cb = callback;\n            const revisedCallback = () => {\n                const evt = event as any;\n                const attr = evt[attrName];\n                let valid: boolean;\n\n                if (typeof attr === \"function\") {\n                    valid = attr(...eventValues);\n                } else if (typeof attr === \"boolean\") {\n                    valid = attr;\n                } else if (typeof attr === \"string\") {\n                    const lowerAttr = attr.toLowerCase().trim();\n                    const expr = [...eventValues].join(\"\").toLowerCase().trim();\n                    valid = lowerAttr === expr;\n                } else {\n                    throw dsErr(ErrorCodes.InvalidValue, { attrName, key, el });\n                }\n\n                if (valid) {\n                    cb(evt);\n                }\n            };\n            callback = revisedCallback;\n        });\n\n        let lastSignalsMarshalled = \"\";\n        const eventName = kebabize(key).toLowerCase();\n        switch (eventName) {\n            case \"load\":\n                callback();\n                delete el.dataset.onLoad;\n                return () => {};\n\n            case \"raf\":\n                let rafId: number | undefined;\n                const raf = () => {\n                    callback();\n                    rafId = requestAnimationFrame(raf);\n                };\n                rafId = requestAnimationFrame(raf);\n\n                return () => {\n                    if (rafId) cancelAnimationFrame(rafId);\n                };\n\n            case \"signals-change\":\n                return effect(() => {\n                    const onlyRemoteSignals = mods.has(\"remote\");\n                    const current = signals.JSON(false, onlyRemoteSignals);\n                    if (lastSignalsMarshalled !== current) {\n                        lastSignalsMarshalled = current;\n                        callback();\n                    }\n                });\n\n            default:\n                const testOutside = mods.has(\"outside\");\n                if (testOutside) {\n                    target = document;\n                    const cb = callback;\n                    let called = false;\n                    const targetOutsideCallback = (e?: Event) => {\n                        const targetHTML = e?.target as HTMLElement;\n                        if (!targetHTML) return;\n                        const isEl = el.id === targetHTML.id;\n                        if (isEl && called) {\n                            called = false;\n                        }\n                        if (!isEl && !called) {\n                            cb(e);\n                            called = true;\n                        }\n                    };\n                    callback = targetOutsideCallback;\n                }\n\n                target.addEventListener(eventName, callback, evtListOpts);\n                return () => {\n                    // console.log(`Removing event listener for ${eventName} on ${el}`)\n                    target.removeEventListener(eventName, callback);\n                };\n        }\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport { dsErr, ErrorCodes } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"ref\",\n    onLoad: ({ el, key, value, signals }) => {\n        if (key.length) {\n            throw dsErr(ErrorCodes.RefKeyNotAllowed);\n        }\n        if (!value.length) {\n            throw dsErr(ErrorCodes.RefValueNotProvided);\n        }\n\n        signals.upsert(value, el);\n        return () => signals.remove(value);\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { dsErr } from \"../../../../engine/errors\";\nimport { AttributePlugin, PluginType } from \"../../../../engine/types\";\n\nexport const Text: AttributePlugin = {\n    type: PluginType.Attribute,\n    name: \"text\",\n    onLoad: (ctx) => {\n        const { el, genRX, effect } = ctx;\n        const rx = genRX();\n        if (!(el instanceof HTMLElement)) {\n            dsErr(\"Element is not HTMLElement\");\n        }\n        return effect(() => {\n            const res = rx(ctx);\n            el.textContent = `${res}`;\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen-outline\n// Slug: Clamp a value to a new range\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.\n\nimport {\n    ActionPlugin,\n    PluginType,\n    RuntimeContext,\n} from \"../../../../engine/types\";\n\nconst { round, max, min } = Math;\nexport const Fit: ActionPlugin = {\n    type: PluginType.Action,\n    name: \"fit\",\n    fn: (\n        _: RuntimeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n        shouldClamp = false,\n        shouldRound = false,\n    ) => {\n        let fitted = ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) +\n            newMin;\n        if (shouldRound) {\n            fitted = round(fitted);\n        }\n        if (shouldClamp) {\n            fitted = max(newMin, min(newMax, fitted));\n        }\n        return fitted;\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match a regular expression\n\nimport { ActionPlugin, PluginType } from \"../../../../engine/types\";\n\nexport const SetAll: ActionPlugin = {\n    type: PluginType.Action,\n    name: \"setAll\",\n    fn: (ctx, regexp, newValue) => {\n        const re = new RegExp(regexp);\n        ctx.signals.walk(\n            (name, signal) => re.test(name) && (signal.value = newValue),\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match a regular expression\n\nimport { ActionPlugin, PluginType } from \"../../../../engine/types\";\n\nexport const ToggleAll: ActionPlugin = {\n    type: PluginType.Action,\n    name: \"toggleAll\",\n    fn: (ctx, regexp) => {\n        const re = new RegExp(regexp);\n        ctx.signals.walk(\n            (name, signal) => re.test(name) && (signal.value = !signal.value),\n        );\n    },\n};\n", "import { Datastar } from \"../engine\";\nimport { ServerSentEvents as SSE } from \"../plugins/official/backend/actions/sse\";\nimport { Indicator } from \"../plugins/official/backend/attributes/indicator\";\nimport { ExecuteScript } from \"../plugins/official/backend/watchers/executeScript\";\nimport { MergeFragments } from \"../plugins/official/backend/watchers/mergeFragments\";\nimport { MergeSignals } from \"../plugins/official/backend/watchers/mergeSignals\";\nimport { RemoveFragments } from \"../plugins/official/backend/watchers/removeFragments\";\nimport { RemoveSignals } from \"../plugins/official/backend/watchers/removeSignals\";\nimport { Clipboard } from \"../plugins/official/browser/actions/clipboard\";\nimport { Intersects } from \"../plugins/official/browser/attributes/intersects\";\nimport { Persist } from \"../plugins/official/browser/attributes/persist\";\nimport { ReplaceUrl } from \"../plugins/official/browser/attributes/replaceUrl\";\nimport { ScrollIntoView } from \"../plugins/official/browser/attributes/scrollIntoView\";\nimport { Show } from \"../plugins/official/browser/attributes/show\";\nimport { ViewTransition } from \"../plugins/official/browser/attributes/viewTransition\";\nimport { Attributes } from \"../plugins/official/dom/attributes/attributes\";\nimport { Bind } from \"../plugins/official/dom/attributes/bind\";\nimport { Class } from \"../plugins/official/dom/attributes/class\";\nimport { On } from \"../plugins/official/dom/attributes/on\";\nimport { Ref } from \"../plugins/official/dom/attributes/ref\";\nimport { Text } from \"../plugins/official/dom/attributes/text\";\nimport { Fit } from \"../plugins/official/logic/actions/fit\";\nimport { SetAll } from \"../plugins/official/logic/actions/setAll\";\nimport { ToggleAll } from \"../plugins/official/logic/actions/toggleAll\";\n\nDatastar.load(\n    // Plugins that can create signals must be loaded first\n    Attributes,\n    Bind,\n    Indicator,\n    Ref,\n    // DOM\n    Class,\n    On,\n    Show,\n    Text,\n    // Backend\n    SSE,\n    MergeFragments,\n    MergeSignals,\n    RemoveFragments,\n    RemoveSignals,\n    ExecuteScript,\n    // Browser\n    Clipboard,\n    Intersects,\n    Persist,\n    ReplaceUrl,\n    ScrollIntoView,\n    ViewTransition,\n    // Logic\n    Fit,\n    SetAll,\n    ToggleAll,\n);\n"],
  "mappings": "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",
  "names": ["DATASTAR", "DATASTAR_REQUEST", "VERSION", "DefaultExecuteScriptAttributes", "FragmentMergeModes", "DefaultFragmentMergeMode", "EventTypes", "url", "dsErr", "code", "args", "e", "DATASTAR", "fullURL", "url", "name", "Computed", "key", "signals", "genRX", "rx", "dsErr", "isBoolString", "str", "kebabize", "$", "ofs", "jsStrToObject", "raw", "Signals", "ctx", "key", "genRX", "signals", "obj", "jsStrToObject", "Star", "SignalValueMacro", "original", "validJS", "elUniqId", "el", "hash", "hashUpdate", "n", "hashUpdateFromStr", "str", "c", "e", "DATASTAR", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "dsErr", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "dsErr", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "dsErr", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "error", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "walkNestedSignal", "cb", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "dotDelimitedPath", "parts", "subSignals", "i", "part", "last", "signal", "fn", "computed", "value", "s", "current", "Signal", "dotDelimitedPaths", "path", "other", "onlyIfMissing", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "onlyPublic", "nestedValues", "shouldIndent", "values", "Engine", "SignalsRoot", "VERSION", "pluginsToLoad", "plugin", "globalInitializer", "wp", "ap", "dsErr", "that", "cb", "effect", "element", "removalSet", "removal", "rootElement", "appliedMacros", "p", "pi", "el", "rawKey", "rawValue", "value", "elUniqId", "keyRaw", "key", "modifiersWithArgsArr", "mods", "m", "label", "args", "macros", "macro", "actions", "apply", "cleanup", "ctx", "argNames", "stmts", "s", "lastIdx", "userExpression", "fnCall", "matches", "methodsCalled", "match", "an", "i", "fnContent", "a", "fnWithCtx", "argumentNames", "fn", "error", "callback", "ds", "Engine", "Star", "SignalValueMacro", "Signals", "Computed", "Datastar", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "line", "field", "valueOffset", "value", "retry", "a", "b", "res", "EventStreamContentType", "DefaultRetryInterval", "LastEventId", "fetchEventSource", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "openWhenHidden", "inputFetch", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "rest", "resolve", "reject", "retries", "headers", "curRequestController", "onVisibilityChange", "create", "retryInterval", "retryTimer", "dispose", "fetch", "onopen", "response", "getBytes", "id", "err", "interval", "dsErr", "innerErr", "DATASTAR_SSE_EVENT", "DATASTAR", "SETTLING_CLASS", "SWAPPING_CLASS", "STARTED", "FINISHED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "dispatchSSE", "type", "argsRaw", "DATASTAR_SSE_EVENT", "isWrongContent", "err", "ServerSentEvents", "ctx", "url", "args", "elId", "signals", "userHeaders", "onlyRemote", "method", "STARTED", "dsErr", "headers", "DATASTAR_REQUEST", "req", "evt", "DATASTAR", "argsRawLines", "lines", "line", "colonIndex", "key", "argLines", "value", "error", "urlInstance", "json", "queryParams", "fetchEventSource", "FINISHED", "INDICATOR_CLASS", "DATASTAR", "INDICATOR_LOADING_CLASS", "Indicator", "value", "signals", "el", "key", "dsErr", "signal", "watcher", "event", "type", "elId", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "ExecuteScript", "EventTypes", "datastarSSEEventWatcher", "autoRemoveRaw", "attributesRaw", "DefaultExecuteScriptAttributes", "script", "autoRemove", "isBoolString", "dsErr", "scriptEl", "attr", "pivot", "key", "value", "docWithViewTransitionAPI", "supportsViewTransitions", "generatedByIdiomorphId", "idiomorph", "oldNode", "newContent", "config", "parsedContent", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "bestMatch", "findBestNodeMatch", "dsErr", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "insertSiblings", "isSoftMatch", "FragmentMergeModes", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "from", "to", "type", "fromAttribute", "toAttribute", "syncAttribute", "fromValue", "toValue", "attributeName", "fAttr", "tAttr", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "newNode", "newElt", "resolver", "promise", "resolve", "removedElement", "noOp", "createIdMap", "elt", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "parser", "contentWithSvgsRemoved", "content", "Element", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "populateIdMapForNode", "idMap", "nodeParent", "idElements", "current", "oldContent", "MergeFragments", "EventTypes", "ctx", "fragmentContainer", "datastarSSEEventWatcher", "fragmentsRaw", "selector", "mergeMode", "DefaultFragmentMergeMode", "settleDurationRaw", "useViewTransitionRaw", "settleDuration", "useViewTransition", "isBoolString", "fragment", "dsErr", "selectorOrID", "targets", "supportsViewTransitions", "docWithViewTransitionAPI", "applyToTargets", "capturedTargets", "initialTarget", "SWAPPING_CLASS", "originalHTML", "modifiedTarget", "FragmentMergeModes", "result", "idiomorph", "oldNode", "_", "attrName", "value", "cl", "revisedHTML", "SETTLING_CLASS", "MergeSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "signals", "onlyIfMissing", "isBoolString", "jsStrToObject", "RemoveFragments", "EventTypes", "datastarSSEEventWatcher", "selector", "settleDurationRaw", "useViewTransitionRaw", "dsErr", "settleDuration", "useViewTransition", "isBoolString", "removeTargets", "applyToTargets", "target", "SWAPPING_CLASS", "supportsViewTransitions", "docWithViewTransitionAPI", "RemoveSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "pathsRaw", "paths", "p", "dsErr", "Clipboard", "_", "text", "dsErr", "ONCE", "HALF", "FULL", "Intersects", "el", "key", "rawKey", "mods", "genRX", "dsErr", "options", "rx", "observer", "entries", "entry", "SESSION", "LOCAL", "REMOTE", "Persist", "dsErr", "ReplaceUrl", "key", "value", "effect", "genRX", "dsErr", "rx", "url", "baseUrl", "fullUrl", "SMOOTH", "INSTANT", "AUTO", "HSTART", "HCENTER", "HEND", "HNEAREST", "VSTART", "VCENTER", "VEND", "VNEAREST", "FOCUS", "CENTER", "START", "END", "NEAREST", "ScrollIntoView", "el", "mods", "key", "value", "rawKey", "dsErr", "opts", "NONE", "DISPLAY", "Show", "s", "key", "value", "genRX", "effect", "dsErr", "rx", "VIEW_TRANSITION", "ViewTransition", "hasViewTransitionMeta", "node", "meta", "effect", "el", "genRX", "supportsViewTransitions", "rx", "name", "elVTASTyle", "Attributes", "el", "genRX", "key", "effect", "signals", "rx", "binds", "attr", "path", "val", "kebabize", "value", "v", "dataURIRegex", "updateEvents", "Bind", "ctx", "el", "value", "key", "signals", "effect", "dsErr", "setFromSignal", "el2sig", "signalName", "tnl", "signalDefault", "isInput", "type", "isCheckbox", "isSelect", "isRadio", "isFile", "hasValue", "v", "vStr", "input", "select", "opt", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "mimeName", "nameName", "current", "selectedValues", "event", "elSigClean", "Class", "key", "el", "genRX", "effect", "cl", "rx", "classes", "k", "v", "classNames", "shouldInclude", "cls", "kebabize", "argsMs", "args", "arg", "argsHas", "defaultValue", "debounce", "callback", "wait", "leading", "trailing", "timer", "resetTimer", "args", "throttle", "waiting", "knownOnModifiers", "On", "el", "key", "genRX", "mods", "signals", "effect", "rx", "target", "callback", "evt", "debounceArgs", "wait", "argsMs", "leading", "argsHas", "trailing", "debounce", "throttleArgs", "throttle", "evtListOpts", "attrName", "eventValues", "cb", "attr", "valid", "lowerAttr", "expr", "dsErr", "lastSignalsMarshalled", "eventName", "kebabize", "rafId", "raf", "onlyRemoteSignals", "current", "called", "e", "targetHTML", "isEl", "Ref", "el", "key", "value", "signals", "dsErr", "Text", "ctx", "el", "genRX", "effect", "rx", "dsErr", "res", "round", "max", "min", "Fit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "shouldClamp", "shouldRound", "fitted", "SetAll", "ctx", "regexp", "newValue", "re", "name", "signal", "ToggleAll", "ctx", "regexp", "re", "name", "signal", "Datastar", "Attributes", "Bind", "Indicator", "Ref", "Class", "On", "Show", "Text", "ServerSentEvents", "MergeFragments", "MergeSignals", "RemoveFragments", "RemoveSignals", "ExecuteScript", "Clipboard", "Intersects", "Persist", "ReplaceUrl", "ScrollIntoView", "ViewTransition", "Fit", "SetAll", "ToggleAll"]
}
