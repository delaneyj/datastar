{
  "version": 3,
  "sources": ["../code/ts/library/src/plugins/official/attributes/core/star.ts", "../code/ts/library/src/plugins/official/attributes/core/computed.ts", "../code/ts/library/src/utils/signals.ts", "../code/ts/library/src/plugins/official/attributes/core/store.ts", "../code/ts/library/src/engine/consts.ts", "../code/ts/library/src/utils/regex.ts", "../code/ts/library/src/plugins/official/preprocessors/core/actions.ts", "../code/ts/library/src/plugins/official/preprocessors/core/signals.ts", "../code/ts/library/src/engine/errors.ts", "../code/ts/library/src/utils/dom.ts", "../code/ts/library/src/vendored/preact-core.ts", "../code/ts/library/src/vendored/deepsignal.ts", "../code/ts/library/src/vendored/ts-merge-patch.ts", "../code/ts/library/src/engine/version.ts", "../code/ts/library/src/engine/engine.ts", "../code/ts/library/src/engine/index.ts", "../code/ts/library/src/vendored/fetch-event-source/parse.ts", "../code/ts/library/src/vendored/fetch-event-source/fetch.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseShared.ts", "../code/ts/library/src/plugins/official/actions/backend/sseShared.ts", "../code/ts/library/src/plugins/official/actions/backend/sseDelete.ts", "../code/ts/library/src/plugins/official/actions/backend/sseGet.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePatch.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePost.ts", "../code/ts/library/src/plugins/official/actions/backend/ssePut.ts", "../code/ts/library/src/plugins/official/actions/dom/clipboard.ts", "../code/ts/library/src/plugins/official/actions/logic/setAll.ts", "../code/ts/library/src/plugins/official/actions/logic/toggleAll.ts", "../code/ts/library/src/plugins/official/actions/math/clampFit.ts", "../code/ts/library/src/plugins/official/actions/math/clampFitInt.ts", "../code/ts/library/src/plugins/official/actions/math/fit.ts", "../code/ts/library/src/plugins/official/actions/math/fitInt.ts", "../code/ts/library/src/plugins/official/attributes/backend/indicator.ts", "../code/ts/library/src/utils/text.ts", "../code/ts/library/src/plugins/official/attributes/dom/bind.ts", "../code/ts/library/src/plugins/official/attributes/dom/class.ts", "../code/ts/library/src/plugins/official/attributes/dom/model.ts", "../code/ts/library/src/utils/arguments.ts", "../code/ts/library/src/utils/timing.ts", "../code/ts/library/src/plugins/official/attributes/dom/on.ts", "../code/ts/library/src/plugins/official/attributes/dom/ref.ts", "../code/ts/library/src/plugins/official/attributes/dom/text.ts", "../code/ts/library/src/plugins/official/attributes/storage/persist.ts", "../code/ts/library/src/plugins/official/attributes/url/replaceUrl.ts", "../code/ts/library/src/plugins/official/attributes/visibility/intersects.ts", "../code/ts/library/src/plugins/official/attributes/visibility/scrollIntoView.ts", "../code/ts/library/src/plugins/official/attributes/visibility/show.ts", "../code/ts/library/src/utils/view-transitions.ts", "../code/ts/library/src/plugins/official/attributes/visibility/viewTransition.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseExecuteScript.ts", "../code/ts/library/src/vendored/idiomorph.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseMergeFragment.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseMergeSignals.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseRemoveFragments.ts", "../code/ts/library/src/plugins/official/watchers/backend/sseRemoveSignals.ts", "../code/ts/library/src/bundles/datastar.ts"],
  "sourcesContent": ["// Authors: Delaney Gillilan\n// Icon: material-symbols:rocket\n// Slug: Star\n// Description: Sage advice for the weary traveler\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Star: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"star\",\n    onLoad: () => {\n        alert(\"YOU ARE PROBABLY OVERCOMPLICATING IT\");\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: fluent:draw-text-24-filled\n// Slug: Create a computed signal\n// Description: This attribute creates a computed signal that updates when its dependencies change.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Computed: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"computed\",\n    mustNotEmptyKey: true,\n    onLoad: (ctx) => {\n        const store = ctx.store();\n        store[ctx.key] = ctx.reactivity.computed(() => {\n            return ctx.expressionFn(ctx);\n        });\n\n        return () => {\n            const store = ctx.store();\n            delete store[ctx.key];\n        };\n    },\n};\n", "export function remoteSignals(obj: Object): Object {\n    const res: Record<string, any> = {};\n\n    for (const [k, v] of Object.entries(obj)) {\n        if (k.startsWith(\"_\")) {\n            continue;\n        } else if (typeof v === \"object\" && !Array.isArray(v)) {\n            res[k] = remoteSignals(v); // recurse\n        } else {\n            res[k] = v;\n        }\n    }\n\n    return res;\n}\n\nexport function storeFromPossibleContents(\n    currentStore: any,\n    contents: any,\n    hasIfMissing: boolean,\n) {\n    const actual: any = {};\n\n    if (!hasIfMissing) {\n        Object.assign(actual, contents);\n    } else {\n        for (const key in contents) {\n            const currentValue = currentStore[key]?.value;\n            if (currentValue === undefined || currentValue === null) {\n                actual[key] = contents[key];\n            }\n        }\n    }\n\n    return actual;\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:home-storage\n// Slug: Store signals into a singleton per page\n// Description: This action stores signals into a singleton per page. This is useful for storing signals that are used across multiple components.\n\nimport {\n    AttributeContext,\n    AttributePlugin,\n    RegexpGroups,\n} from \"../../../../engine\";\nimport { storeFromPossibleContents } from \"../../../../utils/signals\";\n\n// Setup the global store\nexport const Store: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"store\",\n    removeNewLines: true,\n    preprocessors: {\n        pre: [\n            {\n                pluginType: \"preprocessor\",\n                name: \"store\",\n                regexp: /(?<whole>.+)/g,\n                replacer: (groups: RegexpGroups) => {\n                    const { whole } = groups;\n                    return `Object.assign({...ctx.store()}, ${whole})`;\n                },\n            },\n        ],\n    },\n    allowedModifiers: new Set([\"ifmissing\"]),\n    onLoad: (ctx: AttributeContext) => {\n        const possibleMergeSignals = ctx.expressionFn(ctx);\n        const actualMergeSignals = storeFromPossibleContents(\n            ctx.store(),\n            possibleMergeSignals,\n            ctx.modifiers.has(\"ifmissing\"),\n        );\n        ctx.mergeSignals(actualMergeSignals);\n\n        delete ctx.el.dataset[ctx.rawKey];\n    },\n};\n", "// This is auto-generated by Datastar. DO NOT EDIT.\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"datastar-request\";\nexport const VERSION = \"0.20.0\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during merges. Allows for CSS transitions to complete.\nexport const DefaultSettleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing from the store?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals into the store.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals from the store.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import { DATASTAR } from \"../engine/consts\";\n\nexport const validJSIdentifier = `[a-zA-Z_$]+`;\nexport const validNestedJSIdentifier = validJSIdentifier + `[0-9a-zA-Z_$.]*`;\n\nexport function wholePrefixSuffix(\n    rune: string,\n    prefix: string,\n    suffix: string,\n    nestable = true,\n) {\n    const identifier = nestable ? validNestedJSIdentifier : validJSIdentifier;\n    return new RegExp(\n        `(?<whole>${rune}(?<${prefix}>${identifier})${suffix})`,\n        `g`,\n    );\n}\n\nexport const isDatastarGeneratedID = (el: Element) =>\n    el.id.match(`^${DATASTAR}-`) !== null;\n", "import { PreprocessorPlugin, RegexpGroups } from \"../../../../engine\";\nimport { wholePrefixSuffix } from \"../../../../utils/regex\";\n\n// Replacing $action(args) with ctx.actions.action(ctx, args)\nexport const ActionsProcessor: PreprocessorPlugin = {\n    name: \"action\",\n    pluginType: \"preprocessor\",\n    regexp: wholePrefixSuffix(\n        \"\\\\$\",\n        \"action\",\n        \"(?<call>\\\\((?<args>.*)\\\\))\",\n        false,\n    ),\n    replacer: ({ action, args }: RegexpGroups) => {\n        const withCtx = [`ctx`];\n        if (args) {\n            withCtx.push(...args.split(\",\").map((x) => x.trim()));\n        }\n        const argsJoined = withCtx.join(\",\");\n        return `ctx.actions.${action}.method(${argsJoined})`;\n    },\n};\n", "import { PreprocessorPlugin, RegexpGroups } from \"../../../../engine\";\nimport { wholePrefixSuffix } from \"../../../../utils/regex\";\n\n// Replacing $signal with ctx.store.signal.value`\nexport const SignalsProcessor: PreprocessorPlugin = {\n    name: \"signal\",\n    pluginType: \"preprocessor\",\n    regexp: wholePrefixSuffix(\"\\\\$\", \"signal\", \"(?<method>\\\\([^\\\\)]*\\\\))?\"),\n    replacer: (groups: RegexpGroups) => {\n        const { signal, method } = groups;\n        const prefix = `ctx.store()`;\n        if (!method?.length) {\n            return `${prefix}.${signal}.value`;\n        }\n        const parts = signal.split(\".\");\n        const methodName = parts.pop();\n        const nestedSignal = parts.join(\".\");\n        return `${prefix}.${nestedSignal}.value.${methodName}${method}`;\n    },\n};\n", "import { DATASTAR } from \"./consts\";\n\nconst err = (code: number) => {\n    const e = new Error();\n    e.name = `${DATASTAR}${code}`;\n    return e;\n};\n\nexport const ERR_BAD_ARGS = err(400);\nexport const ERR_ALREADY_EXISTS = err(409);\nexport const ERR_NOT_FOUND = err(404);\nexport const ERR_NOT_ALLOWED = err(403);\nexport const ERR_METHOD_NOT_ALLOWED = err(405);\nexport const ERR_SERVICE_UNAVAILABLE = err(503);\n", "import { ERR_BAD_ARGS, ERR_NOT_FOUND } from \"../engine/errors\";\nimport { HTMLorSVGElement } from \"./types\";\n\nexport function elemToSelector(\n    elm: Element | Window | Document | string | null,\n) {\n    if (!elm) return \"null\";\n    if (typeof elm === \"string\") return elm;\n    if (elm instanceof Window) return \"Window\";\n    if (elm instanceof Document) return \"Document\";\n\n    if (elm.tagName === \"BODY\") return \"BODY\";\n    const names = new Array<string>();\n    while (elm.parentElement && elm.tagName !== \"BODY\") {\n        if (elm.id) {\n            const idAttr = elm.getAttribute(\"id\");\n            if (!idAttr) {\n                // Element has an ID but no ID attribute\n                throw ERR_BAD_ARGS;\n            }\n            names.unshift(\"#\" + idAttr); // getAttribute, because `elm.id` could also return a child element with name \"id\"\n            break; // Because ID should be unique, no more is needed. Remove the break, if you always want a full path.\n        } else {\n            let c = 1,\n                e = elm;\n            for (; e.previousElementSibling; e = e.previousElementSibling, c++);\n            names.unshift(elm.tagName + \":nth-child(\" + c + \")\");\n        }\n        elm = elm.parentElement;\n    }\n    return names.join(\">\");\n}\n\nexport function nodeHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n        return null;\n    }\n    return node;\n}\n\nexport function scrollIntoView(\n    el: HTMLElement | SVGElement,\n    opts: ScrollIntoViewOptions,\n    shouldFocus = true,\n) {\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n        // Element is not an HTMLElement or SVGElement\n        throw ERR_NOT_FOUND;\n    }\n    if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n\n    el.scrollIntoView(opts);\n    if (shouldFocus) el.focus();\n}\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n\nimport { ERR_BAD_ARGS } from \"../engine/errors\";\n\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal;\n  _prevSource?: Node;\n  _nextSource?: Node;\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect;\n  _prevTarget?: Node;\n  _nextTarget?: Node;\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number;\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node;\n};\n\nfunction startBatch() {\n  batchDepth++;\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--;\n    return;\n  }\n\n  let error: unknown;\n  let hasError = false;\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect;\n    batchedEffect = undefined;\n\n    batchIteration++;\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect;\n      effect._nextBatchedEffect = undefined;\n      effect._flags &= ~NOTIFIED;\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback();\n        } catch (err) {\n          if (!hasError) {\n            error = err;\n            hasError = true;\n          }\n        }\n      }\n      effect = next;\n    }\n  }\n  batchIteration = 0;\n  batchDepth--;\n\n  if (hasError) {\n    throw error;\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn();\n  }\n  /*@__INLINE__**/ startBatch();\n  try {\n    return fn();\n  } finally {\n    endBatch();\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return fn();\n  } finally {\n    evalContext = prevContext;\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined;\n  }\n\n  let node = signal._node;\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    };\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node;\n    }\n    evalContext._sources = node;\n    signal._node = node;\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node);\n    }\n    return node;\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0;\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource;\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource;\n      }\n\n      node._prevSource = evalContext._sources;\n      node._nextSource = undefined;\n\n      evalContext._sources!._nextSource = node;\n      evalContext._sources = node;\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node;\n  }\n  return undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown;\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number;\n\n  /** @internal */\n  _node?: Node;\n\n  /** @internal */\n  _targets?: Node;\n\n  constructor(value?: T);\n\n  /** @internal */\n  _refresh(): boolean;\n\n  /** @internal */\n  _subscribe(node: Node): void;\n\n  /** @internal */\n  _unsubscribe(node: Node): void;\n\n  subscribe(fn: (value: T) => void): () => void;\n\n  valueOf(): T;\n\n  toString(): string;\n\n  toJSON(): T;\n\n  peek(): T;\n\n  brand: typeof BRAND_SYMBOL;\n\n  get value(): T;\n  set value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value;\n  this._version = 0;\n  this._node = undefined;\n  this._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n  return true;\n};\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets;\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node;\n    }\n    this._targets = node;\n  }\n};\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget;\n    const next = node._nextTarget;\n    if (prev !== undefined) {\n      prev._nextTarget = next;\n      node._prevTarget = undefined;\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev;\n      node._nextTarget = undefined;\n    }\n    if (node === this._targets) {\n      this._targets = next;\n    }\n  }\n};\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value;\n\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      fn(value);\n    } finally {\n      evalContext = prevContext;\n    }\n  });\n};\n\nSignal.prototype.valueOf = function () {\n  return this.value;\n};\n\nSignal.prototype.toString = function () {\n  return this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n  return this.value;\n};\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext;\n  evalContext = undefined;\n  try {\n    return this.value;\n  } finally {\n    evalContext = prevContext;\n  }\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n  get(this: Signal) {\n    const node = addDependency(this);\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    return this._value;\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        // Cycle detected\n        throw ERR_BAD_ARGS;\n      }\n\n      this._value = value;\n      this._version++;\n      globalVersion++;\n\n      /**@__INLINE__*/ startBatch();\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify();\n        }\n      } finally {\n        endBatch();\n      }\n    }\n  },\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true;\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node;\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode;\n    }\n    node._source._node = node;\n    node._version = -1;\n\n    if (node._nextSource === undefined) {\n      target._sources = node;\n      break;\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources;\n  let head = undefined;\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource;\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node);\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource;\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev;\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node;\n    }\n\n    node._source._node = node._rollbackNode;\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined;\n    }\n\n    node = prev;\n  }\n\n  target._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n  _fn: () => T;\n  _sources?: Node;\n  _globalVersion: number;\n  _flags: number;\n\n  constructor(fn: () => T);\n\n  _notify(): void;\n  get value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined);\n\n  this._fn = fn;\n  this._sources = undefined;\n  this._globalVersion = globalVersion - 1;\n  this._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED;\n\n  if (this._flags & RUNNING) {\n    return false;\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true;\n  }\n  this._flags &= ~OUTDATED;\n\n  if (this._globalVersion === globalVersion) {\n    return true;\n  }\n  this._globalVersion = globalVersion;\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING;\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING;\n    return true;\n  }\n\n  const prevContext = evalContext;\n  try {\n    prepareSources(this);\n    evalContext = this;\n    const value = this._fn();\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value;\n      this._flags &= ~HAS_ERROR;\n      this._version++;\n    }\n  } catch (err) {\n    this._value = err;\n    this._flags |= HAS_ERROR;\n    this._version++;\n  }\n  evalContext = prevContext;\n  cleanupSources(this);\n  this._flags &= ~RUNNING;\n  return true;\n};\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING;\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node);\n    }\n  }\n  Signal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node);\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING;\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node);\n      }\n    }\n  }\n};\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED;\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify();\n    }\n  }\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw ERR_BAD_ARGS;\n    }\n    const node = addDependency(this);\n    this._refresh();\n    if (node !== undefined) {\n      node._version = this._version;\n    }\n    if (this._flags & HAS_ERROR) {\n      throw this._value;\n    }\n    return this._value;\n  },\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T;\n  peek(): T;\n\n  subscribe(fn: (value: T) => void): () => void;\n  valueOf(): T;\n  toString(): string;\n  toJSON(): T;\n  brand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup;\n  effect._cleanup = undefined;\n\n  if (typeof cleanup === \"function\") {\n    /*@__INLINE__**/ startBatch();\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext;\n    evalContext = undefined;\n    try {\n      cleanup!();\n    } catch (err) {\n      effect._flags &= ~RUNNING;\n      effect._flags |= DISPOSED;\n      disposeEffect(effect);\n      throw err;\n    } finally {\n      evalContext = prevContext;\n      endBatch();\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node);\n  }\n  effect._fn = undefined;\n  effect._sources = undefined;\n\n  cleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    // Out-of-order effect\n    throw ERR_BAD_ARGS;\n  }\n  cleanupSources(this);\n  evalContext = prevContext;\n\n  this._flags &= ~RUNNING;\n  if (this._flags & DISPOSED) {\n    disposeEffect(this);\n  }\n  endBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n  _fn?: EffectFn;\n  _cleanup?: () => void;\n  _sources?: Node;\n  _nextBatchedEffect?: Effect;\n  _flags: number;\n\n  constructor(fn: EffectFn);\n\n  _callback(): void;\n  _start(): () => void;\n  _notify(): void;\n  _dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn;\n  this._cleanup = undefined;\n  this._sources = undefined;\n  this._nextBatchedEffect = undefined;\n  this._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start();\n  try {\n    if (this._flags & DISPOSED) return;\n    if (this._fn === undefined) return;\n\n    const cleanup = this._fn();\n    if (typeof cleanup === \"function\") {\n      this._cleanup = cleanup!;\n    }\n  } finally {\n    finish();\n  }\n};\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    // Cycle detected\n    throw ERR_BAD_ARGS;\n  }\n  this._flags |= RUNNING;\n  this._flags &= ~DISPOSED;\n  cleanupEffect(this);\n  prepareSources(this);\n\n  /*@__INLINE__**/ startBatch();\n  const prevContext = evalContext;\n  evalContext = this;\n  return endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED;\n    this._nextBatchedEffect = batchedEffect;\n    batchedEffect = this;\n  }\n};\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED;\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this);\n  }\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn);\n  try {\n    effect._callback();\n  } catch (err) {\n    effect._dispose();\n    throw err;\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect);\n}\n\nexport { batch, computed, effect, Signal, untracked };\nexport type { ReadonlySignal };\n", "// From https://github.com/EthanStandel/deepsignal/blob/main/packages/core/src/core.ts\nimport { ERR_NOT_ALLOWED } from \"../engine/errors\";\nimport { batch, Signal, signal } from \"./preact-core\";\n\nexport type AtomicState =\n  | Array<unknown>\n  | ((...args: unknown[]) => unknown)\n  | string\n  | boolean\n  | number\n  | bigint\n  | symbol\n  | undefined\n  | null;\n\nexport type DeepState = {\n  [key: string]: (() => unknown) | AtomicState | DeepState;\n};\n\nexport type ReadOnlyDeep<T> = {\n  readonly [P in keyof T]: ReadOnlyDeep<T[P]>;\n};\n\nexport interface DeepSignalAccessors<T extends DeepState> {\n  value: ReadOnlyDeep<T>;\n  peek: () => ReadOnlyDeep<T>;\n}\n\nexport type DeepSignalType<T extends DeepState> =\n  & DeepSignalAccessors<T>\n  & {\n    [K in keyof T]: T[K] extends AtomicState ? Signal<T[K]>\n      : T[K] extends DeepState ? DeepSignalType<T[K]>\n      : Signal<T[K]>;\n  };\n\nexport class DeepSignal<T extends DeepState> implements DeepSignalAccessors<T> {\n  get value(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>);\n  }\n\n  set value(payload: ReadOnlyDeep<T>) {\n    batch(() => setValue(this as DeepSignalType<T>, payload));\n  }\n\n  peek(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>, { peek: true });\n  }\n}\n\nexport const deepSignal = <T extends DeepState>(\n  initialValue: T,\n): DeepSignalType<T> =>\n  Object.assign(\n    new DeepSignal(),\n    Object.entries(initialValue).reduce(\n      (acc, [key, value]) => {\n        if ([\"value\", \"peek\"].some((iKey) => iKey === key)) {\n          // console.error(`${key} is a reserved property name`)\n          throw ERR_NOT_ALLOWED;\n        } else if (\n          typeof value !== \"object\" || value === null || Array.isArray(value)\n        ) {\n          acc[key] = signal(value);\n        } else {\n          acc[key] = deepSignal(value);\n        }\n        return acc;\n      },\n      {} as { [key: string]: unknown },\n    ),\n  ) as DeepSignalType<T>;\n\nconst setValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  payload: U,\n): void =>\n  Object.keys(payload).forEach((\n    key: keyof U,\n  ) => (deepSignal[key].value = payload[key]));\n\nconst getValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  { peek = false }: { peek?: boolean } = {},\n): ReadOnlyDeep<U> =>\n  Object.entries(deepSignal).reduce(\n    (acc, [key, value]) => {\n      if (value instanceof Signal) {\n        acc[key] = peek ? value.peek() : value.value;\n      } else if (value instanceof DeepSignal) {\n        acc[key] = getValue(value as DeepSignalType<DeepState>, { peek });\n      }\n      return acc;\n    },\n    {} as { [key: string]: unknown },\n  ) as ReadOnlyDeep<U>;\n", "// From https://github.com/riagominota/ts-merge-patch/blob/main/src/index.ts\n\ntype mpObj<T> = { [k in keyof T | string | number | symbol]: any };\nexport function apply<L, R>(\n  target: mpObj<L>,\n  patchItem: mpObj<R>,\n): Partial<L> & Partial<R>;\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): R;\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): {};\nexport function apply<L, R>(target: mpObj<L>, patchItem: null): null;\nexport function apply<L, R>(target: mpObj<L>, patchItem: string): string;\nexport function apply<L, R>(target: mpObj<L>, patchItem: number): number;\nexport function apply<L, R>(target: mpObj<L>, patchItem: undefined): undefined;\nexport function apply<L, R>(target: mpObj<L>, patchItem: R[]): R[];\n\nexport function apply(target: any, patchItem: any): any {\n  /**\n   * If the patch is anything other than an object,\n   * the result will always be to replace\n   * the entire target with the entire patch.\n   */\n  if (\n    typeof patchItem !== \"object\" || Array.isArray(patchItem) || !patchItem\n  ) {\n    return JSON.parse(JSON.stringify(patchItem)); //return new instance of variable\n  }\n\n  if (\n    typeof patchItem === \"object\" &&\n    patchItem.toJSON !== undefined &&\n    typeof patchItem.toJSON === \"function\"\n  ) {\n    return patchItem.toJSON();\n  }\n  /** Also, it is not possible to\n   * patch part of a target that is not an object,\n   * such as to replace just some of the values in an array.\n   */\n  let targetResult = target;\n  if (typeof target !== \"object\") {\n    //Target is empty/not an object, so basically becomes patch, minus any null valued sections (becomes {} + patch)\n    targetResult = { ...patchItem };\n  }\n\n  Object.keys(patchItem).forEach((k) => {\n    if (!targetResult.hasOwnProperty(k)) targetResult[k] = patchItem[k]; //This ensure the key exists and TS can't throw a wobbly over an undefined key\n    if (patchItem[k] === null) {\n      delete targetResult[k];\n    } else {\n      targetResult[k] = apply(targetResult[k], patchItem[k]);\n    }\n  });\n  return targetResult;\n}\n", "export const VERSION = '0.20.0';\n", "import { nodeHTMLorSVGElement } from \"../utils/dom\";\nimport { HTMLorSVGElement } from \"../utils/types\";\nimport { DeepSignal, deepSignal, DeepState } from \"../vendored/deepsignal\";\nimport { computed, effect, Signal, signal } from \"../vendored/preact-core\";\nimport { apply } from \"../vendored/ts-merge-patch\";\nimport { DATASTAR } from \"./consts\";\n\nimport {\n    ERR_ALREADY_EXISTS,\n    ERR_BAD_ARGS,\n    ERR_METHOD_NOT_ALLOWED,\n    ERR_NOT_ALLOWED,\n    ERR_NOT_FOUND,\n} from \"./errors\";\nimport {\n    ActionPlugin,\n    ActionPlugins,\n    AttribtueExpressionFunction,\n    AttributeContext,\n    AttributePlugin,\n    DatastarPlugin,\n    InitContext,\n    OnRemovalFn,\n    PreprocessorPlugin,\n    Reactivity,\n    WatcherPlugin,\n} from \"./types\";\nimport { VERSION } from \"./version\";\n\nconst isPreprocessorPlugin = (p: DatastarPlugin): p is PreprocessorPlugin =>\n    p.pluginType === \"preprocessor\";\nconst isWatcherPlugin = (p: DatastarPlugin): p is WatcherPlugin =>\n    p.pluginType === \"watcher\";\nconst isAttributePlugin = (p: DatastarPlugin): p is AttributePlugin =>\n    p.pluginType === \"attribute\";\nconst isActionPlugin = (p: DatastarPlugin): p is ActionPlugin =>\n    p.pluginType === \"action\";\n\nexport class Engine {\n    plugins: AttributePlugin[] = [];\n    store: DeepSignal<any> = deepSignal({});\n    preprocessors = new Array<PreprocessorPlugin>();\n    actions: ActionPlugins = {};\n    watchers = new Array<WatcherPlugin>();\n    refs: Record<string, HTMLElement> = {};\n    reactivity: Reactivity = {\n        signal,\n        computed,\n        effect,\n    };\n    parentID = \"\";\n    missingIDNext = 0;\n    removals = new Map<Element, { id: string; set: Set<OnRemovalFn> }>();\n    mergeRemovals = new Array<OnRemovalFn>();\n\n    get version() {\n        return VERSION;\n    }\n\n    load(...pluginsToLoad: DatastarPlugin[]) {\n        const allLoadedPlugins = new Set<DatastarPlugin>(this.plugins);\n\n        pluginsToLoad.forEach((plugin) => {\n            if (plugin.requiredPlugins) {\n                for (\n                    const requiredPluginType of plugin\n                        .requiredPlugins\n                ) {\n                    if (\n                        !allLoadedPlugins.has(requiredPluginType)\n                    ) {\n                        // requires other plugin to be loaded\n                        throw ERR_NOT_ALLOWED;\n                    }\n                }\n            }\n\n            let globalInitializer: ((ctx: InitContext) => void) | undefined;\n            if (isPreprocessorPlugin(plugin)) {\n                if (this.preprocessors.includes(plugin)) {\n                    throw ERR_ALREADY_EXISTS;\n                }\n                this.preprocessors.push(plugin);\n            } else if (isWatcherPlugin(plugin)) {\n                if (this.watchers.includes(plugin)) {\n                    throw ERR_ALREADY_EXISTS;\n                }\n                this.watchers.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else if (isActionPlugin(plugin)) {\n                if (!!this.actions[plugin.name]) {\n                    throw ERR_ALREADY_EXISTS;\n                }\n                this.actions[plugin.name] = plugin;\n            } else if (isAttributePlugin(plugin)) {\n                if (this.plugins.includes(plugin)) {\n                    throw ERR_ALREADY_EXISTS;\n                }\n                this.plugins.push(plugin);\n                globalInitializer = plugin.onGlobalInit;\n            } else {\n                throw ERR_NOT_FOUND;\n            }\n\n            if (globalInitializer) {\n                globalInitializer({\n                    store: () => this.store,\n                    upsertSignal: this.upsertSignal\n                        .bind(this),\n                    mergeSignals: this.mergeSignals.bind(this),\n                    removeSignals: this.removeSignals.bind(this),\n                    actions: this.actions,\n                    reactivity: this.reactivity,\n                    applyPlugins: this.applyPlugins.bind(this),\n                    cleanup: this.cleanup.bind(\n                        this,\n                    ),\n                });\n            }\n\n            allLoadedPlugins.add(plugin);\n        });\n\n        this.applyPlugins(document.body);\n    }\n\n    private cleanup(element: Element) {\n        const removalSet = this.removals.get(element);\n        if (removalSet) {\n            for (const removal of removalSet.set) {\n                removal();\n            }\n            this.removals.delete(element);\n        }\n    }\n\n    lastMarshalledStore = \"\";\n    private mergeSignals<T extends object>(mergeSignals: T) {\n        this.mergeRemovals.forEach((removal) => removal());\n        this.mergeRemovals = this.mergeRemovals.slice(0);\n\n        const revisedStore = apply(this.store.value, mergeSignals) as DeepState;\n        this.store = deepSignal(revisedStore);\n\n        const marshalledStore = JSON.stringify(this.store.value);\n        if (marshalledStore === this.lastMarshalledStore) return;\n    }\n\n    private removeSignals(...keys: string[]) {\n        const revisedStore = { ...this.store.value };\n        let found = false;\n        for (const key of keys) {\n            const parts = key.split(\".\");\n            let currentID = parts[0];\n            let subStore = revisedStore;\n            for (let i = 1; i < parts.length; i++) {\n                const part = parts[i];\n                if (!subStore[currentID]) {\n                    subStore[currentID] = {};\n                }\n                subStore = subStore[currentID];\n                currentID = part;\n            }\n            delete subStore[currentID];\n            found = true;\n        }\n        if (!found) return;\n        this.store = deepSignal(revisedStore);\n        this.applyPlugins(document.body);\n    }\n\n    private upsertSignal<T>(path: string, value: T) {\n        const parts = path.split(\".\");\n        let subStore = this.store as any;\n        for (let i = 0; i < parts.length - 1; i++) {\n            const part = parts[i];\n            if (!subStore[part]) {\n                subStore[part] = {};\n            }\n            subStore = subStore[part];\n        }\n        const last = parts[parts.length - 1];\n\n        const current = subStore[last];\n        if (!!current) return current;\n\n        const signal = this.reactivity.signal(value);\n        subStore[last] = signal;\n\n        return signal;\n    }\n\n    private applyPlugins(rootElement: Element) {\n        const appliedProcessors = new Set<PreprocessorPlugin>();\n\n        this.plugins.forEach((p, pi) => {\n            this.walkDownDOM(rootElement, (el) => {\n                if (!pi) this.cleanup(el);\n\n                for (const rawKey in el.dataset) {\n                    const rawExpression = `${el.dataset[rawKey]}` || \"\";\n                    let expression = rawExpression;\n\n                    if (!rawKey.startsWith(p.name)) continue;\n\n                    if (el.id.length === 0) {\n                        el.id = `${DATASTAR}-${this.parentID}-${this\n                            .missingIDNext++}`;\n                    }\n\n                    appliedProcessors.clear();\n\n                    if (p.allowedTagRegexps) {\n                        const lowerCaseTag = el.tagName.toLowerCase();\n                        const allowed = [...p.allowedTagRegexps].some((r) =>\n                            lowerCaseTag.match(r)\n                        );\n                        if (!allowed) {\n                            throw ERR_NOT_ALLOWED;\n                        }\n                    }\n\n                    let keyRaw = rawKey.slice(p.name.length);\n                    let [key, ...modifiersWithArgsArr] = keyRaw.split(\".\");\n                    if (p.mustHaveEmptyKey && key.length > 0) {\n                        // must have empty key\n                        throw ERR_BAD_ARGS;\n                    }\n                    if (p.mustNotEmptyKey && key.length === 0) {\n                        // must have non-empty key\n                        throw ERR_BAD_ARGS;\n                    }\n                    if (key.length) {\n                        key = key[0].toLowerCase() + key.slice(1);\n                    }\n\n                    const modifiersArr = modifiersWithArgsArr.map((m) => {\n                        const [label, ...args] = m.split(\"_\");\n                        return { label, args };\n                    });\n                    if (p.allowedModifiers) {\n                        for (const modifier of modifiersArr) {\n                            if (!p.allowedModifiers.has(modifier.label)) {\n                                // modifier not allowed\n                                throw ERR_NOT_ALLOWED;\n                            }\n                        }\n                    }\n                    const modifiers = new Map<string, string[]>();\n                    for (const modifier of modifiersArr) {\n                        modifiers.set(modifier.label, modifier.args);\n                    }\n\n                    if (p.mustHaveEmptyExpression && expression.length) {\n                        // must have empty expression\n                        throw ERR_BAD_ARGS;\n                    }\n                    if (p.mustNotEmptyExpression && !expression.length) {\n                        // must have non-empty expression\n                        throw ERR_BAD_ARGS;\n                    }\n\n                    const splitRegex = /;|\\n/;\n\n                    if (p.removeNewLines) {\n                        expression = expression\n                            .split(\"\\n\")\n                            .map((p: string) => p.trim())\n                            .join(\" \");\n                    }\n\n                    const processors = [\n                        ...(p.preprocessors?.pre || []),\n                        ...this.preprocessors,\n                        ...(p.preprocessors?.post || []),\n                    ];\n                    for (const processor of processors) {\n                        if (appliedProcessors.has(processor)) continue;\n                        appliedProcessors.add(processor);\n\n                        const expressionParts = expression.split(splitRegex);\n                        const revisedParts: string[] = [];\n\n                        expressionParts.forEach((exp) => {\n                            let revised = exp;\n                            const matches = [\n                                ...revised.matchAll(processor.regexp),\n                            ];\n                            if (matches.length) {\n                                for (const match of matches) {\n                                    if (!match.groups) continue;\n                                    const { groups } = match;\n                                    const { whole } = groups;\n                                    revised = revised.replace(\n                                        whole,\n                                        processor.replacer(groups),\n                                    );\n                                }\n                            }\n                            revisedParts.push(revised);\n                        });\n                        // })\n\n                        expression = revisedParts.join(\"; \");\n                    }\n\n                    const ctx: AttributeContext = {\n                        store: () => this.store,\n                        mergeSignals: this.mergeSignals.bind(this),\n                        upsertSignal: this.upsertSignal\n                            .bind(this),\n                        removeSignals: this.removeSignals.bind(this),\n                        applyPlugins: this.applyPlugins.bind(this),\n                        cleanup: this.cleanup\n                            .bind(this),\n                        walkSignals: this.walkSignals.bind(this),\n                        actions: this.actions,\n                        reactivity: this.reactivity,\n                        el,\n                        rawKey,\n                        key,\n                        rawExpression,\n                        expression,\n                        expressionFn: () => {\n                            throw ERR_METHOD_NOT_ALLOWED;\n                        },\n                        modifiers,\n                    };\n\n                    if (\n                        !p.bypassExpressionFunctionCreation?.(ctx) &&\n                        !p.mustHaveEmptyExpression && expression.length\n                    ) {\n                        const statements = expression\n                            .split(splitRegex)\n                            .map((s) => s.trim())\n                            .filter((s) => s.length);\n                        statements[statements.length - 1] = `return ${\n                            statements[statements.length - 1]\n                        }`;\n                        const j = statements.map((s) => `  ${s}`).join(\";\\n\");\n                        const fnContent = `try{${j}}catch(e){console.error(\\`Error evaluating Datastar expression:\\n${j.replaceAll(\"`\", \"\\\\`\")}\\n\\nError: \\${e.message}\\n\\nCheck if the expression is valid before raising an issue.\\`.trim());debugger}`;\n                        try {\n                            const argumentNames = p.argumentNames || [];\n                            const fn = new Function(\n                                \"ctx\",\n                                ...argumentNames,\n                                fnContent,\n                            ) as AttribtueExpressionFunction;\n                            ctx.expressionFn = fn;\n                        } catch (e) {\n                            const err = new Error(`${e}\\nwith\\n${fnContent}`);\n                            console.error(err);\n                            debugger;\n                        }\n                    }\n\n                    const removal = p.onLoad(ctx);\n                    if (removal) {\n                        if (!this.removals.has(el)) {\n                            this.removals.set(el, {\n                                id: el.id,\n                                set: new Set(),\n                            });\n                        }\n                        this.removals.get(el)!.set.add(removal);\n                    }\n                }\n            });\n        });\n    }\n\n    private walkSignalsStore(\n        store: any,\n        callback: (name: string, signal: Signal<any>) => void,\n    ) {\n        const keys = Object.keys(store);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const value = store[key];\n            const isSignal = value instanceof Signal;\n            const hasChildren = typeof value === \"object\" &&\n                Object.keys(value).length > 0;\n\n            if (isSignal) {\n                callback(key, value);\n                continue;\n            }\n\n            if (!hasChildren) continue;\n\n            this.walkSignalsStore(value, callback);\n        }\n    }\n\n    private walkSignals(callback: (name: string, signal: Signal<any>) => void) {\n        this.walkSignalsStore(this.store, callback);\n    }\n\n    private walkDownDOM(\n        element: Element | null,\n        callback: (el: HTMLorSVGElement) => void,\n        siblingOffset = 0,\n    ) {\n        if (!element) return;\n        const el = nodeHTMLorSVGElement(element);\n        if (!el) return;\n\n        callback(el);\n\n        siblingOffset = 0;\n        element = element.firstElementChild;\n        while (element) {\n            this.walkDownDOM(element, callback, siblingOffset++);\n            element = element.nextElementSibling;\n        }\n    }\n}\n", "import { Star } from \"../plugins/official/attributes/core/star\";\nimport { Computed } from \"../plugins/official/attributes/core/computed\";\nimport { Store } from \"../plugins/official/attributes/core/store\";\nimport { ActionsProcessor } from \"../plugins/official/preprocessors/core/actions\";\nimport { SignalsProcessor } from \"../plugins/official/preprocessors/core/signals\";\nimport { Engine } from \"./engine\";\n\nexport { VERSION } from \"./consts\";\n\nexport type * from \"./types\";\n\nconst ds = new Engine();\nds.load(\n    ActionsProcessor,\n    SignalsProcessor,\n    Store,\n    Computed,\n    Star,\n);\n\nexport const Datastar = ds;\n", "/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n    /** The event ID to set the EventSource object's last event ID value. */\n    id: string;\n    /** A string identifying the type of event described. */\n    event: string;\n    /** The event data */\n    data: string;\n    /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n    retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n    stream: ReadableStream<Uint8Array>,\n    onChunk: (arr: Uint8Array) => void,\n) {\n    const reader = stream.getReader();\n    let result: ReadableStreamReadResult<Uint8Array>;\n    while (!(result = await reader.read()).done) {\n        onChunk(result.value);\n    }\n}\n\nconst enum ControlChars {\n    NewLine = 10,\n    CarriageReturn = 13,\n    Space = 32,\n    Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n    onLine: (line: Uint8Array, fieldLength: number) => void,\n) {\n    let buffer: Uint8Array | undefined;\n    let position: number; // current read position\n    let fieldLength: number; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr: Uint8Array) {\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        } else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === ControlChars.NewLine) {\n                    lineStart = ++position; // skip to next char\n                }\n\n                discardTrailingNewline = false;\n            }\n\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case ControlChars.Colon:\n                        if (fieldLength === -1) { // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case ControlChars.CarriageReturn:\n                        discardTrailingNewline = true;\n                    case ControlChars.NewLine:\n                        lineEnd = position;\n                        break;\n                }\n            }\n\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        } else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n    onId: (id: string) => void,\n    onRetry: (retry: number) => void,\n    onMessage?: (msg: EventSourceMessage) => void,\n) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n\n    // return a function that can process each incoming line buffer:\n    return function onLine(line: Uint8Array, fieldLength: number) {\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        } else if (fieldLength > 0) { // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength +\n                (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data\n                        ? message.data + \"\\n\" + value\n                        : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId(message.id = value);\n                    break;\n                case \"retry\":\n                    const retry = parseInt(value, 10);\n                    if (!isNaN(retry)) { // per spec, ignore non-integers\n                        onRetry(message.retry = retry);\n                    }\n                    break;\n            }\n        }\n    };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\n", "import { ERR_SERVICE_UNAVAILABLE } from \"../../engine/errors\";\nimport { EventSourceMessage, getBytes, getLines, getMessages } from \"./parse\";\n\nexport const EventStreamContentType = \"text/event-stream\";\n\nconst DefaultRetryInterval = 1000;\nconst LastEventId = \"last-event-id\";\n\nexport interface FetchEventSourceInit extends RequestInit {\n    /**\n     * The request headers. FetchEventSource only supports the Record<string,string> format.\n     */\n    headers?: Record<string, string>;\n\n    /**\n     * Called when a response is received. Use this to validate that the response\n     * actually matches what you expect (and throw if it doesn't.) If not provided,\n     * will default to a basic validation to ensure the content-type is text/event-stream.\n     */\n    onopen?: (response: Response) => Promise<void>;\n\n    /**\n     * Called when a message is received. NOTE: Unlike the default browser\n     * EventSource.onmessage, this callback is called for _all_ events,\n     * even ones with a custom `event` field.\n     */\n    onmessage?: (ev: EventSourceMessage) => void;\n\n    /**\n     * Called when a response finishes. If you don't expect the server to kill\n     * the connection, you can throw an exception here and retry using onerror.\n     */\n    onclose?: () => void;\n\n    /**\n     * Called when there is any error making the request / processing messages /\n     * handling callbacks etc. Use this to control the retry strategy: if the\n     * error is fatal, rethrow the error inside the callback to stop the entire\n     * operation. Otherwise, you can return an interval (in milliseconds) after\n     * which the request will automatically retry (with the last-event-id).\n     * If this callback is not specified, or it returns undefined, fetchEventSource\n     * will treat every error as retriable and will try again after 1 second.\n     */\n    onerror?: (err: any) => number | null | undefined | void;\n\n    /**\n     * If true, will keep the request open even if the document is hidden.\n     * By default, fetchEventSource will close the request and reopen it\n     * automatically when the document becomes visible again.\n     */\n    openWhenHidden?: boolean;\n\n    /** The Fetch function to use. Defaults to window.fetch */\n    fetch?: typeof fetch;\n\n    /** The scaler for the retry interval. Defaults to 2 */\n    retryScaler?: number;\n\n    /** The maximum retry interval in milliseconds. Defaults to 30_000 */\n    retryMaxWaitMs?: number;\n\n    /** The maximum number of retries before giving up. Defaults to 10 */\n    retryMaxCount?: number;\n}\n\nexport function fetchEventSource(input: RequestInfo, {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    ...rest\n}: FetchEventSourceInit) {\n    return new Promise<void>((resolve, reject) => {\n        let retries = 0;\n\n        // make a copy of the input headers since we may modify it below:\n        const headers = { ...inputHeaders };\n        if (!headers.accept) {\n            headers.accept = EventStreamContentType;\n        }\n\n        let curRequestController: AbortController;\n        function onVisibilityChange() {\n            curRequestController.abort(); // close existing request on every visibility change\n            if (!document.hidden) {\n                create(); // page is now visible again, recreate request.\n            }\n        }\n\n        if (!openWhenHidden) {\n            document.addEventListener(\"visibilitychange\", onVisibilityChange);\n        }\n\n        let retryInterval = DefaultRetryInterval;\n        let retryTimer = 0;\n        function dispose() {\n            document.removeEventListener(\n                \"visibilitychange\",\n                onVisibilityChange,\n            );\n            window.clearTimeout(retryTimer);\n            curRequestController.abort();\n        }\n\n        // if the incoming signal aborts, dispose resources and resolve:\n        inputSignal?.addEventListener(\"abort\", () => {\n            dispose();\n            resolve(); // don't waste time constructing/logging errors\n        });\n\n        const fetch = inputFetch ?? window.fetch;\n        const onopen = inputOnOpen ??\n            function defaultOnOpen(\n                // response: Response\n            ) {};\n\n        async function create() {\n            curRequestController = new AbortController();\n            try {\n                const response = await fetch(input, {\n                    ...rest,\n                    headers,\n                    signal: curRequestController.signal,\n                });\n\n                await onopen(response);\n\n                await getBytes(\n                    response.body!,\n                    getLines(getMessages((id) => {\n                        if (id) {\n                            // store the id and send it back on the next retry:\n                            headers[LastEventId] = id;\n                        } else {\n                            // don't send the last-event-id header anymore:\n                            delete headers[LastEventId];\n                        }\n                    }, (retry) => {\n                        retryInterval = retry;\n                    }, onmessage)),\n                );\n\n                onclose?.();\n                dispose();\n                resolve();\n            } catch (err) {\n                if (!curRequestController.signal.aborted) {\n                    // if we haven't aborted the request ourselves:\n                    try {\n                        // check if we need to retry:\n                        const interval: any = onerror?.(err) ?? retryInterval;\n                        window.clearTimeout(retryTimer);\n                        retryTimer = window.setTimeout(create, interval);\n                        retryInterval *= retryScaler; // exponential backoff\n                        retryInterval = Math.min(retryInterval, retryMaxWaitMs);\n                        retries++;\n                        if (retries >= retryMaxCount) {\n                            // we should not retry anymore:\n                            dispose();\n                            // Max retries hit, check your server or network connection\n                            reject(ERR_SERVICE_UNAVAILABLE);\n                        } else {\n                            console.error(\n                                `Datastar failed to reach ${rest.method}:${input.toString()} retry in ${interval}ms`,\n                            );\n                        }\n                    } catch (innerErr) {\n                        // we should not retry anymore:\n                        dispose();\n                        reject(innerErr);\n                    }\n                }\n            }\n        }\n\n        create();\n    });\n}\n", "import { DATASTAR } from \"../../../../engine/consts\";\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`;\nexport const SETTLING_CLASS = `${DATASTAR}-settling`;\nexport const SWAPPING_CLASS = `${DATASTAR}-swapping`;\nexport const STARTED = \"started\";\nexport const FINISHED = \"finished\";\n\nexport interface DatastarSSEEvent {\n    type: string;\n    argsRaw: Record<string, string>;\n}\n\nexport interface CustomEventMap {\n    \"datastar-sse\": CustomEvent<DatastarSSEEvent>;\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n    this: Document,\n    ev: CustomEventMap[K],\n) => void;\n\ndeclare global {\n    interface Document { //adds definition to Document, but you can do the same with HTMLElement\n        addEventListener<K extends keyof CustomEventMap>(\n            type: K,\n            listener: WatcherFn<K>,\n        ): void;\n        removeEventListener<K extends keyof CustomEventMap>(\n            type: K,\n            listener: WatcherFn<K>,\n        ): void;\n        dispatchEvent<K extends keyof CustomEventMap>(\n            ev: CustomEventMap[K],\n        ): void;\n    }\n}\n\nexport function datastarSSEEventWatcher(\n    // ctx: InitContext,\n    eventType: string,\n    fn: (argsRaw: Record<string, string>) => void,\n) {\n    document.addEventListener(\n        DATASTAR_SSE_EVENT,\n        (event: CustomEvent<DatastarSSEEvent>) => {\n            if (event.detail.type != eventType) return;\n            const { argsRaw } = event.detail;\n            fn(argsRaw);\n        },\n    );\n}\n", "import { ActionMethod } from \"../../../../engine\";\nimport { DATASTAR, DATASTAR_REQUEST } from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { remoteSignals } from \"../../../../utils/signals\";\nimport {\n    fetchEventSource,\n    FetchEventSourceInit,\n} from \"../../../../vendored/fetch-event-source\";\nimport {\n    DATASTAR_SSE_EVENT,\n    DatastarSSEEvent,\n    FINISHED,\n    STARTED,\n} from \"../../watchers/backend/sseShared\";\n\nexport type IndicatorReference = { el: HTMLElement; count: number };\n\nconst isWrongContent = (err: any) => `${err}`.includes(`text/event-stream`);\n\nexport type SSERequestArgs = {\n    onlyRemoteSignals?: boolean;\n    headers?: Record<string, string>;\n};\n\nfunction dispatchSSE(type: string, argsRaw: Record<string, string>) {\n    document.dispatchEvent(\n        new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n            detail: { type, argsRaw },\n        }),\n    );\n}\n\nexport function sendSSERequest(\n    method: string,\n): ActionMethod {\n    return async (\n        ctx,\n        url,\n        args?: SSERequestArgs,\n    ) => {\n        if (!!!url?.length) throw ERR_BAD_ARGS;\n\n        const { onlyRemoteSignals, headers } = Object.assign({\n            onlyRemoteSignals: true,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                [DATASTAR_REQUEST]: true,\n            },\n        }, args);\n        const currentStore = ctx.store().value;\n        let store = Object.assign({}, currentStore);\n        if (onlyRemoteSignals) {\n            store = remoteSignals(store);\n        }\n        const storeJSON = JSON.stringify(store);\n\n        const { el: { id: elID } } = ctx;\n        dispatchSSE(STARTED, { elID });\n\n        const urlInstance = new URL(url, window.location.origin);\n\n        // https://fetch.spec.whatwg.org/#concept-method-normalize\n        method = method.toUpperCase();\n\n        const req: FetchEventSourceInit = {\n            method,\n            headers,\n            onmessage: (evt) => {\n                if (!evt.event.startsWith(DATASTAR)) {\n                    return;\n                }\n                const type = evt.event;\n                const argsRawLines: Record<string, string[]> = {};\n\n                const lines = evt.data.split(\"\\n\");\n                for (const line of lines) {\n                    const colonIndex = line.indexOf(\" \");\n                    const key = line.slice(0, colonIndex);\n                    let argLines = argsRawLines[key];\n                    if (!argLines) {\n                        argLines = [];\n                        argsRawLines[key] = argLines;\n                    }\n                    const value = line.slice(colonIndex + 1).trim();\n                    argLines.push(value);\n                }\n\n                const argsRaw: Record<string, string> = {};\n                for (const [key, lines] of Object.entries(argsRawLines)) {\n                    argsRaw[key] = lines.join(\"\\n\");\n                }\n\n                // if you aren't seeing your event you can debug by using this line in the console\n                // document.addEventListener(\"datastar-sse\",(e) => console.log(e));\n                dispatchSSE(type, argsRaw);\n            },\n            onerror: (err) => {\n                if (isWrongContent(err)) {\n                    // don't retry if the content-type is wrong\n                    throw err;\n                }\n                // do nothing and it will retry\n                if (err) {\n                    console.error(err.message);\n                }\n            },\n            onclose: () => {\n                dispatchSSE(FINISHED, { elID });\n            },\n        };\n\n        if (method === \"GET\") {\n            const queryParams = new URLSearchParams(urlInstance.search);\n            queryParams.append(DATASTAR, storeJSON);\n            urlInstance.search = queryParams.toString();\n        } else {\n            req.body = storeJSON;\n        }\n\n        try {\n            const revisedURL = urlInstance.toString();\n            await fetchEventSource(revisedURL, req);\n        } catch (err) {\n            if (!isWrongContent(err)) {\n                throw err;\n            }\n\n            // exit gracefully and do nothing if the content-type is wrong\n            // this can happen if the client is sending a request\n            // where no response is expected, and they haven't\n            // set the content-type to text/event-stream\n        }\n    };\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:delete\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const DeleteSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"delete\",\n    method: sendSSERequest(\"delete\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const GetSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"get\",\n    method: sendSSERequest(\"get\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:bandage\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PatchSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"patch\",\n    method: sendSSERequest(\"patch\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:add\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PostSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"post\",\n    method: sendSSERequest(\"post\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:find-replace\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PutSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"put\",\n    method: sendSSERequest(\"put\"),\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:clipboard\n// Slug: Copy text to the clipboard\n// Description: This action copies text to the clipboard using the Clipboard API.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { ERR_NOT_ALLOWED } from \"../../../../engine/errors\";\n\nexport const Clipboard: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clipboard\",\n    method: (_, text) => {\n        if (!navigator.clipboard) {\n            // Clipboard API not available\n            throw ERR_NOT_ALLOWED;\n        }\n        navigator.clipboard.writeText(text);\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\n\nexport const SetAll: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"setAll\",\n    method: (ctx, regexp, newValue) => {\n        const re = new RegExp(regexp);\n        ctx.walkSignals((name, signal) =>\n            re.test(name) && (signal.value = newValue)\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\n\nexport const ToggleAll: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"toggleAll\",\n    method: (ctx, regexp) => {\n        const re = new RegExp(regexp);\n        ctx.walkSignals((name, signal) =>\n            re.test(name) && (signal.value = !signal.value)\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen-outline\n// Slug: Clamp a value to a new range\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const ClampFit: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clampFit\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) => {\n        return Math.max(\n            newMin,\n            Math.min(\n                newMax,\n                ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin,\n            ),\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen\n// Slug: Clamp a value to a new range and round to the nearest integer\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range. The result is then rounded to the nearest integer.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const ClampFitInt: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clampFitInt\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) => {\n        return Math.round(\n            Math.max(\n                newMin,\n                Math.min(\n                    newMax,\n                    ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) +\n                        newMin,\n                ),\n            ),\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols-light:fit-width\n// Slug: Linearly fit a value to a new range\n// Description: This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const Fit: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"fit\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) => {\n        return ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin;\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-width\n// Slug: Linearly fit a value to a new range and round to the nearest integer\n// Description: This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const FitInt: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"fitInt\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) => {\n        return Math.round(\n            ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin,\n        );\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { DATASTAR } from \"../../../../engine/consts\";\nimport { ERR_NOT_FOUND } from \"../../../../engine/errors\";\nimport { isDatastarGeneratedID } from \"../../../../utils/regex\";\nimport {\n    DATASTAR_SSE_EVENT,\n    DatastarSSEEvent,\n    FINISHED,\n    STARTED,\n} from \"../../watchers/backend/sseShared\";\n\nexport const INDICATOR_CLASS = `${DATASTAR}-indicator`;\nexport const INDICATOR_LOADING_CLASS = `${INDICATOR_CLASS}-loading`;\n\nexport const Indicator: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"indicator\",\n    mustHaveEmptyKey: true,\n    onLoad: (ctx) => {\n        const { expression, upsertSignal, el } = ctx;\n        if (isDatastarGeneratedID(el)) {\n            // Indicator cannot be used on an element without an ID\n            // otherwise it will auto generate and most like will be incorrect\n            // if you get to the point match sure this element has a unique ID.\n            throw ERR_NOT_FOUND;\n        }\n        const signalName = expression;\n        const signal = upsertSignal(signalName, false);\n\n        const watcher = (event: CustomEvent<DatastarSSEEvent>) => {\n            const { type, argsRaw: { elID } } = event.detail;\n            if (elID !== el.id) return;\n            switch (type) {\n                case STARTED:\n                    signal.value = true;\n                    break;\n                case FINISHED:\n                    signal.value = false;\n                    break;\n            }\n        };\n\n        document.addEventListener(DATASTAR_SSE_EVENT, watcher);\n\n        return () => {\n            document.removeEventListener(DATASTAR_SSE_EVENT, watcher);\n        };\n    },\n};\n", "export const kebabize = (str: string) =>\n    str.replace(\n        /[A-Z]+(?![a-z])|[A-Z]/g,\n        ($, ofs) => (ofs ? \"-\" : \"\") + $.toLowerCase(),\n    );\n\nexport const isBoolString = (str: string) => str.trim() === \"true\";\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { kebabize } from \"../../../../utils/text\";\n\nexport const Bind: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"bind\",\n    mustNotEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) => {\n        return ctx.reactivity.effect(async () => {\n            const key = kebabize(ctx.key);\n            const value = ctx.expressionFn(ctx);\n            let v: string;\n            if (typeof value === \"string\") {\n                v = value;\n            } else {\n                v = JSON.stringify(value);\n            }\n            if (!v || v === \"false\" || v === \"null\" || v === \"undefined\") {\n                ctx.el.removeAttribute(key);\n            } else {\n                ctx.el.setAttribute(key, v);\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Class: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"class\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) => {\n        return ctx.reactivity.effect(() => {\n            const classes: Object = ctx.expressionFn(ctx);\n            for (const [k, v] of Object.entries(classes)) {\n                const classNames = k.split(\" \");\n                if (v) {\n                    ctx.el.classList.add(...classNames);\n                } else {\n                    ctx.el.classList.remove(...classNames);\n                }\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: clarity:two-way-arrows-line\n// Slug: Enable two-way data binding\n// Description: This attribute plugin enables two-way data binding for input elements.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport {\n    ERR_BAD_ARGS,\n    ERR_METHOD_NOT_ALLOWED,\n} from \"../../../../engine/errors\";\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/;\nconst updateModelEvents = [\"change\", \"input\", \"keydown\"];\n\nexport const Model: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"model\",\n    mustHaveEmptyKey: true,\n    // bypassExpressionFunctionCreation: () => true,\n    onLoad: (ctx) => {\n        const { el, expression, upsertSignal } = ctx;\n        const signalName = expression;\n        if (typeof signalName !== \"string\") {\n            // Signal name must be a string\n            throw ERR_BAD_ARGS;\n        }\n\n        const tnl = el.tagName.toLowerCase();\n\n        let signalDefault: string | boolean | File = \"\";\n        const isInput = tnl.includes(\"input\");\n        const type = el.getAttribute(\"type\");\n        const isCheckbox = tnl.includes(\"checkbox\") ||\n            (isInput && type === \"checkbox\");\n        if (isCheckbox) {\n            signalDefault = false;\n        }\n        const isSelect = tnl.includes(\"select\");\n        const isRadio = tnl.includes(\"radio\") || (isInput && type === \"radio\");\n        const isFile = isInput && type === \"file\";\n        if (isFile) {\n            // can't set a default value for a file input, yet\n        }\n        if (isRadio) {\n            const name = el.getAttribute(\"name\");\n            if (!name?.length) {\n                el.setAttribute(\"name\", signalName);\n            }\n        }\n\n        const signal = upsertSignal(signalName, signalDefault);\n\n        const setInputFromSignal = () => {\n            const hasValue = \"value\" in el;\n            const v = signal.value;\n            const vStr = `${v}`;\n            if (isCheckbox || isRadio) {\n                const input = el as HTMLInputElement;\n                if (isCheckbox) {\n                    input.checked = v;\n                } else if (isRadio) {\n                    // evaluate the value as string to handle any type casting\n                    // automatically since the attribute has to be a string anyways\n                    input.checked = vStr === input.value;\n                }\n            } else if (isFile) {\n                // File input reading from a signal is not supported yet\n            } else if (isSelect) {\n                const select = el as HTMLSelectElement;\n                if (select.multiple) {\n                    Array.from(select.options).forEach((opt) => {\n                        if (opt?.disabled) return;\n                        opt.selected = v.includes(opt.value);\n                    });\n                } else {\n                    select.value = vStr;\n                }\n            } else if (hasValue) {\n                el.value = vStr;\n            } else {\n                el.setAttribute(\"value\", vStr);\n            }\n        };\n        const cleanupSetInputFromSignal = ctx.reactivity.effect(\n            setInputFromSignal,\n        );\n\n        const setSignalFromInput = async () => {\n            if (isFile) {\n                const files = [...((el as HTMLInputElement)?.files || [])],\n                    allContents: string[] = [],\n                    allMimes: string[] = [],\n                    allNames: string[] = [];\n\n                await Promise.all(\n                    files.map((f) => {\n                        return new Promise<void>((resolve) => {\n                            const reader = new FileReader();\n                            reader.onload = () => {\n                                if (typeof reader.result !== \"string\") {\n                                    // console.error(`Invalid result type: ${typeof reader.result}`);\n                                    throw ERR_BAD_ARGS;\n                                }\n                                const match = reader.result.match(dataURIRegex);\n                                if (!match?.groups) {\n                                    // console.error(`Invalid data URI: ${reader.result}`);\n                                    throw ERR_BAD_ARGS;\n                                }\n                                allContents.push(match.groups.contents);\n                                allMimes.push(match.groups.mime);\n                                allNames.push(f.name);\n                            };\n                            reader.onloadend = () => resolve(void 0);\n                            reader.readAsDataURL(f);\n                        });\n                    }),\n                );\n\n                signal.value = allContents;\n                const s = ctx.store();\n                const mimeName = `${signalName}Mimes`,\n                    nameName = `${signalName}Names`;\n                if (mimeName in s) {\n                    s[`${mimeName}`].value = allMimes;\n                }\n                if (nameName in s) {\n                    s[`${nameName}`].value = allNames;\n                }\n                return;\n            }\n\n            const current = signal.value;\n            const input = (el as HTMLInputElement) || (el as HTMLElement);\n\n            if (typeof current === \"number\") {\n                signal.value = Number(\n                    input.value || input.getAttribute(\"value\"),\n                );\n            } else if (typeof current === \"string\") {\n                signal.value = input.value || input.getAttribute(\"value\") ||\n                    \"\";\n            } else if (typeof current === \"boolean\") {\n                if (isCheckbox) {\n                    signal.value = input.checked ||\n                        input.getAttribute(\"checked\") === \"true\";\n                } else {\n                    signal.value = Boolean(\n                        input.value || input.getAttribute(\"value\"),\n                    );\n                }\n            } else if (typeof current === \"undefined\") {\n            } else if (typeof current === \"bigint\") {\n                signal.value = BigInt(\n                    input.value || input.getAttribute(\"value\") || \"0\",\n                );\n            } else if (Array.isArray(current)) {\n                // check if the input is a select element\n                if (isSelect) {\n                    const select = el as HTMLSelectElement;\n                    const selectedOptions = [...select.selectedOptions];\n                    const selectedValues = selectedOptions.map((opt) =>\n                        opt.value\n                    );\n                    signal.value = selectedValues;\n                } else {\n                    signal.value = JSON.parse(input.value).split(\",\");\n                }\n                console.log(input.value);\n            } else {\n                // console.log(`Unsupported type ${typeof current}`);\n                throw ERR_METHOD_NOT_ALLOWED;\n            }\n        };\n\n        const parts = el.tagName.split(\"-\");\n        const isCustomElement = parts.length > 1;\n        if (isCustomElement) {\n            const customElementPrefix = parts[0].toLowerCase();\n            updateModelEvents.forEach((eventType) => {\n                updateModelEvents.push(`${customElementPrefix}-${eventType}`);\n            });\n        }\n\n        updateModelEvents.forEach((eventType) =>\n            el.addEventListener(eventType, setSignalFromInput)\n        );\n\n        return () => {\n            cleanupSetInputFromSignal();\n            updateModelEvents.forEach((event) =>\n                el.removeEventListener(event, setSignalFromInput)\n            );\n        };\n    },\n};\n", "export function argsToMs(args: string[] | undefined) {\n    if (!args || args?.length === 0) return 0;\n\n    for (const arg of args) {\n        if (arg.endsWith(\"ms\")) {\n            return Number(arg.replace(\"ms\", \"\"));\n        } else if (arg.endsWith(\"s\")) {\n            return Number(arg.replace(\"s\", \"\")) * 1000;\n        }\n\n        try {\n            return parseFloat(arg);\n        } catch (e) {}\n    }\n\n    return 0;\n}\n\nexport function argsHas(\n    args: string[] | undefined,\n    arg: string,\n    defaultValue = false,\n) {\n    if (!args) return false;\n    return args.includes(arg) || defaultValue;\n}\n", "export type TimerHandler = (...args: any[]) => void;\n\nexport function debounce(\n    callback: TimerHandler,\n    wait: number,\n    leading = false,\n    trailing = true,\n): TimerHandler {\n    let timer = -1;\n\n    const resetTimer = () => timer && clearTimeout(timer);\n\n    return function wrapper(...args: any[]) {\n        resetTimer();\n\n        if (leading && !timer) {\n            callback(...args);\n        }\n\n        timer = setTimeout(() => {\n            if (trailing) {\n                callback(...args);\n            }\n            resetTimer();\n        }, wait);\n    };\n}\n\nexport function throttle(\n    callback: TimerHandler,\n    wait: number,\n    leading = true,\n    trailing = false,\n): TimerHandler {\n    let waiting = false;\n\n    return function wrapper(...args: any[]) {\n        if (waiting) return;\n\n        if (leading) {\n            callback(...args);\n        }\n\n        waiting = true;\n        setTimeout(() => {\n            waiting = false;\n            if (trailing) {\n                callback(...args);\n            }\n        }, wait);\n    };\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This action adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { argsHas, argsToMs } from \"../../../../utils/arguments\";\nimport { remoteSignals } from \"../../../../utils/signals\";\nimport { kebabize } from \"../../../../utils/text\";\nimport { debounce, throttle } from \"../../../../utils/timing\";\n\nconst knownOnModifiers = new Set([\n    \"window\",\n    \"once\",\n    \"passive\",\n    \"capture\",\n    \"debounce\",\n    \"throttle\",\n    \"remote\",\n    \"outside\",\n]);\n\nlet lastStoreMarshalled = \"\";\n\n// Sets the event listener of the element\nexport const On: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"on\",\n    mustNotEmptyKey: true,\n    mustNotEmptyExpression: true,\n    argumentNames: [\"evt\"],\n    onLoad: (ctx) => {\n        const { el, key, expressionFn } = ctx;\n\n        let target: Element | Window | Document = ctx.el;\n        if (ctx.modifiers.get(\"window\")) {\n            target = window;\n        }\n\n        let callback = (evt?: Event) => {\n            expressionFn(ctx, evt);\n        };\n\n        const debounceArgs = ctx.modifiers.get(\"debounce\");\n        if (debounceArgs) {\n            const wait = argsToMs(debounceArgs);\n            const leading = argsHas(debounceArgs, \"leading\", false);\n            const trailing = argsHas(debounceArgs, \"noTrail\", true);\n            callback = debounce(callback, wait, leading, trailing);\n        }\n\n        const throttleArgs = ctx.modifiers.get(\"throttle\");\n        if (throttleArgs) {\n            const wait = argsToMs(throttleArgs);\n            const leading = argsHas(throttleArgs, \"noLead\", true);\n            const trailing = argsHas(throttleArgs, \"noTrail\", false);\n            callback = throttle(callback, wait, leading, trailing);\n        }\n\n        const evtListOpts: AddEventListenerOptions = {\n            capture: true,\n            passive: false,\n            once: false,\n        };\n        if (!ctx.modifiers.has(\"capture\")) evtListOpts.capture = false;\n        if (ctx.modifiers.has(\"passive\")) evtListOpts.passive = true;\n        if (ctx.modifiers.has(\"once\")) evtListOpts.once = true;\n\n        const unknownModifierKeys = [...ctx.modifiers.keys()].filter((key) =>\n            !knownOnModifiers.has(key)\n        );\n\n        unknownModifierKeys.forEach((attrName) => {\n            const eventValues = ctx.modifiers.get(attrName) || [];\n            const cb = callback;\n            const revisedCallback = () => {\n                const evt = event as any;\n                const attr = evt[attrName];\n                let valid: boolean;\n\n                if (typeof attr === \"function\") {\n                    valid = attr(...eventValues);\n                } else if (typeof attr === \"boolean\") {\n                    valid = attr;\n                } else if (typeof attr === \"string\") {\n                    const lowerAttr = attr.toLowerCase().trim();\n                    const expr = eventValues.join(\"\").toLowerCase().trim();\n                    valid = lowerAttr === expr;\n                } else {\n                    // console.error(`Invalid value for ${attrName} modifier on ${key} on ${el}`);\n                    throw ERR_BAD_ARGS;\n                }\n\n                if (valid) {\n                    cb(evt);\n                }\n            };\n            callback = revisedCallback;\n        });\n\n        const eventName = kebabize(key).toLowerCase();\n        switch (eventName) {\n            case \"load\":\n                callback();\n                delete ctx.el.dataset.onLoad;\n                return () => {};\n\n            case \"raf\":\n                let rafId: number | undefined;\n                const raf = () => {\n                    callback();\n                    rafId = requestAnimationFrame(raf);\n                };\n                rafId = requestAnimationFrame(raf);\n\n                return () => {\n                    if (rafId) cancelAnimationFrame(rafId);\n                };\n\n            case \"store-change\":\n                return ctx.reactivity.effect(() => {\n                    const store = ctx.store();\n                    let storeValue = store.value;\n                    if (ctx.modifiers.has(\"remote\")) {\n                        storeValue = remoteSignals(storeValue);\n                    }\n                    const current = JSON.stringify(storeValue);\n                    if (lastStoreMarshalled !== current) {\n                        lastStoreMarshalled = current;\n                        callback();\n                    }\n                });\n\n            default:\n                const testOutside = ctx.modifiers.has(\"outside\");\n                if (testOutside) {\n                    target = document;\n                    const cb = callback;\n                    let called = false;\n                    const targetOutsideCallback = (e?: Event) => {\n                        const targetHTML = e?.target as HTMLElement;\n                        if (!targetHTML) return;\n                        const isEl = el.id === targetHTML.id;\n                        if (isEl && called) {\n                            called = false;\n                        }\n                        if (!isEl && !called) {\n                            cb(e);\n                            called = true;\n                        }\n                    };\n                    callback = targetOutsideCallback;\n                }\n\n                target.addEventListener(eventName, callback, evtListOpts);\n                return () => {\n                    // console.log(`Removing event listener for ${eventName} on ${el}`)\n                    target.removeEventListener(eventName, callback);\n                };\n        }\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"ref\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n    bypassExpressionFunctionCreation: () => true,\n    onLoad: (ctx) => {\n        const signalName = ctx.expression;\n        ctx.upsertSignal(signalName, ctx.el);\n\n        return () => {\n            ctx.removeSignals(signalName);\n        };\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\n\nexport const Text: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"text\",\n    mustHaveEmptyKey: true,\n    onLoad: (ctx) => {\n        const { el, expressionFn } = ctx;\n        if (!(el instanceof HTMLElement)) {\n            // Element is not HTMLElement\n            throw ERR_BAD_ARGS;\n        }\n        return ctx.reactivity.effect(() => {\n            const res = expressionFn(ctx);\n            el.textContent = `${res}`;\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi:floppy-variant\n// Slug: Persist data to local storage or session storage\n// Description: This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { DATASTAR, DATASTAR_EVENT } from \"../../../../engine/consts\";\nimport { remoteSignals } from \"../../../../utils/signals\";\nimport { DatastarSSEEvent } from \"../../watchers/backend/sseShared\";\n\nexport const Persist: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"persist\",\n    allowedModifiers: new Set([\"local\", \"session\", \"remote\"]),\n    onLoad: (ctx) => {\n        const key = ctx.key || DATASTAR;\n        const expression = ctx.expression;\n        const keys = new Set<string>();\n\n        if (expression.trim() !== \"\") {\n            const value = ctx.expressionFn(ctx);\n            const parts = value.split(\" \");\n            for (const part of parts) {\n                keys.add(part);\n            }\n        }\n\n        let lastMarshalled = \"\";\n        const storageType = ctx.modifiers.has(\"session\") ? \"session\" : \"local\";\n        const useRemote = ctx.modifiers.has(\"remote\");\n\n        const storeUpdateHandler = ((_: CustomEvent<DatastarSSEEvent>) => {\n            let store = ctx.store();\n            if (useRemote) {\n                store = remoteSignals(store);\n            }\n            if (keys.size > 0) {\n                const newStore: Record<string, any> = {};\n                for (const key of keys) {\n                    const parts = key.split(\".\");\n                    let newSubstore = newStore;\n                    let subStore = store;\n                    for (let i = 0; i < parts.length - 1; i++) {\n                        const part = parts[i];\n                        if (!newSubstore[part]) {\n                            newSubstore[part] = {};\n                        }\n                        newSubstore = newSubstore[part];\n                        subStore = subStore[part];\n                    }\n\n                    const lastPart = parts[parts.length - 1];\n                    newSubstore[lastPart] = subStore[lastPart];\n                }\n                store = newStore;\n            }\n\n            const marshalledStore = JSON.stringify(store);\n\n            if (marshalledStore === lastMarshalled) {\n                return;\n            }\n\n            if (storageType === \"session\") {\n                window.sessionStorage.setItem(key, marshalledStore);\n            } else {\n                window.localStorage.setItem(key, marshalledStore);\n            }\n\n            lastMarshalled = marshalledStore;\n        }) as EventListener;\n\n        window.addEventListener(DATASTAR_EVENT, storeUpdateHandler);\n\n        let marshalledStore: string | null;\n\n        if (storageType === \"session\") {\n            marshalledStore = window.sessionStorage.getItem(key);\n        } else {\n            marshalledStore = window.localStorage.getItem(key);\n        }\n\n        if (!!marshalledStore) {\n            const store = JSON.parse(marshalledStore);\n            for (const key in store) {\n                ctx.upsertSignal(key, store[key]);\n            }\n        }\n\n        return () => {\n            window.removeEventListener(DATASTAR_EVENT, storeUpdateHandler);\n        };\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: carbon:url\n// Slug: Replace the current URL with a new URL\n// Description: This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const ReplaceUrl: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"replaceUrl\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) => {\n        return ctx.reactivity.effect(() => {\n            const value = ctx.expressionFn(ctx);\n            const baseUrl = window.location.href;\n            const url = new URL(value, baseUrl).toString();\n\n            window.history.replaceState({}, \"\", url);\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Run expression when element intersects with viewport\n// Description: An attribute that runs an expression when the element intersects with the viewport.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nconst ONCE = \"once\";\nconst HALF = \"half\";\nconst FULL = \"full\";\n\n// Run expression when element intersects with viewport\nexport const Intersection: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"intersects\",\n    allowedModifiers: new Set([ONCE, HALF, FULL]),\n    mustHaveEmptyKey: true,\n    onLoad: (ctx) => {\n        const { modifiers } = ctx;\n        const options = { threshold: 0 };\n        if (modifiers.has(FULL)) options.threshold = 1;\n        else if (modifiers.has(HALF)) options.threshold = 0.5;\n\n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    ctx.expressionFn(ctx);\n                    if (modifiers.has(ONCE)) {\n                        observer.disconnect();\n                        delete ctx.el.dataset[ctx.rawKey];\n                    }\n                }\n            });\n        }, options);\n\n        observer.observe(ctx.el);\n        return () => observer.disconnect();\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: hugeicons:mouse-scroll-01\n// Slug: Scroll an element into view\n// Description: This attribute scrolls the element into view.\n\nimport { AttributeContext, AttributePlugin } from \"../../../../engine\";\nimport { scrollIntoView } from \"../../../../utils/dom\";\n\nconst SMOOTH = \"smooth\";\nconst INSTANT = \"instant\";\nconst AUTO = \"auto\";\nconst HSTART = \"hstart\";\nconst HCENTER = \"hcenter\";\nconst HEND = \"hend\";\nconst HNEAREST = \"hnearest\";\nconst VSTART = \"vstart\";\nconst VCENTER = \"vcenter\";\nconst VEND = \"vend\";\nconst VNEAREST = \"vnearest\";\nconst FOCUS = \"focus\";\n\nconst CENTER = \"center\";\nconst START = \"start\";\nconst END = \"end\";\nconst NEAREST = \"nearest\";\n\n// Scrolls the element into view\nexport const ScrollIntoView: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"scrollIntoView\",\n    mustHaveEmptyKey: true,\n    mustHaveEmptyExpression: true,\n    allowedModifiers: new Set([\n        SMOOTH,\n        INSTANT,\n        AUTO,\n        HSTART,\n        HCENTER,\n        HEND,\n        HNEAREST,\n        VSTART,\n        VCENTER,\n        VEND,\n        VNEAREST,\n        FOCUS,\n    ]),\n\n    onLoad: ({ el, modifiers, rawKey }: AttributeContext) => {\n        if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n        const opts: ScrollIntoViewOptions = {\n            behavior: SMOOTH,\n            block: CENTER,\n            inline: CENTER,\n        };\n        if (modifiers.has(SMOOTH)) opts.behavior = SMOOTH;\n        if (modifiers.has(INSTANT)) opts.behavior = INSTANT;\n        if (modifiers.has(AUTO)) opts.behavior = AUTO;\n        if (modifiers.has(HSTART)) opts.inline = START;\n        if (modifiers.has(HCENTER)) opts.inline = CENTER;\n        if (modifiers.has(HEND)) opts.inline = END;\n        if (modifiers.has(HNEAREST)) opts.inline = NEAREST;\n        if (modifiers.has(VSTART)) opts.block = START;\n        if (modifiers.has(VCENTER)) opts.block = CENTER;\n        if (modifiers.has(VEND)) opts.block = END;\n        if (modifiers.has(VNEAREST)) opts.block = NEAREST;\n\n        scrollIntoView(el, opts, modifiers.has(\"focus\"));\n        delete el.dataset[rawKey];\n        return () => {};\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Show: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"show\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) => {\n        return ctx.reactivity.effect(async () => {\n            const shouldShow: boolean = ctx.expressionFn(ctx);\n\n            if (shouldShow) {\n                if (ctx.el.style.display === \"none\") {\n                    ctx.el.style.removeProperty(\"display\");\n                }\n            } else {\n                ctx.el.style.setProperty(\"display\", \"none\");\n            }\n        });\n    },\n};\n", "export interface DocumentSupportingViewTransitionAPI {\n    startViewTransition(\n        updateCallback: () => Promise<void> | void,\n    ): IViewTransition;\n}\n\nexport interface IViewTransition {\n    finished: Promise<void>;\n    ready: Promise<void>;\n    updateCallbackDone: Promise<void>;\n    skipTransition(): void;\n}\n\nexport const docWithViewTransitionAPI =\n    document as unknown as DocumentSupportingViewTransitionAPI;\nexport const supportsViewTransitions = !!docWithViewTransitionAPI\n    .startViewTransition;\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:masked-transitions\n// Slug: Setup view transitions\n// Description: This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { supportsViewTransitions } from \"../../../../utils/view-transitions\";\n\nconst VIEW_TRANSITION = \"view-transition\";\n\nexport const ViewTransition: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: VIEW_TRANSITION,\n    onGlobalInit() {\n        let hasViewTransitionMeta = false;\n        document.head.childNodes.forEach((node) => {\n            if (\n                node instanceof HTMLMetaElement &&\n                node.name === VIEW_TRANSITION\n            ) {\n                hasViewTransitionMeta = true;\n            }\n        });\n\n        if (!hasViewTransitionMeta) {\n            const meta = document.createElement(\"meta\");\n            meta.name = VIEW_TRANSITION;\n            meta.content = \"same-origin\";\n            document.head.appendChild(meta);\n        }\n    },\n    onLoad: (ctx) => {\n        if (!supportsViewTransitions) {\n            console.error(\"Browser does not support view transitions\");\n            return;\n        }\n\n        return ctx.reactivity.effect(() => {\n            const { el, expressionFn } = ctx;\n            let name = expressionFn(ctx);\n            if (!name) return;\n\n            const elVTASTyle = el.style as unknown as CSSStyleDeclaration;\n            elVTASTyle.viewTransitionName = name;\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: tabler:file-type-js\n// Slug: Execute JavaScript from a Server-Sent Event\n// Description: Execute JavaScript from a Server-Sent Event\n\nimport { WatcherPlugin } from \"../../../../engine/types\";\n\nimport {\n    DefaultExecuteScriptAttributes,\n    DefaultExecuteScriptAutoRemove,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const ExecuteScript: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.ExecuteScript,\n    onGlobalInit: async () => {\n        datastarSSEEventWatcher(\n            EventTypes.ExecuteScript,\n            (\n                {\n                    autoRemove: autoRemoveRaw =\n                        `${DefaultExecuteScriptAutoRemove}`,\n                    attributes: attributesRaw = DefaultExecuteScriptAttributes,\n                    script,\n                },\n            ) => {\n                const autoRemove = isBoolString(autoRemoveRaw);\n                if (!script?.length) {\n                    // No script provided\n                    throw ERR_BAD_ARGS;\n                }\n                const scriptEl = document.createElement(\"script\");\n                attributesRaw.split(\"\\n\").forEach((attr) => {\n                    const pivot = attr.indexOf(\" \");\n                    const key = pivot ? attr.slice(0, pivot) : attr;\n                    const value = pivot ? attr.slice(pivot) : '';\n                    scriptEl.setAttribute(key.trim(), value.trim());\n                });\n                scriptEl.text = script;\n                document.head.appendChild(scriptEl);\n                if (autoRemove) {\n                    scriptEl.remove();\n                }\n            },\n        );\n    },\n};\n", "import { FragmentMergeModes } from \"../engine/consts\";\nimport { ERR_BAD_ARGS, ERR_NOT_FOUND } from \"../engine/errors\";\n\nconst generatedByIdiomorphId = new WeakSet();\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(\n    oldNode: Document | Element,\n    newContent: string | Element,\n    config = {},\n) {\n    if (oldNode instanceof Document) {\n        oldNode = oldNode.documentElement;\n    }\n\n    let parsedContent: Element;\n    if (typeof newContent === \"string\") {\n        parsedContent = parseContent(newContent) as Element;\n    } else {\n        parsedContent = newContent;\n    }\n\n    const normalizedContent = normalizeContent(parsedContent);\n    const ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n}\n\nfunction morphNormalizedContent(\n    oldNode: Element,\n    normalizedNewContent: Element,\n    ctx: any,\n) {\n    if (ctx.head.block) {\n        const oldHead = oldNode.querySelector(\"head\");\n        const newHead = normalizedNewContent.querySelector(\"head\");\n        if (oldHead && newHead) {\n            const promises = handleHeadElement(newHead, oldHead, ctx);\n            // when head promises resolve, call morph again, ignoring the head tag\n            Promise.all(promises).then(() => {\n                morphNormalizedContent(\n                    oldNode,\n                    normalizedNewContent,\n                    Object.assign(ctx, {\n                        head: {\n                            block: false,\n                            ignore: true,\n                        },\n                    }),\n                );\n            });\n            return;\n        }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n        // innerHTML, so we are only updating the children\n        morphChildren(normalizedNewContent, oldNode, ctx);\n        return oldNode.children;\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n        // otherwise find the best element match in the new content, morph that, and merge its siblings\n        // into either side of the best match\n        const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n        if (!bestMatch) {\n            // could not find a best match, so throw an error\n            throw ERR_NOT_FOUND;\n        }\n\n        // stash the siblings that will need to be inserted on either side of the best match\n        const previousSibling = bestMatch?.previousSibling as Element;\n        const nextSibling = bestMatch?.nextSibling as Element;\n\n        // morph it\n        const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n        if (bestMatch) {\n            // if there was a best match, merge the siblings in too and return the\n            // whole bunch\n            return insertSiblings(previousSibling, morphedNode, nextSibling);\n        } else {\n            // otherwise nothing was added to the DOM\n            return [];\n        }\n    } else {\n        // console.error(`Do not understand how to morph style ${ctx.morphStyle}`);\n        throw ERR_BAD_ARGS;\n    }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n    } else if (newContent == null) {\n        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return;\n\n        oldNode.remove();\n        ctx.callbacks.afterNodeRemoved(oldNode);\n        return;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return;\n        if (ctx.callbacks.beforeNodeAdded(newContent) === false) return;\n\n        if (!oldNode.parentElement) {\n            // oldNode has no parentElement\n            throw ERR_BAD_ARGS;\n        }\n        oldNode.parentElement.replaceChild(newContent, oldNode);\n        ctx.callbacks.afterNodeAdded(newContent);\n        ctx.callbacks.afterNodeRemoved(oldNode);\n        return newContent;\n    } else {\n        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n            return;\n        }\n\n        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n            // ignore the head element\n        } else if (\n            newContent instanceof HTMLHeadElement &&\n            oldNode instanceof HTMLHeadElement &&\n            ctx.head.style !== FragmentMergeModes.Morph\n        ) {\n            handleHeadElement(newContent, oldNode, ctx);\n        } else {\n            syncNodeFrom(newContent, oldNode);\n            morphChildren(newContent, oldNode, ctx);\n        }\n        ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n        return oldNode;\n    }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n    let nextNewChild = newParent.firstChild as Element | null;\n    let insertionPoint = oldParent.firstChild as Element | null;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n        newChild = nextNewChild;\n        nextNewChild = newChild.nextSibling as Element | null;\n\n        // if we are at the end of the exiting parent's children, just append\n        if (insertionPoint == null) {\n            if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n            oldParent.appendChild(newChild);\n            ctx.callbacks.afterNodeAdded(newChild);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // if the current node has an id set match then morph\n        if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n            morphOldNodeTo(insertionPoint, newChild, ctx);\n            insertionPoint = insertionPoint.nextSibling as Element | null;\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // otherwise search forward in the existing old children for an id set match\n        let idSetMatch = findIdSetMatch(\n            newParent,\n            oldParent,\n            newChild,\n            insertionPoint,\n            ctx,\n        );\n\n        // if we found a potential match, remove the nodes until that point and morph\n        if (idSetMatch) {\n            insertionPoint = removeNodesBetween(\n                insertionPoint,\n                idSetMatch,\n                ctx,\n            );\n            morphOldNodeTo(idSetMatch, newChild, ctx);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // no id set match found, so scan forward for a soft match for the current node\n        let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx);\n\n        // if we found a soft match for the current node, morph\n        if (softMatch) {\n            insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n            morphOldNodeTo(softMatch, newChild, ctx);\n            removeIdsFromConsideration(ctx, newChild);\n            continue;\n        }\n\n        // abandon all hope of morphing, just insert the new child before the insertion point\n        // and move on\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n        removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n        let tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling as Element | null;\n        removeNode(tempNode, ctx);\n    }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n        for (const fromAttribute of from.attributes) {\n            const toAttribute = to.getAttribute(fromAttribute.name);\n            if (toAttribute !== fromAttribute.value) {\n                to.setAttribute(fromAttribute.name, fromAttribute.value);\n            }\n        }\n        for (const toAttribute of to.attributes) {\n            if (!from.hasAttribute(toAttribute.name)) {\n                to.removeAttribute(toAttribute.name);\n            }\n        }\n    }\n\n    // sync text nodes\n    if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n        if (to.nodeValue !== from.nodeValue) {\n            to.nodeValue = from.nodeValue;\n        }\n    }\n\n    // NB: many bothans died to bring us information:\n    //\n    // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n    // sync input value\n    if (\n        from instanceof HTMLInputElement && to instanceof HTMLInputElement &&\n        from.type !== \"file\"\n    ) {\n        to.value = from.value || \"\";\n        syncAttribute(from, to, \"value\");\n\n        // sync boolean attributes\n        syncAttribute(from, to, \"checked\");\n        syncAttribute(from, to, \"disabled\");\n    } else if (from instanceof HTMLOptionElement) {\n        syncAttribute(from, to, \"selected\");\n    } else if (\n        from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement\n    ) {\n        const fromValue = from.value;\n        const toValue = to.value;\n        if (fromValue !== toValue) {\n            to.value = fromValue;\n        }\n        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n            to.firstChild.nodeValue = fromValue;\n        }\n    }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n    const fAttr = from.getAttribute(attributeName);\n    const tAttr = to.getAttribute(attributeName);\n\n    if (fAttr !== tAttr) {\n        if (fAttr) {\n            to.setAttribute(attributeName, fAttr);\n        } else {\n            to.removeAttribute(attributeName);\n        }\n    }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(\n    newHeadTag: HTMLHeadElement,\n    currentHead: HTMLHeadElement,\n    ctx: any,\n) {\n    const added = [];\n    const removed = [];\n    const preserved = [];\n    const nodesToAppend = [];\n\n    const headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    const srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n        // If the current head element is in the map\n        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n        if (inNewContent || isPreserved) {\n            if (isReAppended) {\n                // remove the current version and let the new version replace it and re-execute\n                removed.push(currentHeadElt);\n            } else {\n                // this element already exists and should not be re-appended, so remove it from\n                // the new content map, preserving it in the DOM\n                srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                preserved.push(currentHeadElt);\n            }\n        } else {\n            if (headMergeStyle === FragmentMergeModes.Append) {\n                // we are appending and this existing element is not new content\n                // so if and only if it is marked for re-append do we do anything\n                if (isReAppended) {\n                    removed.push(currentHeadElt);\n                    nodesToAppend.push(currentHeadElt);\n                }\n            } else {\n                // if this is a merge, we remove this content since it is not in the new head\n                if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                    removed.push(currentHeadElt);\n                }\n            }\n        }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    // console.log('to append: ', nodesToAppend)\n\n    const promises = [];\n    for (const newNode of nodesToAppend) {\n        // console.log('adding: ', newNode)\n        const newElt = document.createRange().createContextualFragment(\n            newNode.outerHTML,\n        ).firstChild as Element | null;\n        if (!newElt) {\n            // console.error(`could not create new element from: ${newNode.outerHTML}`);\n            throw ERR_BAD_ARGS;\n        }\n        // console.log(newElt)\n        if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n            if (newElt.hasAttribute(\"href\") || newElt.hasAttribute(\"src\")) {\n                let resolver: (value: unknown) => void;\n                const promise = new Promise((resolve) => {\n                    resolver = resolve;\n                });\n                newElt.addEventListener(\"load\", function () {\n                    resolver(undefined);\n                });\n                promises.push(promise);\n            }\n            currentHead.appendChild(newElt);\n            ctx.callbacks.afterNodeAdded(newElt);\n            added.push(newElt);\n        }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n            currentHead.removeChild(removedElement);\n            ctx.callbacks.afterNodeRemoved(removedElement);\n        }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n        added: added,\n        kept: preserved,\n        removed: removed,\n    });\n    return promises;\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(\n    oldNode: Element,\n    newContent: Element,\n    config: any,\n) {\n    return {\n        target: oldNode,\n        newContent: newContent,\n        config: config,\n        morphStyle: config.morphStyle,\n        ignoreActive: config.ignoreActive,\n        idMap: createIdMap(oldNode, newContent),\n        deadIds: new Set(),\n        callbacks: Object.assign(\n            {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n            },\n            config.callbacks,\n        ),\n        head: Object.assign(\n            {\n                style: \"merge\",\n                shouldPreserve: (elt: Element) =>\n                    elt.getAttribute(\"im-preserve\") === \"true\",\n                shouldReAppend: (elt: Element) =>\n                    elt.getAttribute(\"im-re-append\") === \"true\",\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            },\n            config.head,\n        ),\n    };\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n    if (!node1 || !node2) return false;\n\n    if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n        if (node1?.id?.length && node1.id === node2.id) return true;\n\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n    }\n    return false;\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n    if (!node1 || !node2) return false;\n\n    return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n}\n\nfunction removeNodesBetween(\n    startInclusive: Element,\n    endExclusive: Element,\n    ctx: any,\n) {\n    while (startInclusive !== endExclusive) {\n        const tempNode = startInclusive;\n        startInclusive = startInclusive?.nextSibling as Element;\n        if (!tempNode) {\n            // tempNode is null\n            throw ERR_BAD_ARGS;\n        }\n        removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling as Element | null;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(\n    newContent: Element,\n    oldParent: Element,\n    newChild: Element,\n    insertionPoint: Element,\n    ctx: any,\n) {\n    // max id matches we are willing to discard in our search\n    const newChildPotentialIdCount = getIdIntersectionCount(\n        ctx,\n        newChild,\n        oldParent,\n    );\n\n    let potentialMatch: Element | null = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n        potentialMatch = insertionPoint;\n        // if there is a possibility of an id match, scan forward\n        // keep track of the potential id match count we are discarding (the\n        // newChildPotentialIdCount must be greater than this to make it likely\n        // worth it)\n        let otherMatchCount = 0;\n        while (potentialMatch != null) {\n            // If we have an id match, return the current potential match\n            if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                return potentialMatch;\n            }\n\n            // computer the other potential matches of this new content\n            otherMatchCount += getIdIntersectionCount(\n                ctx,\n                potentialMatch,\n                newContent,\n            );\n            if (otherMatchCount > newChildPotentialIdCount) {\n                // if we have more potential id matches in _other_ content, we\n                // do not have a good candidate for an id match, so return null\n                return null;\n            }\n\n            // advanced to the next old content child\n            potentialMatch = potentialMatch.nextSibling as Element | null;\n        }\n    }\n    return potentialMatch;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(\n    newContent: Element,\n    newChild: Element,\n    insertionPoint: Element,\n    ctx: any,\n) {\n    let potentialSoftMatch = insertionPoint as Element | null;\n    let nextSibling = newChild.nextSibling as Element | null;\n\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch && nextSibling) {\n        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n            // the current potential soft match has a potential id set match with the remaining new\n            // content so bail out of looking\n            return null;\n        }\n\n        // if we have a soft match with the current node, return it\n        if (isSoftMatch(newChild, potentialSoftMatch)) {\n            return potentialSoftMatch;\n        }\n\n        if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n            // the next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling as Element | null;\n\n            // If there are two future soft matches, bail to allow the siblings to soft match\n            // so that we don't consume future soft matches for the sake of the current node\n            if (siblingSoftMatchCount >= 2) {\n                return null;\n            }\n        }\n\n        // advanced to the next old content child\n        potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null;\n    }\n\n    return potentialSoftMatch;\n}\n\nconst parser = new DOMParser();\nfunction parseContent(newContent: string) {\n    // remove svgs to avoid false-positive matches on head, etc.\n    const contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n        const content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n            generatedByIdiomorphId.add(content);\n            return content;\n        } else {\n            // otherwise return the html element as the parent container\n            let Element = content.firstChild;\n            if (Element) {\n                generatedByIdiomorphId.add(Element);\n                return Element as Element;\n            } else {\n                return null;\n            }\n        }\n    } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        const responseDoc = parser.parseFromString(\n            `<body><template>${newContent}</template></body>`,\n            \"text/html\",\n        );\n        const content = responseDoc.body.querySelector(\"template\")?.content;\n        if (!content) {\n            // Content is null\n            throw ERR_NOT_FOUND;\n        }\n        generatedByIdiomorphId.add(content);\n        return content;\n    }\n}\n\nfunction normalizeContent(newContent: Element) {\n    if (newContent == null) {\n        // noinspection UnnecessaryLocalVariableJS\n        const dummyParent = document.createElement(\"div\");\n        return dummyParent;\n    } else if (generatedByIdiomorphId.has(newContent)) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return newContent;\n    } else if (newContent instanceof Node) {\n        // a single node is added as a child to a dummy parent\n        const dummyParent = document.createElement(\"div\");\n        dummyParent.append(newContent);\n        return dummyParent;\n    } else {\n        // all nodes in the array or Element collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n            dummyParent.append(elt);\n        }\n        return dummyParent;\n    }\n}\n\nfunction insertSiblings(\n    previousSibling?: Element,\n    morphedNode?: Element,\n    nextSibling?: Element,\n) {\n    const stack = [];\n    const added = [];\n    while (previousSibling) {\n        stack.push(previousSibling);\n        previousSibling = previousSibling.previousSibling as Element;\n    }\n    while (stack.length > 0) {\n        const node = stack.pop()!;\n        added.push(node); // push added preceding siblings on in order and insert\n        morphedNode?.parentElement?.insertBefore(node, morphedNode);\n    }\n    added.push(morphedNode);\n    while (nextSibling) {\n        stack.push(nextSibling);\n        added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n        nextSibling = nextSibling.nextSibling as Element;\n    }\n    while (stack.length) {\n        morphedNode?.parentElement?.insertBefore(\n            stack.pop()!,\n            morphedNode.nextSibling,\n        );\n    }\n    return added;\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n    let currentElement = newContent.firstChild as Element | null;\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n        let newScore = scoreElement(currentElement, oldNode, ctx);\n        if (newScore > score) {\n            bestElement = currentElement;\n            score = newScore;\n        }\n        currentElement = currentElement.nextSibling as Element | null;\n    }\n    return bestElement;\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n    if (isSoftMatch(node1, node2)) {\n        return 0.5 + getIdIntersectionCount(ctx, node1, node2);\n    }\n    return 0;\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n    removeIdsFromConsideration(ctx, tempNode);\n    if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n    tempNode.remove();\n    ctx.callbacks.afterNodeRemoved(tempNode);\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n    return !ctx.deadIds.has(id);\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n    return ctx.idMap.get(targetNode)?.has(id) || false;\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n    const idSet = ctx.idMap.get(node);\n    if (!idSet) return;\n    for (const id of idSet) {\n        ctx.deadIds.add(id);\n    }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n    const sourceSet = ctx.idMap.get(node1);\n    if (!sourceSet) return 0;\n\n    let matchCount = 0;\n    for (const id of sourceSet) {\n        // a potential match is an id in the source and potentialIdsSet, but\n        // that has not already been merged into the DOM\n        if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n            ++matchCount;\n        }\n    }\n    return matchCount;\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n    const nodeParent = node.parentElement;\n    // find all elements with an id property\n    const idElements = node.querySelectorAll(\"[id]\");\n    for (const elt of idElements) {\n        let current = elt as Element | null;\n        // walk up the parent hierarchy of that element, adding the id\n        // of element to the parent's id set\n        while (current !== nodeParent && !!current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the  map\n            if (idSet == null) {\n                idSet = new Set();\n                idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n            current = current.parentElement;\n        }\n    }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n    const idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:cloud-download\n// Slug: Use Server-Sent Events to fetch data from a server using the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { InitContext, WatcherPlugin } from \"../../../../engine\";\nimport {\n    DefaultFragmentMergeMode,\n    DefaultFragmentsUseViewTransitions,\n    DefaultSettleDurationMs,\n    EventTypes,\n    FragmentMergeModes,\n} from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport {\n    docWithViewTransitionAPI,\n    supportsViewTransitions,\n} from \"../../../../utils/view-transitions\";\nimport { idiomorph } from \"../../../../vendored/idiomorph\";\nimport {\n    datastarSSEEventWatcher,\n    SETTLING_CLASS,\n    SWAPPING_CLASS,\n} from \"./sseShared\";\n\nexport const MergeFragments: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.MergeFragments,\n    onGlobalInit: async (ctx) => {\n        const fragmentContainer = document.createElement(\"template\");\n        datastarSSEEventWatcher(EventTypes.MergeFragments, ({\n            fragments: fragmentsRaw = \"<div></div>\",\n            selector = \"\",\n            mergeMode = DefaultFragmentMergeMode,\n            settleDuration: settleDurationRaw = `${DefaultSettleDurationMs}`,\n            useViewTransition: useViewTransitionRaw =\n                `${DefaultFragmentsUseViewTransitions}`,\n        }) => {\n            const settleDuration = parseInt(settleDurationRaw);\n            const useViewTransition = isBoolString(useViewTransitionRaw);\n\n            fragmentContainer.innerHTML = fragmentsRaw.trim();\n            const fragments = [...fragmentContainer.content.children];\n            fragments.forEach((fragment) => {\n                if (!(fragment instanceof Element)) {\n                    // No fragments found\n                    throw ERR_BAD_ARGS;\n                }\n\n                const selectorOrID = selector ||\n                    `#${fragment.getAttribute(\"id\")}`;\n                const targets = document.querySelectorAll(selectorOrID) ||\n                    [];\n                const allTargets = [...targets];\n                if (!allTargets.length) {\n                    // No targets found\n                    throw ERR_BAD_ARGS;\n                }\n\n                if (supportsViewTransitions && useViewTransition) {\n                    docWithViewTransitionAPI.startViewTransition(() =>\n                        applyToTargets(\n                            ctx,\n                            mergeMode,\n                            settleDuration,\n                            fragment,\n                            allTargets,\n                        )\n                    );\n                } else {\n                    applyToTargets(\n                        ctx,\n                        mergeMode,\n                        settleDuration,\n                        fragment,\n                        allTargets,\n                    );\n                }\n            });\n        });\n    },\n};\n\nfunction applyToTargets(\n    ctx: InitContext,\n    mergeMode: string,\n    settleDuration: number,\n    fragment: Element,\n    capturedTargets: Element[],\n) {\n    for (const initialTarget of capturedTargets) {\n        initialTarget.classList.add(SWAPPING_CLASS);\n        const originalHTML = initialTarget.outerHTML;\n        let modifiedTarget = initialTarget;\n        switch (mergeMode) {\n            case FragmentMergeModes.Morph:\n                const result = idiomorph(\n                    modifiedTarget,\n                    fragment,\n                    {\n                        callbacks: {\n                            beforeNodeRemoved: (\n                                oldNode: Element,\n                                _: Element,\n                            ) => {\n                                ctx.cleanup(\n                                    oldNode,\n                                );\n                                return true;\n                            },\n                        },\n                    },\n                );\n                if (!result?.length) {\n                    // No morph result\n                    throw ERR_BAD_ARGS;\n                }\n                modifiedTarget = result[0] as Element;\n                break;\n            case FragmentMergeModes.Inner:\n                // Replace the contents of the target element with the response\n                modifiedTarget.innerHTML = fragment.innerHTML;\n                break;\n            case FragmentMergeModes.Outer:\n                // Replace the entire target element with the response\n                modifiedTarget.replaceWith(fragment);\n                break;\n            case FragmentMergeModes.Prepend:\n                // Insert the response before the first child of the target element\n                modifiedTarget.prepend(fragment);\n                break;\n            case FragmentMergeModes.Append:\n                // Insert the response after the last child of the target element\n                modifiedTarget.append(fragment);\n                break;\n            case FragmentMergeModes.Before:\n                // Insert the response before the target element\n                modifiedTarget.before(fragment);\n                break;\n            case FragmentMergeModes.After:\n                // Insert the response after the target element\n                modifiedTarget.after(fragment);\n                break;\n            case FragmentMergeModes.UpsertAttributes:\n                // Upsert the attributes of the target element\n                fragment.getAttributeNames().forEach(\n                    (attrName) => {\n                        const value = fragment.getAttribute(\n                            attrName,\n                        )!;\n                        modifiedTarget.setAttribute(\n                            attrName,\n                            value,\n                        );\n                    },\n                );\n                break;\n            default:\n                // Unknown merge type\n                throw ERR_BAD_ARGS;\n        }\n        ctx.cleanup(modifiedTarget);\n        modifiedTarget.classList.add(SWAPPING_CLASS);\n\n        ctx.applyPlugins(document.body);\n\n        setTimeout(() => {\n            initialTarget.classList.remove(SWAPPING_CLASS);\n            modifiedTarget.classList.remove(SWAPPING_CLASS);\n        }, settleDuration);\n\n        const revisedHTML = modifiedTarget.outerHTML;\n\n        if (originalHTML !== revisedHTML) {\n            modifiedTarget.classList.add(SETTLING_CLASS);\n            setTimeout(() => {\n                modifiedTarget.classList.remove(\n                    SETTLING_CLASS,\n                );\n            }, settleDuration);\n        }\n    }\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { InitExpressionFunction, WatcherPlugin } from \"../../../../engine\";\nimport {\n    DefaultMergeSignalsOnlyIfMissing,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { storeFromPossibleContents } from \"../../../../utils/signals\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const MergeSignals: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.MergeSignals,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(EventTypes.MergeSignals, ({\n            signals = \"{}\",\n            onlyIfMissing: onlyIfMissingRaw =\n                `${DefaultMergeSignalsOnlyIfMissing}`,\n        }) => {\n            const onlyIfMissing = isBoolString(onlyIfMissingRaw);\n            const fnContents =\n                ` return Object.assign({...ctx.store()}, ${signals})`;\n            try {\n                const fn = new Function(\n                    \"ctx\",\n                    fnContents,\n                ) as InitExpressionFunction;\n                const possibleMergeSignals = fn(ctx);\n                const actualMergeSignals = storeFromPossibleContents(\n                    ctx.store(),\n                    possibleMergeSignals,\n                    onlyIfMissing,\n                );\n                ctx.mergeSignals(actualMergeSignals);\n                ctx.applyPlugins(document.body);\n            } catch (e) {\n                console.log(fnContents);\n                console.error(e);\n                debugger;\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { WatcherPlugin } from \"../../../../engine\";\nimport {\n    DefaultFragmentsUseViewTransitions,\n    DefaultSettleDurationMs,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport {\n    docWithViewTransitionAPI,\n    supportsViewTransitions,\n} from \"../../../../utils/view-transitions\";\nimport { datastarSSEEventWatcher, SWAPPING_CLASS } from \"./sseShared\";\n\nexport const RemoveFragments: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.RemoveFragments,\n    onGlobalInit: async () => {\n        datastarSSEEventWatcher(EventTypes.RemoveFragments, ({\n            selector,\n            settleDuration: settleDurationRaw = `${DefaultSettleDurationMs}`,\n            useViewTransition: useViewTransitionRaw =\n                `${DefaultFragmentsUseViewTransitions}`,\n        }) => {\n            if (!!!selector.length) {\n                // No selector provided for remove-fragments\n                throw ERR_BAD_ARGS;\n            }\n\n            const settleDuration = parseInt(settleDurationRaw);\n            const useViewTransition = isBoolString(useViewTransitionRaw);\n            const removeTargets = document.querySelectorAll(selector);\n\n            const applyToTargets = () => {\n                for (const target of removeTargets) {\n                    target.classList.add(SWAPPING_CLASS);\n                }\n\n                setTimeout(() => {\n                    for (const target of removeTargets) {\n                        target.remove();\n                    }\n                }, settleDuration);\n            };\n\n            if (supportsViewTransitions && useViewTransition) {\n                docWithViewTransitionAPI.startViewTransition(() =>\n                    applyToTargets()\n                );\n            } else {\n                applyToTargets();\n            }\n        });\n    },\n};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { EventTypes } from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { WatcherPlugin } from \"../../../../engine/types\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const RemoveSignals: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.RemoveSignals,\n    onGlobalInit: async (ctx) => {\n        datastarSSEEventWatcher(\n            EventTypes.RemoveSignals,\n            ({ paths: pathsRaw = \"\" }) => {\n                // replace all whitespace with a single space\n                pathsRaw = pathsRaw.replaceAll(/\\s+/g, \" \");\n                if (!!!pathsRaw?.length) {\n                    // No paths provided for remove-signals\n                    throw ERR_BAD_ARGS;\n                }\n                const paths = pathsRaw.split(\" \");\n                ctx.removeSignals(...paths);\n            },\n        );\n    },\n};\n", "import { Datastar } from \"../engine\";\nimport { DeleteSSE } from \"../plugins/official/actions/backend/sseDelete\";\nimport { GetSSE } from \"../plugins/official/actions/backend/sseGet\";\nimport { PatchSSE } from \"../plugins/official/actions/backend/ssePatch\";\nimport { PostSSE } from \"../plugins/official/actions/backend/ssePost\";\nimport { PutSSE } from \"../plugins/official/actions/backend/ssePut\";\nimport { Clipboard } from \"../plugins/official/actions/dom/clipboard\";\nimport { SetAll } from \"../plugins/official/actions/logic/setAll\";\nimport { ToggleAll } from \"../plugins/official/actions/logic/toggleAll\";\nimport { ClampFit } from \"../plugins/official/actions/math/clampFit\";\nimport { ClampFitInt } from \"../plugins/official/actions/math/clampFitInt\";\nimport { Fit } from \"../plugins/official/actions/math/fit\";\nimport { FitInt } from \"../plugins/official/actions/math/fitInt\";\nimport { Indicator } from \"../plugins/official/attributes/backend/indicator\";\nimport { Bind } from \"../plugins/official/attributes/dom/bind\";\nimport { Class } from \"../plugins/official/attributes/dom/class\";\nimport { Model } from \"../plugins/official/attributes/dom/model\";\nimport { On } from \"../plugins/official/attributes/dom/on\";\nimport { Ref } from \"../plugins/official/attributes/dom/ref\";\nimport { Text } from \"../plugins/official/attributes/dom/text\";\nimport { Persist } from \"../plugins/official/attributes/storage/persist\";\nimport { ReplaceUrl } from \"../plugins/official/attributes/url/replaceUrl\";\nimport { Intersection } from \"../plugins/official/attributes/visibility/intersects\";\nimport { ScrollIntoView } from \"../plugins/official/attributes/visibility/scrollIntoView\";\nimport { Show } from \"../plugins/official/attributes/visibility/show\";\nimport { ViewTransition } from \"../plugins/official/attributes/visibility/viewTransition\";\nimport { ExecuteScript } from \"../plugins/official/watchers/backend/sseExecuteScript\";\nimport { MergeFragments } from \"../plugins/official/watchers/backend/sseMergeFragment\";\nimport { MergeSignals } from \"../plugins/official/watchers/backend/sseMergeSignals\";\nimport { RemoveFragments } from \"../plugins/official/watchers/backend/sseRemoveFragments\";\nimport { RemoveSignals } from \"../plugins/official/watchers/backend/sseRemoveSignals\";\n\nDatastar.load(\n    // attributes\n    Model,\n    Ref,\n    Indicator,\n    Bind,\n    ReplaceUrl,\n    Class,\n    On,\n    Text,\n    Persist,\n    Intersection,\n    ScrollIntoView,\n    Show,\n    ViewTransition,\n    // actions\n    DeleteSSE,\n    GetSSE,\n    PatchSSE,\n    PostSSE,\n    PutSSE,\n    Clipboard,\n    SetAll,\n    ToggleAll,\n    ClampFit,\n    ClampFitInt,\n    Fit,\n    FitInt,\n    // effects\n    MergeFragments,\n    MergeSignals,\n    RemoveFragments,\n    RemoveSignals,\n    ExecuteScript,\n);\n"],
  "mappings": "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",
  "names": ["Star", "Computed", "ctx", "store", "remoteSignals", "obj", "res", "k", "v", "storeFromPossibleContents", "currentStore", "contents", "hasIfMissing", "actual", "key", "currentValue", "Store", "groups", "whole", "ctx", "possibleMergeSignals", "actualMergeSignals", "storeFromPossibleContents", "DATASTAR", "DATASTAR_EVENT", "DATASTAR_REQUEST", "DefaultExecuteScriptAttributes", "FragmentMergeModes", "DefaultFragmentMergeMode", "EventTypes", "validJSIdentifier", "validNestedJSIdentifier", "wholePrefixSuffix", "rune", "prefix", "suffix", "nestable", "identifier", "isDatastarGeneratedID", "el", "DATASTAR", "ActionsProcessor", "wholePrefixSuffix", "action", "args", "withCtx", "x", "argsJoined", "SignalsProcessor", "wholePrefixSuffix", "groups", "signal", "method", "prefix", "parts", "methodName", "nestedSignal", "err", "code", "DATASTAR", "ERR_BAD_ARGS", "ERR_ALREADY_EXISTS", "ERR_NOT_FOUND", "ERR_NOT_ALLOWED", "ERR_METHOD_NOT_ALLOWED", "ERR_SERVICE_UNAVAILABLE", "nodeHTMLorSVGElement", "node", "scrollIntoView", "el", "opts", "shouldFocus", "ERR_NOT_FOUND", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "batch", "fn", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "ERR_BAD_ARGS", "startBatch", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "OUTDATED", "NOTIFIED", "RUNNING", "HAS_ERROR", "err", "computed", "cleanupEffect", "cleanup", "DISPOSED", "disposeEffect", "endEffect", "Effect", "finish", "DeepSignal", "getValue", "payload", "batch", "setValue", "deepSignal", "initialValue", "acc", "key", "value", "iKey", "ERR_NOT_ALLOWED", "signal", "peek", "Signal", "apply", "target", "patchItem", "targetResult", "k", "VERSION", "isPreprocessorPlugin", "p", "isWatcherPlugin", "isAttributePlugin", "isActionPlugin", "Engine", "deepSignal", "signal", "computed", "effect", "VERSION", "pluginsToLoad", "allLoadedPlugins", "plugin", "requiredPluginType", "ERR_NOT_ALLOWED", "globalInitializer", "ERR_ALREADY_EXISTS", "ERR_NOT_FOUND", "element", "removalSet", "removal", "mergeSignals", "revisedStore", "apply", "keys", "found", "key", "parts", "currentID", "subStore", "i", "part", "path", "value", "last", "current", "rootElement", "appliedProcessors", "pi", "el", "rawKey", "rawExpression", "expression", "DATASTAR", "lowerCaseTag", "r", "keyRaw", "modifiersWithArgsArr", "ERR_BAD_ARGS", "modifiersArr", "m", "label", "args", "modifier", "modifiers", "splitRegex", "processors", "processor", "expressionParts", "revisedParts", "exp", "revised", "matches", "match", "groups", "whole", "ctx", "ERR_METHOD_NOT_ALLOWED", "statements", "s", "j", "fnContent", "argumentNames", "fn", "e", "err", "store", "callback", "isSignal", "Signal", "hasChildren", "siblingOffset", "nodeHTMLorSVGElement", "ds", "Engine", "ActionsProcessor", "SignalsProcessor", "Store", "Computed", "Star", "Datastar", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "line", "field", "valueOffset", "value", "retry", "a", "b", "res", "EventStreamContentType", "DefaultRetryInterval", "LastEventId", "fetchEventSource", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "openWhenHidden", "inputFetch", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "rest", "resolve", "reject", "retries", "headers", "curRequestController", "onVisibilityChange", "create", "retryInterval", "retryTimer", "dispose", "fetch", "onopen", "response", "getBytes", "getLines", "getMessages", "id", "retry", "err", "interval", "ERR_SERVICE_UNAVAILABLE", "innerErr", "DATASTAR_SSE_EVENT", "DATASTAR", "SETTLING_CLASS", "SWAPPING_CLASS", "STARTED", "FINISHED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "isWrongContent", "err", "dispatchSSE", "type", "argsRaw", "DATASTAR_SSE_EVENT", "sendSSERequest", "method", "ctx", "url", "args", "ERR_BAD_ARGS", "onlyRemoteSignals", "headers", "DATASTAR_REQUEST", "currentStore", "store", "remoteSignals", "storeJSON", "elID", "STARTED", "urlInstance", "req", "evt", "DATASTAR", "argsRawLines", "lines", "line", "colonIndex", "key", "argLines", "value", "FINISHED", "queryParams", "revisedURL", "fetchEventSource", "DeleteSSE", "sendSSERequest", "GetSSE", "sendSSERequest", "PatchSSE", "sendSSERequest", "PostSSE", "sendSSERequest", "PutSSE", "sendSSERequest", "Clipboard", "_", "text", "ERR_NOT_ALLOWED", "SetAll", "ctx", "regexp", "newValue", "re", "name", "signal", "ToggleAll", "ctx", "regexp", "re", "name", "signal", "ClampFit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "ClampFitInt", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "Fit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "FitInt", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "INDICATOR_CLASS", "DATASTAR", "INDICATOR_LOADING_CLASS", "Indicator", "ctx", "expression", "upsertSignal", "el", "isDatastarGeneratedID", "ERR_NOT_FOUND", "signal", "watcher", "event", "type", "elID", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "kebabize", "str", "$", "ofs", "isBoolString", "Bind", "ctx", "key", "kebabize", "value", "v", "Class", "ctx", "classes", "k", "v", "classNames", "dataURIRegex", "updateModelEvents", "Model", "ctx", "el", "expression", "upsertSignal", "signalName", "ERR_BAD_ARGS", "tnl", "signalDefault", "isInput", "type", "isCheckbox", "isSelect", "isRadio", "isFile", "signal", "setInputFromSignal", "hasValue", "v", "vStr", "input", "select", "opt", "cleanupSetInputFromSignal", "setSignalFromInput", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "s", "mimeName", "nameName", "current", "selectedValues", "ERR_METHOD_NOT_ALLOWED", "parts", "customElementPrefix", "eventType", "event", "argsToMs", "args", "arg", "argsHas", "defaultValue", "debounce", "callback", "wait", "leading", "trailing", "timer", "resetTimer", "args", "throttle", "waiting", "knownOnModifiers", "lastStoreMarshalled", "On", "ctx", "el", "key", "expressionFn", "target", "callback", "evt", "debounceArgs", "wait", "argsToMs", "leading", "argsHas", "trailing", "debounce", "throttleArgs", "throttle", "evtListOpts", "attrName", "eventValues", "cb", "attr", "valid", "lowerAttr", "expr", "ERR_BAD_ARGS", "eventName", "kebabize", "rafId", "raf", "storeValue", "remoteSignals", "current", "called", "e", "targetHTML", "isEl", "Ref", "ctx", "signalName", "Text", "ctx", "el", "expressionFn", "ERR_BAD_ARGS", "res", "Persist", "ctx", "key", "DATASTAR", "expression", "keys", "parts", "part", "lastMarshalled", "storageType", "useRemote", "storeUpdateHandler", "_", "store", "remoteSignals", "newStore", "newSubstore", "subStore", "i", "lastPart", "marshalledStore", "DATASTAR_EVENT", "ReplaceUrl", "ctx", "value", "baseUrl", "url", "ONCE", "HALF", "FULL", "Intersection", "ctx", "modifiers", "options", "observer", "entries", "entry", "SMOOTH", "INSTANT", "AUTO", "HSTART", "HCENTER", "HEND", "HNEAREST", "VSTART", "VCENTER", "VEND", "VNEAREST", "FOCUS", "CENTER", "START", "END", "NEAREST", "ScrollIntoView", "el", "modifiers", "rawKey", "opts", "scrollIntoView", "Show", "ctx", "docWithViewTransitionAPI", "supportsViewTransitions", "VIEW_TRANSITION", "ViewTransition", "hasViewTransitionMeta", "node", "meta", "ctx", "supportsViewTransitions", "el", "expressionFn", "name", "elVTASTyle", "ExecuteScript", "EventTypes", "datastarSSEEventWatcher", "autoRemoveRaw", "attributesRaw", "DefaultExecuteScriptAttributes", "script", "autoRemove", "isBoolString", "ERR_BAD_ARGS", "scriptEl", "attr", "pivot", "key", "value", "generatedByIdiomorphId", "idiomorph", "oldNode", "newContent", "config", "parsedContent", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "bestMatch", "findBestNodeMatch", "ERR_NOT_FOUND", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "insertSiblings", "ERR_BAD_ARGS", "isSoftMatch", "FragmentMergeModes", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "from", "to", "type", "fromAttribute", "toAttribute", "syncAttribute", "fromValue", "toValue", "attributeName", "fAttr", "tAttr", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "newNode", "newElt", "resolver", "promise", "resolve", "removedElement", "noOp", "createIdMap", "elt", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "parser", "contentWithSvgsRemoved", "content", "Element", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "populateIdMapForNode", "idMap", "nodeParent", "idElements", "current", "oldContent", "MergeFragments", "EventTypes", "ctx", "fragmentContainer", "datastarSSEEventWatcher", "fragmentsRaw", "selector", "mergeMode", "DefaultFragmentMergeMode", "settleDurationRaw", "useViewTransitionRaw", "settleDuration", "useViewTransition", "isBoolString", "fragment", "ERR_BAD_ARGS", "selectorOrID", "allTargets", "supportsViewTransitions", "docWithViewTransitionAPI", "applyToTargets", "capturedTargets", "initialTarget", "SWAPPING_CLASS", "originalHTML", "modifiedTarget", "FragmentMergeModes", "result", "idiomorph", "oldNode", "_", "attrName", "value", "revisedHTML", "SETTLING_CLASS", "MergeSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "signals", "onlyIfMissingRaw", "onlyIfMissing", "isBoolString", "fnContents", "possibleMergeSignals", "actualMergeSignals", "storeFromPossibleContents", "e", "RemoveFragments", "EventTypes", "datastarSSEEventWatcher", "selector", "settleDurationRaw", "useViewTransitionRaw", "ERR_BAD_ARGS", "settleDuration", "useViewTransition", "isBoolString", "removeTargets", "applyToTargets", "target", "SWAPPING_CLASS", "supportsViewTransitions", "docWithViewTransitionAPI", "RemoveSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "pathsRaw", "ERR_BAD_ARGS", "paths", "Datastar", "Model", "Ref", "Indicator", "Bind", "ReplaceUrl", "Class", "On", "Text", "Persist", "Intersection", "ScrollIntoView", "Show", "ViewTransition", "DeleteSSE", "GetSSE", "PatchSSE", "PostSSE", "PutSSE", "Clipboard", "SetAll", "ToggleAll", "ClampFit", "ClampFitInt", "Fit", "FitInt", "MergeFragments", "MergeSignals", "RemoveFragments", "RemoveSignals", "ExecuteScript"]
}
