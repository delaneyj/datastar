{"version":3,"file":"datastar.js","sources":["../src/lib/dom.ts","../src/lib/external/preact-core.ts","../src/lib/external/deepsignal.ts","../src/lib/external/ts-merge-patch.ts","../src/lib/plugins/core.ts","../src/lib/core.ts","../src/lib/plugins/attributes.ts","../src/lib/external/fetch-event-source.ts","../src/lib/external/idiomorph.ts","../src/lib/plugins/visibility.ts","../src/lib/plugins/backend.ts","../src/lib/plugins/helpers.ts","../src/lib/index.ts"],"sourcesContent":["import { HTMLorSVGElement } from './types'\n\nexport function toHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return null\n  }\n  return node\n}\n","// From https://github.com/preactjs/signals/blob/main/packages/core/src/index.ts\n\nfunction cycleDetected(): never {\n  throw new Error('Cycle detected')\n}\nfunction mutationDetected(): never {\n  throw new Error('Computed cannot have side-effects')\n}\n\nconst identifier = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) {\n    throw error\n  }\n}\n\nfunction batch<T>(callback: () => T): T {\n  if (batchDepth > 0) {\n    return callback()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return callback()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\nlet untrackedDepth = 0\n\nfunction untracked<T>(callback: () => T): T {\n  if (untrackedDepth > 0) {\n    return callback()\n  }\n  const prevContext = evalContext\n  evalContext = undefined\n  untrackedDepth++\n  try {\n    return callback()\n  } finally {\n    untrackedDepth--\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         ↑     ↑\n     *        tail  node (new)\n     *               ↓\n     * { A <-> B <-> C }\n     *               ↑\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         ↑           ↑\n     *        node   ┌─── tail (evalContext._sources)\n     *         └─────│─────┐\n     *               ↓     ↓\n     * { A <-> C <-> D <-> B }\n     *                     ↑\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n// @ts-ignore internal Signal is viewed as a function\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof identifier\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore internal Signal is viewed as function\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = identifier\n\nSignal.prototype._refresh = function () {\n  return true\n}\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  const signal = this\n  return effect(function (this: Effect) {\n    const value = signal.value\n    const flag = this._flags & TRACKING\n    this._flags &= ~TRACKING\n    try {\n      fn(value)\n    } finally {\n      this._flags |= flag\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return this.value + ''\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  return this._value\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get() {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (evalContext instanceof Computed) {\n      mutationDetected()\n    }\n\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        cycleDetected()\n      }\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (let node = this._targets; node !== undefined; node = node._nextTarget) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n    }\n  },\n})\n\nfunction signal<T>(value: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (let node = target._sources; node !== undefined; node = node._nextSource) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   ↑           ↑\n   *                   │           └──────┐\n   * target._sources = A; (node is head)  │\n   *                   ↓                  │\n   * target._sources = C; (node is tail) ─┘\n   */\n  for (let node = target._sources; node !== undefined; node = node._nextSource) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         ↓\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   ↑     ↑     ↑\n       *   │     │     └ head = node\n       *   │     └ head = node\n       *   └ head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n  _compute: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(compute: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._compute = compute\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._compute()\n    if (this._flags & HAS_ERROR || this._value !== value || this._version === 0) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when the it\n    // gets its first subscriber.\n    for (let node = this._sources; node !== undefined; node = node._nextSource) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (let node = this._sources; node !== undefined; node = node._nextSource) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (let node = this._targets; node !== undefined; node = node._nextTarget) {\n      node._target._notify()\n    }\n  }\n}\n\nComputed.prototype.peek = function () {\n  if (!this._refresh()) {\n    cycleDetected()\n  }\n  if (this._flags & HAS_ERROR) {\n    throw this._value\n  }\n  return this._value\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get() {\n    if (this._flags & RUNNING) {\n      cycleDetected()\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw this._value\n    }\n    return this._value\n  },\n})\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n  readonly value: T\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n  return new Computed(compute)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup()\n    } catch (err) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw err\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (let node = effect._sources; node !== undefined; node = node._nextSource) {\n    node._source._unsubscribe(node)\n  }\n  effect._compute = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw new Error('Out-of-order effect')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\ntype EffectCleanup = () => unknown\ndeclare class Effect {\n  _compute?: () => unknown | EffectCleanup\n  _cleanup?: () => unknown\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(compute: () => unknown | EffectCleanup)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\nfunction Effect(this: Effect, compute: () => unknown | EffectCleanup) {\n  this._compute = compute\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._compute === undefined) return\n\n    const cleanup = this._compute()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup as EffectCleanup\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    cycleDetected()\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\nfunction effect(compute: () => unknown | EffectCleanup): () => void {\n  const effect = new Effect(compute)\n  try {\n    effect._callback()\n  } catch (err) {\n    effect._dispose()\n    throw err\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { Signal, batch, computed, effect, signal, untracked }\nexport type { ReadonlySignal }\n","// From https://github.com/EthanStandel/deepsignal/blob/main/packages/core/src/core.ts\nimport { Signal, batch, signal } from './preact-core'\n\nexport type AtomicState =\n  | Array<unknown>\n  | ((...args: unknown[]) => unknown)\n  | string\n  | boolean\n  | number\n  | bigint\n  | symbol\n  | undefined\n  | null\n\nexport type DeepState = {\n  [key: string]: (() => unknown) | AtomicState | DeepState\n}\n\nexport type ReadOnlyDeep<T> = {\n  readonly [P in keyof T]: ReadOnlyDeep<T[P]>\n}\n\nexport interface DeepSignalAccessors<T extends DeepState> {\n  value: ReadOnlyDeep<T>\n  peek: () => ReadOnlyDeep<T>\n}\n\nexport type DeepSignalType<T extends DeepState> = DeepSignalAccessors<T> & {\n  [K in keyof T]: T[K] extends AtomicState ? Signal<T[K]> : T[K] extends DeepState ? DeepSignalType<T[K]> : Signal<T[K]>\n}\n\nexport class DeepSignal<T extends DeepState> implements DeepSignalAccessors<T> {\n  get value(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>)\n  }\n\n  set value(payload: ReadOnlyDeep<T>) {\n    batch(() => setValue(this as DeepSignalType<T>, payload))\n  }\n\n  peek(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>, { peek: true })\n  }\n}\n\nexport const deepSignal = <T extends DeepState>(initialValue: T): DeepSignalType<T> =>\n  Object.assign(\n    new DeepSignal(),\n    Object.entries(initialValue).reduce(\n      (acc, [key, value]) => {\n        if (['value', 'peek'].some((iKey) => iKey === key)) {\n          throw new Error(`${key} is a reserved property name`)\n        } else if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n          acc[key] = signal(value)\n        } else {\n          acc[key] = deepSignal(value)\n        }\n        return acc\n      },\n      {} as { [key: string]: unknown },\n    ),\n  ) as DeepSignalType<T>\n\nconst setValue = <U extends DeepState, T extends DeepSignalType<U>>(deepSignal: T, payload: U): void =>\n  Object.keys(payload).forEach((key: keyof U) => (deepSignal[key].value = payload[key]))\n\nconst getValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  { peek = false }: { peek?: boolean } = {},\n): ReadOnlyDeep<U> =>\n  Object.entries(deepSignal).reduce(\n    (acc, [key, value]) => {\n      if (value instanceof Signal) {\n        acc[key] = peek ? value.peek() : value.value\n      } else if (value instanceof DeepSignal) {\n        acc[key] = getValue(value as DeepSignalType<DeepState>, { peek })\n      }\n      return acc\n    },\n    {} as { [key: string]: unknown },\n  ) as ReadOnlyDeep<U>\n","// From https://github.com/riagominota/ts-merge-patch/blob/main/src/index.ts\n\ntype mpObj<T> = { [k in keyof T | string | number | symbol]: any }\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): Partial<L> & Partial<R>\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): R\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): {}\nexport function apply<L, R>(target: mpObj<L>, patchItem: null): null\nexport function apply<L, R>(target: mpObj<L>, patchItem: string): string\nexport function apply<L, R>(target: mpObj<L>, patchItem: number): number\nexport function apply<L, R>(target: mpObj<L>, patchItem: undefined): undefined\nexport function apply<L, R>(target: mpObj<L>, patchItem: R[]): R[]\n\nexport function apply(target: any, patchItem: any): any {\n  /**\n   * If the patch is anything other than an object,\n   * the result will always be to replace\n   * the entire target with the entire patch.\n   */\n  if (typeof patchItem !== 'object' || Array.isArray(patchItem) || !patchItem) {\n    return patchItem //return new instance of variable\n  }\n\n  if (typeof patchItem === 'object' && patchItem.toJSON !== undefined && typeof patchItem.toJSON === 'function') {\n    return patchItem.toJSON()\n  }\n  /** Also, it is not possible to\n   * patch part of a target that is not an object,\n   * such as to replace just some of the values in an array.\n   */\n  let targetResult = target\n  if (typeof target !== 'object') {\n    //Target is empty/not an object, so basically becomes patch, minus any null valued sections (becomes {} + patch)\n    targetResult = { ...patchItem }\n  }\n\n  Object.keys(patchItem).forEach((k) => {\n    if (!targetResult.hasOwnProperty(k)) targetResult[k] = patchItem[k] //This ensure the key exists and TS can't throw a wobbly over an undefined key\n    if (patchItem[k] === null) {\n      delete targetResult[k]\n    } else {\n      targetResult[k] = apply(targetResult[k], patchItem[k])\n    }\n  })\n  return targetResult\n}\n","import { AttributeContext, AttributePlugin, Preprocessor, RegexpGroups } from '../types'\n\nconst validNestedJSIdentifier = `[a-zA-Z_$][0-9a-zA-Z_$.]+`\nfunction wholePrefixSuffix(rune: string, prefix: string, suffix: string) {\n  return new RegExp(`(?<whole>\\\\${rune}(?<${prefix}>${validNestedJSIdentifier})${suffix})`, `g`)\n}\n\n// Replacing $signal with ctx.store.signal.value`\nconst SignalProcessor: Preprocessor = {\n  regexp: wholePrefixSuffix('$', 'signal', '(?<method>\\\\([^\\\\)]*\\\\))?'),\n  replacer: (groups: RegexpGroups) => {\n    const { signal, method } = groups\n    const prefix = `ctx.store()`\n    if (!method?.length) {\n      return `${prefix}.${signal}.value`\n    }\n    const parts = signal.split('.')\n    const methodName = parts.pop()\n    const nestedSignal = parts.join('.')\n    return `${prefix}.${nestedSignal}.value.${methodName}${method}`\n  },\n}\n\n// Replacing $$action(args) with ctx.actions.action(ctx, args)\nconst ActionProcessor: Preprocessor = {\n  regexp: wholePrefixSuffix('$\\\\$', 'action', '(?<call>\\\\((?<args>.*)\\\\))?'),\n  replacer: ({ action, args }: RegexpGroups) => {\n    const withCtx = [`ctx`]\n    if (args) {\n      withCtx.push(...args.split(',').map((x) => x.trim()))\n    }\n    const argsJoined = withCtx.join(',')\n    return `ctx.actions.${action}(${argsJoined})`\n  },\n}\n\n// Replacing #foo with ctx.refs.foo\nconst RefProcessor: Preprocessor = {\n  regexp: wholePrefixSuffix('~', 'ref', ''),\n  replacer({ ref }: RegexpGroups) {\n    return `data.refs.${ref}`\n  },\n}\n\nexport const CorePreprocessors: Preprocessor[] = [ActionProcessor, SignalProcessor, RefProcessor]\n\n// Setup the global store\nconst StoreAttributePlugin: AttributePlugin = {\n  prefix: 'store',\n  preprocessors: {\n    pre: [\n      {\n        regexp: /(?<whole>.+)/g,\n        replacer: (groups: RegexpGroups) => {\n          const { whole } = groups\n          return `Object.assign({...ctx.store()}, ${whole})`\n        },\n      },\n    ],\n  },\n  onLoad: (ctx: AttributeContext) => {\n    const bodyStore = ctx.expressionFn(ctx)\n    ctx.mergeStore(bodyStore)\n    delete ctx.el.dataset.store\n  },\n}\n\n// Sets the value of the element\nconst RefPlugin: AttributePlugin = {\n  prefix: 'ref',\n  mustHaveEmptyKey: true,\n  mustNotEmptyExpression: true,\n  bypassExpressionFunctionCreation: () => true,\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expression } = ctx\n    ctx.refs[expression] = el\n    return () => delete ctx.refs[expression]\n  },\n}\n\nexport const CorePlugins: AttributePlugin[] = [StoreAttributePlugin, RefPlugin]\n","import { toHTMLorSVGElement } from './dom'\nimport { DeepSignal, DeepState, deepSignal } from './external/deepsignal'\nimport { Signal, computed, effect, signal } from './external/preact-core'\nimport { apply } from './external/ts-merge-patch'\nimport { CorePlugins, CorePreprocessors } from './plugins/core'\nimport {\n  Actions,\n  AttributeContext,\n  AttributePlugin,\n  ExpressionFunction,\n  HTMLorSVGElement,\n  OnRemovalFn,\n  Preprocessor,\n  Reactivity,\n} from './types'\n\nexport class Datastar {\n  plugins: AttributePlugin[] = []\n  store: DeepSignal<any> = deepSignal({})\n  actions: Actions = {}\n  refs: Record<string, HTMLElement> = {}\n  reactivity: Reactivity = {\n    signal,\n    computed,\n    effect,\n  }\n  parentID = ''\n  missingIDNext = 0\n  removals = new Map<Element, Set<OnRemovalFn>>()\n\n  constructor(actions: Actions = {}, ...plugins: AttributePlugin[]) {\n    this.actions = Object.assign(this.actions, actions)\n    plugins = [...CorePlugins, ...plugins]\n    if (!plugins.length) throw new Error('No plugins provided')\n\n    const allPluginPrefixes = new Set<string>()\n    for (const p of plugins) {\n      if (p.requiredPluginPrefixes) {\n        for (const requiredPluginType of p.requiredPluginPrefixes) {\n          if (!allPluginPrefixes.has(requiredPluginType)) {\n            throw new Error(`${p.prefix} requires ${requiredPluginType}`)\n          }\n        }\n      }\n\n      this.plugins.push(p)\n      allPluginPrefixes.add(p.prefix)\n    }\n  }\n\n  run() {\n    this.plugins.forEach((p) => {\n      if (p.onGlobalInit) {\n        p.onGlobalInit({\n          actions: this.actions,\n          refs: this.refs,\n          reactivity: this.reactivity,\n          mergeStore: this.mergeStore.bind(this),\n          store: this.store,\n        })\n      }\n    })\n    this.applyPlugins(document.body)\n  }\n\n  private cleanupElementRemovals(element: Element) {\n    const removalSet = this.removals.get(element)\n    if (removalSet) {\n      for (const removal of removalSet) {\n        removal()\n      }\n      this.removals.delete(element)\n    }\n  }\n\n  private mergeStore<T extends object>(patchStore: T) {\n    const revisedStore = apply(this.store.value, patchStore) as DeepState\n    this.store = deepSignal(revisedStore)\n  }\n\n  public signalByName<T>(name: string) {\n    return (this.store as any)[name] as Signal<T>\n  }\n\n  private applyPlugins(rootElement: Element) {\n    const appliedProcessors = new Set<Preprocessor>()\n\n    this.plugins.forEach((p, pi) => {\n      this.walkDownDOM(rootElement, (el) => {\n        if (!pi) this.cleanupElementRemovals(el)\n\n        for (const dsKey in el.dataset) {\n          let expression = el.dataset[dsKey] || ''\n\n          if (!dsKey.startsWith(p.prefix)) continue\n\n          if (el.id.length === 0) {\n            el.id = `ds-${this.parentID}-${this.missingIDNext++}`\n          }\n\n          appliedProcessors.clear()\n\n          if (p.allowedTagRegexps) {\n            const lowerCaseTag = el.tagName.toLowerCase()\n            const allowed = [...p.allowedTagRegexps].some((r) => lowerCaseTag.match(r))\n            if (!allowed) {\n              throw new Error(\n                `'${el.tagName}' not allowed for '${dsKey}', allowed ${[\n                  [...p.allowedTagRegexps].map((t) => `'${t}'`),\n                ].join(', ')}`,\n              )\n            }\n            // console.log(`Tag '${el.tagName}' is allowed for plugin '${dsKey}'`)\n          }\n\n          let keyRaw = dsKey.slice(p.prefix.length)\n          let [key, ...modifiersWithArgsArr] = keyRaw.split('.')\n          if (p.mustHaveEmptyKey && key.length > 0) {\n            throw new Error(`'${dsKey}' must have empty key`)\n          }\n          if (p.mustNotEmptyKey && key.length === 0) {\n            throw new Error(`'${dsKey}' must have non-empty key`)\n          }\n          if (key.length) {\n            key = key[0].toLowerCase() + key.slice(1)\n          }\n\n          const modifiersArr = modifiersWithArgsArr.map((m) => {\n            const [label, ...args] = m.split('_')\n            return { label, args }\n          })\n          if (p.allowedModifiers) {\n            for (const modifier of modifiersArr) {\n              if (!p.allowedModifiers.has(modifier.label)) {\n                throw new Error(`'${modifier.label}' is not allowed`)\n              }\n            }\n          }\n          const modifiers = new Map<string, string[]>()\n          for (const modifier of modifiersArr) {\n            modifiers.set(modifier.label, modifier.args)\n          }\n\n          if (p.mustHaveEmptyExpression && expression.length) {\n            throw new Error(`'${dsKey}' must have empty expression`)\n          }\n          if (p.mustNotEmptyExpression && !expression.length) {\n            throw new Error(`'${dsKey}' must have non-empty expression`)\n          }\n\n          const processors = [...(p.preprocessors?.pre || []), ...CorePreprocessors, ...(p.preprocessors?.post || [])]\n          for (const processor of processors) {\n            if (appliedProcessors.has(processor)) continue\n            appliedProcessors.add(processor)\n\n            const expressionParts = expression.split(';')\n            const revisedParts: string[] = []\n\n            expressionParts.forEach((exp) => {\n              let revised = exp\n              const matches = [...revised.matchAll(processor.regexp)]\n              if (matches.length) {\n                for (const match of matches) {\n                  if (!match.groups) continue\n                  const { groups } = match\n                  const { whole } = groups\n                  revised = revised.replace(whole, processor.replacer(groups))\n                }\n              }\n              revisedParts.push(revised)\n            })\n            // })\n\n            expression = revisedParts.join('; ')\n          }\n\n          const ctx: AttributeContext = {\n            store: () => this.store,\n            mergeStore: this.mergeStore.bind(this),\n            applyPlugins: this.applyPlugins.bind(this),\n            cleanupElementRemovals: this.cleanupElementRemovals.bind(this),\n            walkSignals: this.walkSignals.bind(this),\n            actions: this.actions,\n            refs: this.refs,\n            reactivity: this.reactivity,\n            el,\n            key,\n            expression,\n            expressionFn: () => {\n              throw new Error('Expression function not created')\n            },\n            modifiers,\n          }\n\n          if (!p.bypassExpressionFunctionCreation?.(ctx) && !p.mustHaveEmptyExpression && expression.length) {\n            const statements = expression.split(';').map((s) => s.trim())\n            statements[statements.length - 1] = `return ${statements[statements.length - 1]}`\n            let fnContent = `\ntry {\n${statements.map((s) => `  ${s}`).join(';\\n')}\n} catch (e) {\n  throw e\n}\n            `\n\n            // console.log(fnContent)\n            try {\n              const fn = new Function('ctx', fnContent) as ExpressionFunction\n              ctx.expressionFn = fn\n            } catch (e) {\n              throw new Error(`Error creating expression function for '${fnContent}', error: ${e}`)\n            }\n          }\n\n          const removal = p.onLoad(ctx)\n          if (removal) {\n            if (!this.removals.has(el)) {\n              this.removals.set(el, new Set())\n            }\n            this.removals.get(el)!.add(removal)\n          }\n        }\n      })\n    })\n  }\n\n  private walkSignalsStore(store: any, callback: (name: string, signal: Signal<any>) => void) {\n    const keys = Object.keys(store)\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const value = store[key]\n      const isSignal = value instanceof Signal\n      const hasChildren = typeof value === 'object' && Object.keys(value).length > 0\n\n      if (isSignal) {\n        callback(key, value)\n        continue\n      }\n\n      if (!hasChildren) continue\n\n      this.walkSignalsStore(value, callback)\n    }\n  }\n\n  private walkSignals(callback: (name: string, signal: Signal<any>) => void) {\n    this.walkSignalsStore(this.store, callback)\n  }\n\n  private walkDownDOM(element: Element | null, callback: (el: HTMLorSVGElement) => void, siblingOffset = 0) {\n    if (!element) return\n    const el = toHTMLorSVGElement(element)\n    if (!el) return\n\n    callback(el)\n\n    siblingOffset = 0\n    element = element.firstElementChild\n    while (element) {\n      this.walkDownDOM(element, callback, siblingOffset++)\n      element = element.nextElementSibling\n    }\n  }\n}\n","import { Signal } from '../external/preact-core'\nimport { AttributeContext, AttributePlugin, RegexpGroups } from '../types'\n\nconst kebabize = (str: string) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase())\n\n// Sets the value of the element\nexport const BindAttributePlugin: AttributePlugin = {\n  prefix: 'bind',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n\n  onLoad: (ctx: AttributeContext) => {\n    return ctx.reactivity.effect(async () => {\n      const key = kebabize(ctx.key)\n      const value = await ctx.expressionFn(ctx)\n      const v = `${value}`\n      if (!v || v === 'false' || v === 'null' || v === 'undefined') {\n        ctx.el.removeAttribute(key)\n      } else {\n        ctx.el.setAttribute(key, v)\n      }\n    })\n  },\n}\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst updateModelEvents = ['change', 'input', 'keydown']\n\n// Sets the value of the element\nexport const TwoWayBindingModelPlugin: AttributePlugin = {\n  prefix: 'model',\n  mustHaveEmptyKey: true,\n  preprocessors: {\n    post: [\n      {\n        regexp: /(?<whole>.+)/g,\n        replacer: (groups: RegexpGroups) => {\n          const { whole } = groups\n          return `ctx.store().${whole}`\n        },\n      },\n    ],\n  },\n  allowedTagRegexps: new Set(['input', 'textarea', 'select', 'checkbox', 'radio']),\n  // bypassExpressionFunctionCreation: () => true,\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expression } = ctx\n    const signal = ctx.expressionFn(ctx)\n    const tnl = el.tagName.toLowerCase()\n\n    if (expression.startsWith('ctx.store().ctx.store()')) {\n      throw new Error(`Model attribute on #${el.id} must have a signal name, you probably prefixed with $ by accident`)\n    }\n\n    const isInput = tnl.includes('input')\n    const isSelect = tnl.includes('select')\n    const isTextarea = tnl.includes('textarea')\n    const type = el.getAttribute('type')\n    const isCheckbox = tnl.includes('checkbox') || (isInput && type === 'checkbox')\n    const isRadio = tnl.includes('radio') || (isInput && type === 'radio')\n    const isFile = isInput && type === 'file'\n\n    if (!isInput && !isSelect && !isTextarea && !isCheckbox && !isRadio) {\n      throw new Error('Element must be input, select, textarea, checkbox or radio')\n    }\n\n    const signalName = expression.replaceAll('ctx.store().', '')\n    if (isRadio) {\n      const name = el.getAttribute('name')\n      if (!name?.length) {\n        el.setAttribute('name', signalName)\n      }\n    }\n\n    const setInputFromSignal = () => {\n      if (!signal) {\n        throw new Error(`Signal ${signalName} not found`)\n      }\n      const hasValue = 'value' in el\n      const v = signal.value\n      if (isCheckbox || isRadio) {\n        const input = el as HTMLInputElement\n        if (isCheckbox) {\n          input.checked = v\n        } else if (isRadio) {\n          // evaluate the value as string to handle any type casting\n          // automatically since the attribute has to be a string anyways\n          input.checked = `${v}` === input.value\n        }\n      } else if (isFile) {\n        // File input reading from a signal is not supported yet\n      } else if (hasValue) {\n        el.value = `${v}`\n      } else {\n        el.setAttribute('value', `${v}`)\n      }\n    }\n    const cleanupSetInputFromSignal = ctx.reactivity.effect(setInputFromSignal)\n\n    const setSignalFromInput = async () => {\n      if (isFile) {\n        return await new Promise((resolve) => {\n          const [f] = (el as any)?.files || []\n          if (!f) {\n            signal.value = ''\n            return\n          }\n          const reader = new FileReader()\n          const s = ctx.store()\n          reader.onload = () => {\n            if (typeof reader.result !== 'string') {\n              throw new Error('Unsupported type')\n            }\n\n            const match = reader.result.match(dataURIRegex)\n            if (!match?.groups) {\n              throw new Error('Invalid data URI')\n            }\n            const { mime, contents } = match.groups\n            signal.value = contents\n\n            const mimeName = `${signalName}Mime`\n            if (mimeName in s) {\n              const mimeSignal = s[`${mimeName}`] as Signal<string>\n              mimeSignal.value = mime\n            }\n          }\n          reader.onloadend = () => resolve(void 0)\n          reader.readAsDataURL(f)\n\n          const nameName = `${signalName}Name`\n          if (nameName in s) {\n            const nameSignal = s[`${nameName}`] as Signal<string>\n            nameSignal.value = f.name\n          }\n        })\n      }\n\n      const current = signal.value\n      const input = el as HTMLInputElement\n\n      if (typeof current === 'number') {\n        signal.value = Number(input.value)\n      } else if (typeof current === 'string') {\n        signal.value = input.value\n      } else if (typeof current === 'boolean') {\n        if (isCheckbox) {\n          signal.value = input.checked\n        } else {\n          signal.value = Boolean(input.value)\n        }\n      } else if (typeof current === 'undefined') {\n      } else if (typeof current === 'bigint') {\n        signal.value = BigInt(input.value)\n      } else {\n        console.log(typeof current)\n        throw new Error('Unsupported type')\n      }\n    }\n\n    const parts = el.tagName.split('-')\n    const isCustomElement = parts.length > 1\n    if (isCustomElement) {\n      const customElementPrefix = parts[0].toLowerCase()\n      updateModelEvents.forEach((eventType) => {\n        updateModelEvents.push(`${customElementPrefix}-${eventType}`)\n      })\n    }\n\n    updateModelEvents.forEach((eventType) => el.addEventListener(eventType, setSignalFromInput))\n\n    return () => {\n      cleanupSetInputFromSignal()\n      updateModelEvents.forEach((event) => el.removeEventListener(event, setSignalFromInput))\n    }\n  },\n}\n\n// Sets the textContent of the element\nexport const TextPlugin: AttributePlugin = {\n  prefix: 'text',\n  mustHaveEmptyKey: true,\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expressionFn } = ctx\n    if (!(el instanceof HTMLElement)) {\n      throw new Error('Element is not HTMLElement')\n    }\n    return ctx.reactivity.effect(() => {\n      const res = expressionFn(ctx)\n      el.textContent = `${res}`\n    })\n  },\n}\n\n// Sets the event listener of the element\nexport const EventPlugin: AttributePlugin = {\n  prefix: 'on',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n  allowedModifiers: new Set(['once', 'passive', 'capture', 'debounce', 'throttle']),\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, key, expressionFn } = ctx\n    let callback = () => {\n      expressionFn(ctx)\n    }\n\n    const debounceArgs = ctx.modifiers.get('debounce')\n    if (debounceArgs) {\n      const wait = argsToMs(debounceArgs)\n      const leading = argsHas(debounceArgs, 'leading', false)\n      const trailing = argsHas(debounceArgs, 'noTrail', true)\n      callback = debounce(callback, wait, leading, trailing)\n    }\n\n    const throttleArgs = ctx.modifiers.get('throttle')\n    if (throttleArgs) {\n      const wait = argsToMs(throttleArgs)\n      const leading = argsHas(throttleArgs, 'noLead', true)\n      const trailing = argsHas(throttleArgs, 'noTrail', true)\n      callback = throttle(callback, wait, leading, trailing)\n    }\n\n    const evtListOpts: AddEventListenerOptions = {\n      capture: true,\n      passive: false,\n      once: false,\n    }\n    if (!ctx.modifiers.has('capture')) evtListOpts.capture = false\n    if (ctx.modifiers.has('passive')) evtListOpts.passive = true\n    if (ctx.modifiers.has('once')) evtListOpts.once = true\n\n    const eventName = kebabize(key).toLowerCase()\n    switch (eventName) {\n      case 'load':\n        callback()\n        delete el.dataset.onLoad\n        return () => {}\n\n      case 'raf':\n        let rafId: number | undefined\n        const raf = () => {\n          callback()\n          rafId = requestAnimationFrame(raf)\n        }\n        requestAnimationFrame(raf)\n        delete el.dataset.onRaf\n\n        return () => {\n          if (rafId) cancelAnimationFrame(rafId)\n        }\n\n      default:\n        el.addEventListener(eventName, callback, evtListOpts)\n        return () => {\n          // console.log(`Removing event listener for ${eventName} on ${el}`)\n          el.removeEventListener(eventName, callback)\n        }\n    }\n  },\n}\n\nexport const AttributePlugins: AttributePlugin[] = [\n  BindAttributePlugin,\n  TwoWayBindingModelPlugin,\n  TextPlugin,\n  EventPlugin,\n]\n\nfunction argsToMs(args: string[] | undefined) {\n  if (!args || args?.length === 0) return 0\n\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return Number(arg.replace('ms', ''))\n    } else if (arg.endsWith('s')) {\n      return Number(arg.replace('s', '')) * 1000\n    }\n\n    try {\n      return parseFloat(arg)\n    } catch (e) {}\n  }\n\n  return 0\n}\n\nfunction argsHas(args: string[] | undefined, arg: string, defaultValue = false) {\n  if (!args) return false\n  return args.includes(arg) || defaultValue\n}\n\ntype TimerHandler = (...args: any[]) => void\n\nfunction debounce(callback: TimerHandler, wait: number, leading = false, trailing = true): TimerHandler {\n  let timer: NodeJS.Timeout | undefined\n\n  const resetTimer = () => timer && clearTimeout(timer)\n\n  return function wrapper(...args: any[]) {\n    resetTimer()\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      resetTimer()\n    }, wait)\n  }\n}\n\nfunction throttle(callback: TimerHandler, wait: number, leading = true, trailing = false): TimerHandler {\n  let waiting = false\n  let lastArgs: any[] | null = null\n\n  return function wrapper(...args: any[]) {\n    if (!waiting) {\n      waiting = true\n\n      if (leading) {\n        callback(...args)\n      } else {\n        lastArgs = args\n      }\n\n      setTimeout(() => {\n        if (trailing && lastArgs) {\n          callback(...lastArgs)\n          lastArgs = null\n        }\n        waiting = false\n      }, wait)\n    } else {\n      lastArgs = args\n    }\n  }\n}\n","// From https://github.com/Azure/fetch-event-source\n\nexport interface FetchEventSourceInit extends RequestInit {\n  /**\n   * The request headers. FetchEventSource only supports the Record<string,string> format.\n   */\n  headers?: Record<string, string>\n\n  /**\n   * Called when a response is received. Use this to validate that the response\n   * actually matches what you expect (and throw if it doesn't.) If not provided,\n   * will default to a basic validation to ensure the content-type is text/event-stream.\n   */\n  onopen?: (response: Response) => Promise<void>\n\n  /**\n   * Called when a message is received. NOTE: Unlike the default browser\n   * EventSource.onmessage, this callback is called for _all_ events,\n   * even ones with a custom `event` field.\n   */\n  onmessage?: (ev: EventSourceMessage) => void\n\n  /**\n   * Called when a response finishes. If you don't expect the server to kill\n   * the connection, you can throw an exception here and retry using onerror.\n   */\n  onclose?: () => void\n\n  /**\n   * Called when there is any error making the request / processing messages /\n   * handling callbacks etc. Use this to control the retry strategy: if the\n   * error is fatal, rethrow the error inside the callback to stop the entire\n   * operation. Otherwise, you can return an interval (in milliseconds) after\n   * which the request will automatically retry (with the last-event-id).\n   * If this callback is not specified, or it returns undefined, fetchEventSource\n   * will treat every error as retriable and will try again after 1 second.\n   */\n  onerror?: (err: any) => number | null | undefined | void\n\n  /**\n   * If true, will keep the request open even if the document is hidden.\n   * By default, fetchEventSource will close the request and reopen it\n   * automatically when the document becomes visible again.\n   */\n  openWhenHidden?: boolean\n}\n\nexport function fetchEventSource(\n  url: URL,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders }\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) {\n        create() // page is now visible again, recreate request.\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryInterval = DefaultRetryInterval\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n    const onopen = inputOnOpen ?? defaultOnOpen\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(url, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        await onopen(response)\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // store the id and send it back on the next retry:\n                  headers[LastEventId] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId]\n                }\n              },\n              (retry) => {\n                retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) ?? retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string\n  /** A string identifying the type of event described. */\n  event: string\n  /** The event data */\n  data: string\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number\n}\n\nconst EventStreamContentType = 'text/event-stream'\nconst DefaultRetryInterval = 1000\nconst LastEventId = 'last-event-id'\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\nfunction defaultOnOpen(response: Response) {\n  const contentType = response.headers.get('content-type')\n  if (!contentType?.startsWith(EventStreamContentType)) {\n    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`)\n  }\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(stream: ReadableStream<Uint8Array>, onChunk: (arr: Uint8Array) => void) {\n  const reader = stream.getReader()\n  while (true) {\n    const result = await reader.read()\n    if (result.done) {\n      break\n    }\n    onChunk(result.value)\n  }\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position // skip to next char\n        }\n\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true\n          case ControlChars.NewLine:\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + '\\n' + value : value // otherwise,\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry':\n          const retry = parseInt(value, 10)\n          if (!isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n      }\n    }\n  }\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined,\n  }\n}\n","const generatedByIdiomorphId = new WeakSet()\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(oldNode: Document | Element, newContent: string | Element, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement\n  }\n\n  let parsedContent: Element\n  if (typeof newContent === 'string') {\n    parsedContent = parseContent(newContent) as Element\n  } else {\n    parsedContent = newContent\n  }\n\n  const normalizedContent = normalizeContent(parsedContent)\n  const ctx = createMorphContext(oldNode, normalizedContent, config)\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx)\n}\n\nfunction morphNormalizedContent(oldNode: Element, normalizedNewContent: Element, ctx: any) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector('head')\n    const newHead = normalizedNewContent.querySelector('head')\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx)\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(() => {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        )\n      })\n      return\n    }\n  }\n\n  if (ctx.morphStyle === 'innerHTML') {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx)\n    return oldNode.children\n  } else if (ctx.morphStyle === 'outerHTML' || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx)\n    if (!bestMatch) {\n      throw new Error('Could not find best match')\n    }\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling as Element\n    const nextSibling = bestMatch?.nextSibling as Element\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx)\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling)\n    } else {\n      // otherwise nothing was added to the DOM\n      return []\n    }\n  } else {\n    throw 'Do not understand how to morph style ' + ctx.morphStyle\n  }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n\n    oldNode.remove()\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return\n\n    if (!oldNode.parentElement) {\n      throw new Error('oldNode has no parentElement')\n    }\n    oldNode.parentElement.replaceChild(newContent, oldNode)\n    ctx.callbacks.afterNodeAdded(newContent)\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return newContent\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      newContent instanceof HTMLHeadElement &&\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== 'morph'\n    ) {\n      handleHeadElement(newContent, oldNode, ctx)\n    } else {\n      syncNodeFrom(newContent, oldNode)\n      morphChildren(newContent, oldNode, ctx)\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent)\n    return oldNode\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n  let nextNewChild = newParent.firstChild as Element | null\n  let insertionPoint = oldParent.firstChild as Element | null\n  let newChild\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild\n    nextNewChild = newChild.nextSibling as Element | null\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n      oldParent.appendChild(newChild)\n      ctx.callbacks.afterNodeAdded(newChild)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx)\n      insertionPoint = insertionPoint.nextSibling as Element | null\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx)\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx)\n      morphOldNodeTo(idSetMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx)\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx)\n      morphOldNodeTo(softMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n    oldParent.insertBefore(newChild, insertionPoint)\n    ctx.callbacks.afterNodeAdded(newChild)\n    removeIdsFromConsideration(ctx, newChild)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling as Element | null\n    removeNode(tempNode, ctx)\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n  let type = from.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    for (const fromAttribute of from.attributes) {\n      const toAttribute = to.getAttribute(fromAttribute.name)\n      if (toAttribute !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value)\n      }\n    }\n    for (const toAttribute of to.attributes) {\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name)\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue\n    }\n  }\n\n  // NB: many bothans died to bring us information:\n  //\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n  // sync input value\n  if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n    to.value = from.value || ''\n    syncAttribute(from, to, 'value')\n\n    // sync boolean attributes\n    syncAttribute(from, to, 'checked')\n    syncAttribute(from, to, 'disabled')\n  } else if (from instanceof HTMLOptionElement) {\n    syncAttribute(from, to, 'selected')\n  } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n    const fromValue = from.value\n    const toValue = to.value\n    if (fromValue !== toValue) {\n      to.value = fromValue\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue\n    }\n  }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n  const fAttr = from.getAttribute(attributeName)\n  const tAttr = to.getAttribute(attributeName)\n\n  if (fAttr !== tAttr) {\n    if (fAttr) {\n      to.setAttribute(attributeName, fAttr)\n    } else {\n      to.removeAttribute(attributeName)\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag: HTMLHeadElement, currentHead: HTMLHeadElement, ctx: any) {\n  const added = []\n  const removed = []\n  const preserved = []\n  const nodesToAppend = []\n\n  const headMergeStyle = ctx.head.style\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map()\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild)\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML)\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt)\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt)\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt)\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML)\n        preserved.push(currentHeadElt)\n      }\n    } else {\n      if (headMergeStyle === 'append') {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt)\n          nodesToAppend.push(currentHeadElt)\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt)\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values())\n  // console.log('to append: ', nodesToAppend)\n\n  const promises = []\n  for (const newNode of nodesToAppend) {\n    // console.log('adding: ', newNode)\n    const newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild as Element | null\n    if (!newElt) {\n      throw new Error('could not create new element from: ' + newNode.outerHTML)\n    }\n    // console.log(newElt)\n    if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n      if (newElt.hasAttribute('href') || newElt.hasAttribute('src')) {\n        let resolver: (value: unknown) => void\n        const promise = new Promise((resolve) => {\n          resolver = resolve\n        })\n        newElt.addEventListener('load', function () {\n          resolver(undefined)\n        })\n        promises.push(promise)\n      }\n      currentHead.appendChild(newElt)\n      ctx.callbacks.afterNodeAdded(newElt)\n      added.push(newElt)\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement)\n      ctx.callbacks.afterNodeRemoved(removedElement)\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  })\n  return promises\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(oldNode: Element, newContent: Element, config: any) {\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: Object.assign(\n      {\n        beforeNodeAdded: noOp,\n        afterNodeAdded: noOp,\n        beforeNodeMorphed: noOp,\n        afterNodeMorphed: noOp,\n        beforeNodeRemoved: noOp,\n        afterNodeRemoved: noOp,\n      },\n      config.callbacks,\n    ),\n    head: Object.assign(\n      {\n        style: 'merge',\n        shouldPreserve: (elt: Element) => elt.getAttribute('im-preserve') === 'true',\n        shouldReAppend: (elt: Element) => elt.getAttribute('im-re-append') === 'true',\n        shouldRemove: noOp,\n        afterHeadMorphed: noOp,\n      },\n      config.head,\n    ),\n  }\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n  if (!node1 || !node2) return false\n\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1?.id?.length && node1.id === node2.id) return true\n\n    return getIdIntersectionCount(ctx, node1, node2) > 0\n  }\n  return false\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n  if (!node1 || !node2) return false\n\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n}\n\nfunction removeNodesBetween(startInclusive: Element, endExclusive: Element, ctx: any) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive\n    startInclusive = startInclusive?.nextSibling as Element\n    if (!tempNode) {\n      throw new Error('tempNode is null')\n    }\n    removeNode(tempNode, ctx)\n  }\n  removeIdsFromConsideration(ctx, endExclusive)\n  return endExclusive.nextSibling as Element | null\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent: Element, oldParent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent)\n\n  let potentialMatch: Element | null = null\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    potentialMatch = insertionPoint\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent)\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as Element | null\n    }\n  }\n  return potentialMatch\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  let potentialSoftMatch = insertionPoint as Element | null\n  let nextSibling = newChild.nextSibling as Element | null\n\n  let siblingSoftMatchCount = 0\n\n  while (potentialSoftMatch && nextSibling) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling as Element | null\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null\n  }\n\n  return potentialSoftMatch\n}\n\nconst parser = new DOMParser()\nfunction parseContent(newContent: string) {\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '')\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, 'text/html')\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      generatedByIdiomorphId.add(content)\n      return content\n    } else {\n      // otherwise return the html element as the parent container\n      let Element = content.firstChild\n      if (Element) {\n        generatedByIdiomorphId.add(Element)\n        return Element as Element\n      } else {\n        return null\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(`<body><template>${newContent}</template></body>`, 'text/html')\n    const content = responseDoc.body.querySelector('template')?.content\n    if (!content) {\n      throw new Error('content is null')\n    }\n    generatedByIdiomorphId.add(content)\n    return content\n  }\n}\n\nfunction normalizeContent(newContent: Element) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement('div')\n    return dummyParent\n  } else if (generatedByIdiomorphId.has(newContent)) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement('div')\n    dummyParent.append(newContent)\n    return dummyParent\n  } else {\n    // all nodes in the array or Element collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement('div')\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt)\n    }\n    return dummyParent\n  }\n}\n\nfunction insertSiblings(previousSibling?: Element, morphedNode?: Element, nextSibling?: Element) {\n  const stack = []\n  const added = []\n  while (previousSibling) {\n    stack.push(previousSibling)\n    previousSibling = previousSibling.previousSibling as Element\n  }\n  while (stack.length > 0) {\n    const node = stack.pop()!\n    added.push(node) // push added preceding siblings on in order and insert\n    morphedNode?.parentElement?.insertBefore(node, morphedNode)\n  }\n  added.push(morphedNode)\n  while (nextSibling) {\n    stack.push(nextSibling)\n    added.push(nextSibling) // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as Element\n  }\n  while (stack.length) {\n    morphedNode?.parentElement?.insertBefore(stack.pop()!, morphedNode.nextSibling)\n  }\n  return added\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n  let currentElement = newContent.firstChild as Element | null\n  let bestElement = currentElement\n  let score = 0\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx)\n    if (newScore > score) {\n      bestElement = currentElement\n      score = newScore\n    }\n    currentElement = currentElement.nextSibling as Element | null\n  }\n  return bestElement\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2)\n  }\n  return 0\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n  removeIdsFromConsideration(ctx, tempNode)\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return\n\n  tempNode.remove()\n  ctx.callbacks.afterNodeRemoved(tempNode)\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n  return !ctx.deadIds.has(id)\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n  return ctx.idMap.get(targetNode)?.has(id) || false\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n  const idSet = ctx.idMap.get(node)\n  if (!idSet) return\n  for (const id of idSet) {\n    ctx.deadIds.add(id)\n  }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n  const sourceSet = ctx.idMap.get(node1)\n  if (!sourceSet) return 0\n\n  let matchCount = 0\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount\n    }\n  }\n  return matchCount\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n  const nodeParent = node.parentElement\n  // find all elements with an id property\n  const idElements = node.querySelectorAll('[id]')\n  for (const elt of idElements) {\n    let current = elt as Element | null\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && !!current) {\n      let idSet = idMap.get(current)\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set()\n        idMap.set(current, idSet)\n      }\n      idSet.add(elt.id)\n      current = current.parentElement\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n  const idMap = new Map()\n  populateIdMapForNode(oldContent, idMap)\n  populateIdMapForNode(newContent, idMap)\n  return idMap\n}\n","import { toHTMLorSVGElement } from '../dom'\nimport { AttributeContext, AttributePlugin } from '../types'\n\nconst DISPLAY = 'display'\nconst NONE = 'none'\nconst IMPORTANT = 'important'\n\n// Sets the display of the element\nexport const ShowPlugin: AttributePlugin = {\n  prefix: 'show',\n  allowedModifiers: new Set([IMPORTANT]),\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, modifiers, expressionFn, reactivity } = ctx\n\n    return reactivity.effect(async () => {\n      const expressionEvaluated = await expressionFn(ctx)\n      const shouldShow = !!expressionEvaluated\n      const isImportant = modifiers.has(IMPORTANT)\n      const priority = isImportant ? IMPORTANT : undefined\n\n      if (shouldShow) {\n        if (el.style.length === 1 && el.style.display === NONE) {\n          el.style.removeProperty(DISPLAY)\n        } else {\n          el.style.setProperty(DISPLAY, '', priority)\n        }\n      } else {\n        el.style.setProperty(DISPLAY, NONE, priority)\n      }\n    })\n  },\n}\n\nconst INTERSECTS = 'intersects'\nconst ONCE = 'once'\nconst HALF = 'half'\nconst FULL = 'full'\n\n// Run expression when element intersects with viewport\nexport const IntersectionPlugin: AttributePlugin = {\n  prefix: INTERSECTS,\n  allowedModifiers: new Set([ONCE, HALF, FULL]),\n  mustHaveEmptyKey: true,\n  onLoad: (ctx: AttributeContext) => {\n    const { modifiers } = ctx\n    const options = { threshold: 0 }\n    if (modifiers.has(FULL)) options.threshold = 1\n    else if (modifiers.has(HALF)) options.threshold = 0.5\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          ctx.expressionFn(ctx)\n          if (modifiers.has(ONCE)) {\n            observer.disconnect()\n          }\n        }\n      })\n    }, options)\n\n    observer.observe(ctx.el)\n    return () => observer.disconnect()\n  },\n}\n\nconst PREPEND = 'prepend'\nconst APPEND = 'append'\nconst teleportParentErr = new Error('Target element must have a parent if using prepend or append')\n// Teleports the element to another element\nexport const TeleportPlugin: AttributePlugin = {\n  prefix: 'teleport',\n  allowedModifiers: new Set([PREPEND, APPEND]),\n  allowedTagRegexps: new Set(['template']),\n  bypassExpressionFunctionCreation: () => true,\n  onLoad: (ctx: AttributeContext) => {\n    const { el, modifiers, expression } = ctx\n    if (!(el instanceof HTMLTemplateElement)) {\n      throw new Error(`el must be a template element`)\n    }\n\n    const target = document.querySelector(expression)\n    if (!target) {\n      throw new Error(`Target element not found: ${expression}`)\n    }\n\n    if (!el.content) {\n      throw new Error('Template element must have content')\n    }\n\n    const n = el.content.cloneNode(true)\n    const nEl = toHTMLorSVGElement(n as Element)\n    if (nEl?.firstElementChild) {\n      throw new Error('Empty template')\n    }\n\n    if (modifiers.has(PREPEND)) {\n      if (!target.parentNode) throw teleportParentErr\n      target.parentNode.insertBefore(n, target)\n    } else if (modifiers.has(APPEND)) {\n      if (!target.parentNode) throw teleportParentErr\n      target.parentNode.insertBefore(n, target.nextSibling)\n    } else {\n      target.appendChild(n)\n    }\n  },\n}\n\n// Scrolls the element into view\nexport const ScrollIntoViewPlugin: AttributePlugin = {\n  prefix: 'scrollIntoView',\n  mustHaveEmptyKey: true,\n  mustHaveEmptyExpression: true,\n  allowedModifiers: new Set([\n    'smooth',\n    'instant',\n    'auto',\n    'hstart',\n    'hcenter',\n    'hend',\n    'hnearest',\n    'vstart',\n    'vcenter',\n    'vend',\n    'vnearest',\n    'focus',\n  ]),\n\n  onLoad: ({ el, modifiers }: AttributeContext) => {\n    if (!el.tabIndex) el.setAttribute('tabindex', '0')\n    const opts: ScrollIntoViewOptions = {\n      behavior: 'smooth',\n      block: 'center',\n      inline: 'center',\n    }\n    if (modifiers.has('smooth')) opts.behavior = 'smooth'\n    if (modifiers.has('instant')) opts.behavior = 'instant'\n    if (modifiers.has('auto')) opts.behavior = 'auto'\n    if (modifiers.has('hstart')) opts.inline = 'start'\n    if (modifiers.has('hcenter')) opts.inline = 'center'\n    if (modifiers.has('hend')) opts.inline = 'end'\n    if (modifiers.has('hnearest')) opts.inline = 'nearest'\n    if (modifiers.has('vstart')) opts.block = 'start'\n    if (modifiers.has('vcenter')) opts.block = 'center'\n    if (modifiers.has('vend')) opts.block = 'end'\n    if (modifiers.has('vnearest')) opts.block = 'nearest'\n\n    el.scrollIntoView(opts)\n    if (modifiers.has('focus')) el.focus()\n    delete el.dataset.focus\n    return () => el.blur()\n  },\n}\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(updateCallback: () => Promise<void> | void): ViewTransition\n}\n\nexport interface ViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport interface CSSStyleDeclaration {\n  viewTransitionName: string\n}\n\nexport const docWithViewTransitionAPI = document as unknown as DocumentSupportingViewTransitionAPI\nexport const supportsViewTransitions = !!docWithViewTransitionAPI.startViewTransition\n\n// Setup view transition api\nexport const ViewTransitionPlugin: AttributePlugin = {\n  prefix: 'viewTransition',\n  onGlobalInit() {\n    let hasViewTransitionMeta = false\n    document.head.childNodes.forEach((node) => {\n      if (node instanceof HTMLMetaElement && node.name === 'view-transition') {\n        hasViewTransitionMeta = true\n      }\n    })\n\n    if (!hasViewTransitionMeta) {\n      const meta = document.createElement('meta')\n      meta.name = 'view-transition'\n      meta.content = 'same-origin'\n      document.head.appendChild(meta)\n    }\n  },\n  onLoad: (ctx) => {\n    if (!supportsViewTransitions) {\n      console.error('Browser does not support view transitions')\n      return\n    }\n\n    return ctx.reactivity.effect(() => {\n      const { el, expressionFn } = ctx\n      let name = expressionFn(ctx)\n      if (!name) return\n\n      const elVTASTyle = el.style as unknown as CSSStyleDeclaration\n      elVTASTyle.viewTransitionName = name\n    })\n  },\n}\n\nexport const VisibilityPlugins: AttributePlugin[] = [\n  ShowPlugin,\n  IntersectionPlugin,\n  TeleportPlugin,\n  ScrollIntoViewPlugin,\n  ViewTransitionPlugin,\n]\n","import { fetchEventSource, FetchEventSourceInit } from '../external/fetch-event-source'\nimport { idiomorph } from '../external/idiomorph'\nimport { Actions, AttributeContext, AttributePlugin } from '../types'\nimport { docWithViewTransitionAPI, supportsViewTransitions } from './visibility'\n\nconst CONTENT_TYPE = 'Content-Type'\nconst DATASTAR_REQUEST = 'datastar-request'\nconst APPLICATION_JSON = 'application/json'\nconst TRUE_STRING = 'true'\nconst DATASTAR_CLASS_PREFIX = 'datastar-'\nconst EVENT_FRAGMENT = `${DATASTAR_CLASS_PREFIX}fragment`\n// const EVENT_REDIRECT = `${DATASTAR_CLASS_PREFIX}redirect`\n// const EVENT_ERROR = `${DATASTAR_CLASS_PREFIX}error`\nconst INDICATOR_CLASS = `${DATASTAR_CLASS_PREFIX}indicator`\nconst INDICATOR_LOADING_CLASS = `${INDICATOR_CLASS}-loading`\nconst SETTLING_CLASS = `${DATASTAR_CLASS_PREFIX}settling`\nconst SWAPPING_CLASS = `${DATASTAR_CLASS_PREFIX}swapping`\nconst SELECTOR_SELF_SELECTOR = 'self'\n\nconst GET = 'get',\n  POST = 'post',\n  PUT = 'put',\n  PATCH = 'patch',\n  DELETE = 'delete'\n\nexport const BackendActions: Actions = [GET, POST, PUT, PATCH, DELETE].reduce(\n  (acc, method) => {\n    acc[method] = async (ctx, urlExpression) => {\n      const da = Document as any\n      if (!da.startViewTransition) {\n        await fetcher(method, urlExpression, ctx)\n        return\n      }\n\n      new Promise((resolve) => {\n        da.startViewTransition(async () => {\n          await fetcher(method, urlExpression, ctx)\n          resolve(void 0)\n        })\n      })\n    }\n    return acc\n  },\n  {\n    isFetching: async (_, selector: string) => {\n      const indicators = document.querySelectorAll(selector)\n      return Array.from(indicators).some((indicator) => {\n        indicator.classList.contains(INDICATOR_LOADING_CLASS)\n      })\n    },\n  } as Actions,\n)\n\nconst KnowEventTypes = ['selector', 'merge', 'settle', 'fragment', 'redirect', 'error']\nconst MergeOptions = {\n  MorphElement: 'morph_element',\n  InnerElement: 'inner_element',\n  OuterElement: 'outer_element',\n  PrependElement: 'prepend_element',\n  AppendElement: 'append_element',\n  BeforeElement: 'before_element',\n  AfterElement: 'after_element',\n  DeleteElement: 'delete_element',\n  UpsertAttributes: 'upsert_attributes',\n} as const\ntype MergeOption = (typeof MergeOptions)[keyof typeof MergeOptions]\n\n// Sets the header of the fetch request\nexport const HeadersPlugin: AttributePlugin = {\n  prefix: 'header',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n\n  onLoad: (ctx) => {\n    const s = ctx.store()\n    if (!s.fetch) s.fetch = {}\n    if (!s.fetch.headers) s.fetch.headers = {}\n    const headers = s.fetch.headers\n    const key = ctx.key[0].toUpperCase() + ctx.key.slice(1)\n    headers[key] = ctx.reactivity.computed(() => ctx.expressionFn(ctx))\n    return () => {\n      delete headers[key]\n    }\n  },\n}\n\n// Sets the fetch indicator selector\nexport const FetchIndicatorPlugin: AttributePlugin = {\n  prefix: 'fetchIndicator',\n  mustHaveEmptyKey: true,\n  mustNotEmptyExpression: true,\n  onGlobalInit: () => {\n    const style = document.createElement('style')\n    style.innerHTML = `\n.${INDICATOR_CLASS}{\n opacity:0;\n transition: opacity 300ms ease-out;\n}\n.${INDICATOR_LOADING_CLASS} {\n opacity:1;\n transition: opacity 300ms ease-in;\n}\n`\n    document.head.appendChild(style)\n  },\n  onLoad: (ctx) => {\n    return ctx.reactivity.effect(() => {\n      const c = ctx.reactivity.computed(() => `${ctx.expressionFn(ctx)}`)\n      const s = ctx.store()\n      if (!s.fetch) s.fetch = {}\n      if (!s.fetch.indicatorSelectors) s.fetch.indicatorSelectors = {}\n      s.fetch.indicatorSelectors[ctx.el.id] = c\n\n      const indicator = document.querySelector(c.value)\n      if (!indicator) {\n        throw new Error(`No indicator found`)\n      }\n      indicator.classList.add(INDICATOR_CLASS)\n\n      return () => {\n        delete s.fetch.indicatorSelectors[ctx.el.id]\n      }\n    })\n  },\n}\n\n// Sets the fetch indicator selector\nexport const IsLoadingPlugin: AttributePlugin = {\n  prefix: 'isLoadingId',\n  mustNotEmptyExpression: true,\n  onLoad: (ctx) => {\n    const c = ctx.expression\n    const s = ctx.store()\n\n    if (!s.fetch) s.fetch = {}\n    if (!s.fetch.loadingIdentifiers) s.fetch.loadingIdentifiers = {}\n    s.fetch.loadingIdentifiers[ctx.el.id] = c\n\n    if (!s.isLoading) s.isLoading = ctx.reactivity.signal(new Array<string>())\n\n    return () => {\n      /* Cant get this to clean up properly, it seems to run every time the store is changed\n      // always refresh the store in callbacks\n      const s = ctx.store()\n      if (s.fetch.loadingIdentifiers) delete s.fetch.loadingIdentifiers[ctx.el.id]\n\n      if (s.isLoading) {\n        s.isLoading.value = s.isLoading.value.filter((id: string) => {\n          return id !== c\n        })\n      }\n      if (s.isLoading.value.length === 0) {\n        delete s.isLoading\n      }\n    */\n    }\n  },\n}\n\nexport const BackendPlugins: AttributePlugin[] = [HeadersPlugin, FetchIndicatorPlugin, IsLoadingPlugin]\n\nasync function fetcher(method: string, urlExpression: string, ctx: AttributeContext) {\n  const s = ctx.store()\n\n  if (!urlExpression) {\n    throw new Error(`No signal for ${method} on ${urlExpression}`)\n  }\n\n  const storeWithoutFetch = { ...s.value }\n  delete storeWithoutFetch.fetch\n  const storeJSON = JSON.stringify(storeWithoutFetch)\n\n  let hasIndicator = false,\n    loadingTarget = ctx.el\n\n  const indicatorSelector = s.fetch?.indicatorSelectors?.[loadingTarget.id] || null\n  if (indicatorSelector) {\n    const indicator = document.querySelector(indicatorSelector.value)\n    if (indicator) {\n      loadingTarget = indicator\n      loadingTarget.classList.remove(INDICATOR_CLASS)\n      loadingTarget.classList.add(INDICATOR_LOADING_CLASS)\n      hasIndicator = true\n    }\n  }\n\n  const loadingIdentifier = s.fetch?.loadingIdentifiers?.[loadingTarget.id] || null\n  if (loadingIdentifier && !s.isLoading.value.includes(loadingIdentifier)) {\n    s.isLoading.value = [...(s.isLoading.value || []), loadingIdentifier]\n  }\n\n  // console.log(`Adding ${LOADING_CLASS} to ${el.id}`)\n  const url = new URL(urlExpression, window.location.origin)\n  method = method.toUpperCase()\n  const req: FetchEventSourceInit = {\n    method,\n    headers: {\n      [CONTENT_TYPE]: APPLICATION_JSON,\n      [DATASTAR_REQUEST]: TRUE_STRING,\n    },\n    onmessage: (evt) => {\n      if (!evt.event) return\n      let fragment = '',\n        merge: MergeOption = 'morph_element',\n        selector = '',\n        settleTime = 500\n      if (!evt.event.startsWith(DATASTAR_CLASS_PREFIX)) {\n        throw new Error(`Unknown event: ${evt.event}`)\n      }\n      const isFragment = evt.event === EVENT_FRAGMENT\n\n      const lines = evt.data.trim().split('\\n')\n      let currentDatatype = ''\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i]\n        if (!line?.length) continue\n\n        const firstWord = line.split(' ', 1)[0]\n        const isDatatype = KnowEventTypes.includes(firstWord)\n        const isNewDatatype = isDatatype && firstWord !== currentDatatype\n        if (isNewDatatype) {\n          currentDatatype = firstWord\n          line = line.slice(firstWord.length + 1)\n\n          switch (currentDatatype) {\n            case 'selector':\n              selector = line\n              break\n            case 'merge':\n              merge = line as MergeOption\n              const exists = Object.values(MergeOptions).includes(merge)\n              if (!exists) {\n                throw new Error(`Unknown merge option: ${merge}`)\n              }\n              break\n            case 'settle':\n              settleTime = parseInt(line)\n              break\n            case 'fragment':\n              break\n            case 'redirect':\n              window.location.href = line\n              return\n            case 'error':\n              throw new Error(line)\n            default:\n              throw new Error(`Unknown data type`)\n          }\n        }\n\n        if (currentDatatype === 'fragment') fragment += line + '\\n'\n      }\n\n      if (isFragment) {\n        if (!fragment?.length) fragment = '<div></div>'\n        mergeHTMLFragment(ctx, selector, merge, fragment, settleTime)\n      }\n    },\n    onclose: () => {\n      // Always get a fresh store in callbacks since the reference might be stale\n      const s = ctx.store()\n      if (hasIndicator) {\n        setTimeout(() => {\n          loadingTarget.classList.remove(INDICATOR_LOADING_CLASS)\n          loadingTarget.classList.add(INDICATOR_CLASS)\n        }, 300)\n      }\n\n      if (s.isLoading && loadingIdentifier) {\n        s.isLoading.value = s.isLoading.value.filter((id: string) => {\n          return id !== loadingIdentifier\n        })\n      }\n    },\n  }\n\n  if (s.fetch?.headers?.value && req.headers) {\n    for (const key in s.fetch.headers.value) {\n      const value = s.fetch.headers.value[key]\n      req.headers[key] = value\n    }\n  }\n\n  if (method === 'GET') {\n    const queryParams = new URLSearchParams(url.search)\n    queryParams.append('datastar', storeJSON)\n    url.search = queryParams.toString()\n  } else {\n    req.body = storeJSON\n  }\n\n  await fetchEventSource(url, req)\n}\n\nconst fragContainer = document.createElement('template')\nexport function mergeHTMLFragment(\n  ctx: AttributeContext,\n  selector: string,\n  merge: MergeOption,\n  fragment: string,\n  settleTime: number,\n) {\n  const { el } = ctx\n\n  fragContainer.innerHTML = fragment.trim()\n  const frag = fragContainer.content.firstChild\n  if (!(frag instanceof Element)) {\n    throw new Error(`No fragment found`)\n  }\n\n  const useElAsTarget = selector === SELECTOR_SELF_SELECTOR\n\n  let targets: Iterable<Element>\n  if (useElAsTarget) {\n    targets = [el]\n  } else {\n    const selectorOrID = selector || `#${frag.getAttribute('id')}`\n    targets = document.querySelectorAll(selectorOrID) || []\n    if (!!!targets) {\n      throw new Error(`No targets found for ${selectorOrID}`)\n    }\n  }\n\n  const applyToTargets = () => {\n    for (const initialTarget of targets) {\n      initialTarget.classList.add(SWAPPING_CLASS)\n      const originalHTML = initialTarget.outerHTML\n      let modifiedTarget = initialTarget\n      switch (merge) {\n        case MergeOptions.MorphElement:\n          const result = idiomorph(modifiedTarget, frag)\n          if (!result?.length) {\n            throw new Error(`No morph result`)\n          }\n          const first = result[0] as Element\n          modifiedTarget = first\n          break\n        case MergeOptions.InnerElement:\n          // Replace the contents of the target element with the response\n          modifiedTarget.innerHTML = frag.innerHTML\n          break\n        case MergeOptions.OuterElement:\n          // Replace the entire target element with the response\n          modifiedTarget.replaceWith(frag)\n          break\n        case MergeOptions.PrependElement:\n          modifiedTarget.prepend(frag) //  Insert the response before the first child of the target element\n          break\n        case MergeOptions.AppendElement:\n          modifiedTarget.append(frag) //  Insert the response after the last child of the target element\n          break\n        case MergeOptions.BeforeElement:\n          modifiedTarget.before(frag) //  Insert the response before the target element\n          break\n        case MergeOptions.AfterElement:\n          modifiedTarget.after(frag) //  Insert the response after the target element\n          break\n        case MergeOptions.DeleteElement:\n          //  Deletes the target element regardless of the response\n          setTimeout(() => modifiedTarget.remove(), settleTime)\n          break\n        case MergeOptions.UpsertAttributes:\n          //  Upsert the attributes of the target element\n          frag.getAttributeNames().forEach((attrName) => {\n            const value = frag.getAttribute(attrName)!\n            modifiedTarget.setAttribute(attrName, value)\n          })\n          break\n        default:\n          throw new Error(`Unknown merge type: ${merge}`)\n      }\n      modifiedTarget.classList.add(SWAPPING_CLASS)\n\n      ctx.cleanupElementRemovals(initialTarget)\n      ctx.applyPlugins(document.body)\n\n      setTimeout(() => {\n        initialTarget.classList.remove(SWAPPING_CLASS)\n        modifiedTarget.classList.remove(SWAPPING_CLASS)\n      }, settleTime)\n\n      const revisedHTML = modifiedTarget.outerHTML\n\n      if (originalHTML !== revisedHTML) {\n        modifiedTarget.classList.add(SETTLING_CLASS)\n        setTimeout(() => {\n          modifiedTarget.classList.remove(SETTLING_CLASS)\n        }, settleTime)\n      }\n    }\n  }\n\n  if (supportsViewTransitions) {\n    docWithViewTransitionAPI.startViewTransition(() => applyToTargets())\n  } else {\n    applyToTargets()\n  }\n}\n","import { Actions } from '..'\n\nexport const HelperActions: Actions = {\n  setAll: async (ctx, regexp, newValue) => {\n    const re = new RegExp(regexp)\n    ctx.walkSignals((name, signal) => re.test(name) && (signal.value = newValue))\n  },\n  toggleAll: async (ctx, regexp) => {\n    const re = new RegExp(regexp)\n    ctx.walkSignals((name, signal) => re.test(name) && (signal.value = !signal.value))\n  },\n  clipboard: async (_, text) => {\n    if (!navigator.clipboard) throw new Error('Clipboard API not available')\n    await navigator.clipboard.writeText(text)\n  },\n}\n","export * from './core'\nexport * from './dom'\nexport * from './types'\n\nimport { version } from '../../package.json'\nimport { Datastar } from './core'\nimport { AttributePlugins, BackendActions, BackendPlugins, VisibilityPlugins } from './plugins'\nimport { HelperActions } from './plugins/helpers'\nimport { Actions, AttributePlugin } from './types'\n\nexport function runDatastarWith(actions: Actions = {}, ...plugins: AttributePlugin[]) {\n  const start = performance.now()\n  const ds = new Datastar(actions, ...plugins)\n  ds.run()\n  const end = performance.now()\n  console.log(`Datastar v${version} loaded and attached to all DOM elements in ${end - start}ms`)\n  return ds\n}\n\nexport function runDatastarWithAllPlugins(addedActions: Actions = {}, ...addedPlugins: AttributePlugin[]) {\n  const actions: Actions = Object.assign({}, HelperActions, BackendActions, addedActions)\n  const allPlugins = [...BackendPlugins, ...VisibilityPlugins, ...AttributePlugins, ...addedPlugins]\n  return runDatastarWith(actions, ...allPlugins)\n}\n\nconst winAny = window as any\nwinAny.ds = runDatastarWithAllPlugins()\nwinAny.dispatchEvent(new CustomEvent('datastar-ready'))\n"],"names":["toHTMLorSVGElement","node","cycleDetected","mutationDetected","identifier","RUNNING","NOTIFIED","OUTDATED","DISPOSED","HAS_ERROR","TRACKING","startBatch","batchDepth","endBatch","error","hasError","batchedEffect","effect","batchIteration","next","needsToRecompute","err","batch","callback","evalContext","globalVersion","addDependency","signal","Signal","value","prev","fn","flag","Computed","target","prepareSources","rollbackNode","cleanupSources","head","compute","prevContext","computed","cleanupEffect","cleanup","disposeEffect","endEffect","Effect","finish","DeepSignal","getValue","payload","setValue","deepSignal","initialValue","acc","key","iKey","peek","apply","patchItem","targetResult","k","validNestedJSIdentifier","wholePrefixSuffix","rune","prefix","suffix","SignalProcessor","groups","method","parts","methodName","nestedSignal","ActionProcessor","action","args","withCtx","x","argsJoined","RefProcessor","ref","CorePreprocessors","StoreAttributePlugin","whole","ctx","bodyStore","RefPlugin","el","expression","CorePlugins","Datastar","actions","plugins","allPluginPrefixes","p","requiredPluginType","element","removalSet","removal","patchStore","revisedStore","name","rootElement","appliedProcessors","pi","dsKey","lowerCaseTag","r","t","keyRaw","modifiersWithArgsArr","modifiersArr","m","label","modifier","modifiers","processors","processor","expressionParts","revisedParts","exp","revised","matches","match","statements","s","fnContent","e","store","keys","i","isSignal","hasChildren","siblingOffset","kebabize","str","$","ofs","BindAttributePlugin","v","dataURIRegex","updateModelEvents","TwoWayBindingModelPlugin","tnl","isInput","isSelect","isTextarea","type","isCheckbox","isRadio","isFile","signalName","setInputFromSignal","hasValue","input","cleanupSetInputFromSignal","setSignalFromInput","resolve","f","reader","mime","contents","mimeName","mimeSignal","nameName","nameSignal","current","customElementPrefix","eventType","event","TextPlugin","expressionFn","res","EventPlugin","debounceArgs","wait","argsToMs","leading","argsHas","trailing","debounce","throttleArgs","throttle","evtListOpts","eventName","rafId","raf","AttributePlugins","arg","defaultValue","timer","resetTimer","waiting","lastArgs","fetchEventSource","url","inputSignal","inputHeaders","inputOnOpen","onmessage","onclose","onerror","openWhenHidden","rest","reject","headers","EventStreamContentType","curRequestController","onVisibilityChange","create","retryInterval","DefaultRetryInterval","retryTimer","dispose","onopen","defaultOnOpen","response","getBytes","getLines","getMessages","id","LastEventId","retry","interval","innerErr","contentType","stream","onChunk","result","onLine","buffer","position","fieldLength","discardTrailingNewline","arr","concat","bufLength","lineStart","lineEnd","onId","onRetry","onMessage","message","newMessage","decoder","line","field","valueOffset","a","b","generatedByIdiomorphId","idiomorph","oldNode","newContent","config","parsedContent","parseContent","normalizedContent","normalizeContent","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","morphChildren","bestMatch","findBestNodeMatch","previousSibling","nextSibling","morphedNode","morphOldNodeTo","insertSiblings","isSoftMatch","syncNodeFrom","newParent","oldParent","nextNewChild","insertionPoint","newChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","from","to","fromAttribute","toAttribute","syncAttribute","fromValue","toValue","attributeName","fAttr","tAttr","newHeadTag","currentHead","added","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","newHeadChild","currentHeadElt","inNewContent","isReAppended","isPreserved","newNode","newElt","resolver","promise","removedElement","noOp","createIdMap","elt","node1","node2","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","parser","contentWithSvgsRemoved","content","Element","dummyParent","stack","currentElement","bestElement","score","newScore","scoreElement","isIdInConsideration","idIsWithinNode","targetNode","idSet","sourceSet","matchCount","populateIdMapForNode","idMap","nodeParent","idElements","oldContent","DISPLAY","NONE","IMPORTANT","ShowPlugin","reactivity","shouldShow","priority","INTERSECTS","ONCE","HALF","FULL","IntersectionPlugin","options","observer","entries","entry","PREPEND","APPEND","teleportParentErr","TeleportPlugin","n","ScrollIntoViewPlugin","opts","docWithViewTransitionAPI","supportsViewTransitions","ViewTransitionPlugin","hasViewTransitionMeta","meta","elVTASTyle","VisibilityPlugins","CONTENT_TYPE","DATASTAR_REQUEST","APPLICATION_JSON","TRUE_STRING","DATASTAR_CLASS_PREFIX","EVENT_FRAGMENT","INDICATOR_CLASS","INDICATOR_LOADING_CLASS","SETTLING_CLASS","SWAPPING_CLASS","SELECTOR_SELF_SELECTOR","GET","POST","PUT","PATCH","DELETE","BackendActions","urlExpression","da","fetcher","_","selector","indicators","indicator","KnowEventTypes","MergeOptions","HeadersPlugin","FetchIndicatorPlugin","style","c","IsLoadingPlugin","BackendPlugins","storeWithoutFetch","storeJSON","hasIndicator","loadingTarget","indicatorSelector","loadingIdentifier","req","evt","fragment","merge","settleTime","isFragment","lines","currentDatatype","firstWord","mergeHTMLFragment","queryParams","fragContainer","frag","useElAsTarget","targets","selectorOrID","applyToTargets","initialTarget","originalHTML","modifiedTarget","attrName","revisedHTML","HelperActions","regexp","newValue","re","text","runDatastarWith","start","ds","end","version","runDatastarWithAllPlugins","addedActions","addedPlugins","allPlugins","winAny"],"mappings":"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"}