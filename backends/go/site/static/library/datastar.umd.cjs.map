{"version":3,"file":"datastar.umd.cjs","sources":["../src/lib/dom.ts","../src/lib/external/preact-core.ts","../src/lib/external/deepsignal.ts","../src/lib/external/json-bigint.ts","../src/lib/external/ts-merge-patch.ts","../src/lib/plugins/core.ts","../src/lib/core.ts","../src/lib/plugins/attributes.ts","../src/lib/external/fetch-event-source.ts","../src/lib/external/idiomorph.ts","../src/lib/plugins/backend.ts","../src/lib/plugins/visibility.ts","../src/lib/plugins/helpers.ts","../src/lib/index.ts"],"sourcesContent":["import { HTMLorSVGElement } from './types'\n\nexport function toHTMLorSVGElement(node: Node): HTMLorSVGElement | null {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return null\n  }\n  return node\n}\n","// From https://github.com/preactjs/signals/blob/main/packages/core/src/index.ts\n\nfunction cycleDetected(): never {\n  throw new Error('Cycle detected')\n}\nfunction mutationDetected(): never {\n  throw new Error('Computed cannot have side-effects')\n}\n\nconst identifier = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) {\n    throw error\n  }\n}\n\nfunction batch<T>(callback: () => T): T {\n  if (batchDepth > 0) {\n    return callback()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return callback()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\nlet untrackedDepth = 0\n\nfunction untracked<T>(callback: () => T): T {\n  if (untrackedDepth > 0) {\n    return callback()\n  }\n  const prevContext = evalContext\n  evalContext = undefined\n  untrackedDepth++\n  try {\n    return callback()\n  } finally {\n    untrackedDepth--\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         ↑     ↑\n     *        tail  node (new)\n     *               ↓\n     * { A <-> B <-> C }\n     *               ↑\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  } else if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         ↑           ↑\n     *        node   ┌─── tail (evalContext._sources)\n     *         └─────│─────┐\n     *               ↓     ↓\n     * { A <-> C <-> D <-> B }\n     *                     ↑\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n// @ts-ignore internal Signal is viewed as a function\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof identifier\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore internal Signal is viewed as function\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = identifier\n\nSignal.prototype._refresh = function () {\n  return true\n}\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  const signal = this\n  return effect(function (this: Effect) {\n    const value = signal.value\n    const flag = this._flags & TRACKING\n    this._flags &= ~TRACKING\n    try {\n      fn(value)\n    } finally {\n      this._flags |= flag\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return this.value + ''\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  return this._value\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get() {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (evalContext instanceof Computed) {\n      mutationDetected()\n    }\n\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        cycleDetected()\n      }\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (let node = this._targets; node !== undefined; node = node._nextTarget) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n    }\n  },\n})\n\nfunction signal<T>(value: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (let node = target._sources; node !== undefined; node = node._nextSource) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   ↑           ↑\n   *                   │           └──────┐\n   * target._sources = A; (node is head)  │\n   *                   ↓                  │\n   * target._sources = C; (node is tail) ─┘\n   */\n  for (let node = target._sources; node !== undefined; node = node._nextSource) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         ↓\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   ↑     ↑     ↑\n       *   │     │     └ head = node\n       *   │     └ head = node\n       *   └ head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n  _compute: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(compute: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._compute = compute\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._compute()\n    if (this._flags & HAS_ERROR || this._value !== value || this._version === 0) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when the it\n    // gets its first subscriber.\n    for (let node = this._sources; node !== undefined; node = node._nextSource) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (let node = this._sources; node !== undefined; node = node._nextSource) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (let node = this._targets; node !== undefined; node = node._nextTarget) {\n      node._target._notify()\n    }\n  }\n}\n\nComputed.prototype.peek = function () {\n  if (!this._refresh()) {\n    cycleDetected()\n  }\n  if (this._flags & HAS_ERROR) {\n    throw this._value\n  }\n  return this._value\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get() {\n    if (this._flags & RUNNING) {\n      cycleDetected()\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw this._value\n    }\n    return this._value\n  },\n})\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n  readonly value: T\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n  return new Computed(compute)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup()\n    } catch (err) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw err\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (let node = effect._sources; node !== undefined; node = node._nextSource) {\n    node._source._unsubscribe(node)\n  }\n  effect._compute = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw new Error('Out-of-order effect')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\ntype EffectCleanup = () => unknown\ndeclare class Effect {\n  _compute?: () => unknown | EffectCleanup\n  _cleanup?: () => unknown\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(compute: () => unknown | EffectCleanup)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\nfunction Effect(this: Effect, compute: () => unknown | EffectCleanup) {\n  this._compute = compute\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._compute === undefined) return\n\n    const cleanup = this._compute()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup as EffectCleanup\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    cycleDetected()\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\nfunction effect(compute: () => unknown | EffectCleanup): () => void {\n  const effect = new Effect(compute)\n  try {\n    effect._callback()\n  } catch (err) {\n    effect._dispose()\n    throw err\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { Signal, batch, computed, effect, signal, untracked }\nexport type { ReadonlySignal }\n","// From https://github.com/EthanStandel/deepsignal/blob/main/packages/core/src/core.ts\nimport { Signal, batch, signal } from './preact-core'\n\nexport type AtomicState =\n  | Array<unknown>\n  | ((...args: unknown[]) => unknown)\n  | string\n  | boolean\n  | number\n  | bigint\n  | symbol\n  | undefined\n  | null\n\nexport type DeepState = {\n  [key: string]: (() => unknown) | AtomicState | DeepState\n}\n\nexport type ReadOnlyDeep<T> = {\n  readonly [P in keyof T]: ReadOnlyDeep<T[P]>\n}\n\nexport interface DeepSignalAccessors<T extends DeepState> {\n  value: ReadOnlyDeep<T>\n  peek: () => ReadOnlyDeep<T>\n}\n\nexport type DeepSignalType<T extends DeepState> = DeepSignalAccessors<T> & {\n  [K in keyof T]: T[K] extends AtomicState ? Signal<T[K]> : T[K] extends DeepState ? DeepSignalType<T[K]> : Signal<T[K]>\n}\n\nexport class DeepSignal<T extends DeepState> implements DeepSignalAccessors<T> {\n  get value(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>)\n  }\n\n  set value(payload: ReadOnlyDeep<T>) {\n    batch(() => setValue(this as DeepSignalType<T>, payload))\n  }\n\n  peek(): ReadOnlyDeep<T> {\n    return getValue(this as DeepSignalType<T>, { peek: true })\n  }\n}\n\nexport const deepSignal = <T extends DeepState>(initialValue: T): DeepSignalType<T> =>\n  Object.assign(\n    new DeepSignal(),\n    Object.entries(initialValue).reduce(\n      (acc, [key, value]) => {\n        if (['value', 'peek'].some((iKey) => iKey === key)) {\n          throw new Error(`${key} is a reserved property name`)\n        } else if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n          acc[key] = signal(value)\n        } else {\n          acc[key] = deepSignal(value)\n        }\n        return acc\n      },\n      {} as { [key: string]: unknown },\n    ),\n  ) as DeepSignalType<T>\n\nconst setValue = <U extends DeepState, T extends DeepSignalType<U>>(deepSignal: T, payload: U): void =>\n  Object.keys(payload).forEach((key: keyof U) => (deepSignal[key].value = payload[key]))\n\nconst getValue = <U extends DeepState, T extends DeepSignalType<U>>(\n  deepSignal: T,\n  { peek = false }: { peek?: boolean } = {},\n): ReadOnlyDeep<U> =>\n  Object.entries(deepSignal).reduce(\n    (acc, [key, value]) => {\n      if (value instanceof Signal) {\n        acc[key] = peek ? value.peek() : value.value\n      } else if (value instanceof DeepSignal) {\n        acc[key] = getValue(value as DeepSignalType<DeepState>, { peek })\n      }\n      return acc\n    },\n    {} as { [key: string]: unknown },\n  ) as ReadOnlyDeep<U>\n","// Originally from https://github.com/Ivan-Korolenko/json-with-bigint/blob/main/json-with-bigint.js\n\n// const bigInts = /([\\[:])?\"(\\d+)n\"([,\\}\\]])/g\nconst numbersBiggerThanMaxInt =\n  /([\\[:])?(\\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\\}\\]])/g\n\n/*\n  Function to serialize data to JSON string\n  Converts BigInt values to custom format (strings with \"n\" at the end) and then converts them to proper big integers in JSON string\n*/\nexport function JSONStringify<T>(data: T, space = 2): string {\n  const preliminaryJSON = JSON.stringify(\n    data,\n    (_, value) => (typeof value === 'bigint' ? value.toString() + 'n' : value),\n    space,\n  )\n  return preliminaryJSON.replace(/\"(-?\\d+)n\"/g, (_, value) => value)\n}\n\n/*\n    Function to parse JSON\n    If JSON has values presented in a lib's custom format (strings with \"n\" character at the end), we just parse them to BigInt values (for backward compatibility with previous versions of the lib)\n    If JSON has values greater than Number.MAX_SAFE_INTEGER, we convert those values to our custom format, then parse them to BigInt values.\n    Other types of values are not affected and parsed as native JSON.parse() would parse them.\n  */\nexport function JSONParse(json: string): any {\n  /*\n  Big numbers are found and marked using Regex with this condition:\n  Number's length is bigger than 16 || Number's length is 16 and any numerical digit of the number is greater than that of the Number.MAX_SAFE_INTEGER\n  */\n  const serializedData = json.replace(numbersBiggerThanMaxInt, '$1\"$2n\"$3')\n  return JSON.parse(serializedData, (_, value) => {\n    switch (typeof value) {\n      case 'number':\n        if (Number.isSafeInteger(value)) return value\n        return BigInt(value)\n      case 'string':\n        // Check if string matches bigIntString regex\n        if (value.match(/(-?\\d+)n/g)?.length) {\n          // If string matches bigIntString regex, then it's a big integer\n          // Remove \"n\" character from the end of the string and parse it to BigInt\n          return BigInt(value.slice(0, -1))\n        }\n        return value\n      default:\n        return value\n    }\n  })\n}\n","// From https://github.com/riagominota/ts-merge-patch/blob/main/src/index.ts\n\ntype mpObj<T> = { [k in keyof T | string | number | symbol]: any }\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): Partial<L> & Partial<R>\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): R\nexport function apply<L, R>(target: mpObj<L>, patchItem: mpObj<R>): {}\nexport function apply<L, R>(target: mpObj<L>, patchItem: null): null\nexport function apply<L, R>(target: mpObj<L>, patchItem: string): string\nexport function apply<L, R>(target: mpObj<L>, patchItem: number): number\nexport function apply<L, R>(target: mpObj<L>, patchItem: undefined): undefined\nexport function apply<L, R>(target: mpObj<L>, patchItem: R[]): R[]\n\nexport function apply(target: any, patchItem: any): any {\n  /**\n   * If the patch is anything other than an object,\n   * the result will always be to replace\n   * the entire target with the entire patch.\n   */\n  if (typeof patchItem !== 'object' || Array.isArray(patchItem) || !patchItem) {\n    return patchItem //return new instance of variable\n  }\n\n  if (typeof patchItem === 'object' && patchItem.toJSON !== undefined && typeof patchItem.toJSON === 'function') {\n    return patchItem.toJSON()\n  }\n  /** Also, it is not possible to\n   * patch part of a target that is not an object,\n   * such as to replace just some of the values in an array.\n   */\n  let targetResult = target\n  if (typeof target !== 'object') {\n    //Target is empty/not an object, so basically becomes patch, minus any null valued sections (becomes {} + patch)\n    targetResult = { ...patchItem }\n  }\n\n  Object.keys(patchItem).forEach((k) => {\n    if (!targetResult.hasOwnProperty(k)) targetResult[k] = patchItem[k] //This ensure the key exists and TS can't throw a wobbly over an undefined key\n    if (patchItem[k] === null) {\n      delete targetResult[k]\n    } else {\n      targetResult[k] = apply(targetResult[k], patchItem[k])\n    }\n  })\n  return targetResult\n}\n","import { AttributeContext, AttributePlugin, Preprocesser, RegexpGroups } from '../types'\n\nconst validNestedJSIdentifier = `[a-zA-Z_$][0-9a-zA-Z_$.]*`\nfunction wholePrefixSuffix(rune: string, prefix: string, suffix: string) {\n  return new RegExp(`(?<whole>\\\\${rune}(?<${prefix}>${validNestedJSIdentifier})${suffix})`, `g`)\n}\n\n// Replacing $signal with ctx.store.signal.value`\nconst SignalProcessor: Preprocesser = {\n  regexp: wholePrefixSuffix('$', 'signal', ''),\n  replacer: (groups: RegexpGroups) => {\n    const { signal } = groups\n    return `ctx.store().${signal}.value`\n  },\n}\n\n// Replacing $$action(args) with ctx.actions.action(ctx, args)\nconst ActionProcessor: Preprocesser = {\n  regexp: wholePrefixSuffix('$\\\\$', 'action', '(?<call>\\\\((?<args>.*)\\\\))?'),\n  replacer: ({ action, args }: RegexpGroups) => {\n    const withCtx = [`ctx`]\n    if (args) {\n      withCtx.push(...args.split(',').map((x) => x.trim()))\n    }\n    const argsJoined = withCtx.join(',')\n    return `ctx.actions.${action}(${argsJoined})`\n  },\n}\n\n// Replacing #foo with ctx.refs.foo\nconst RefProcessor: Preprocesser = {\n  regexp: wholePrefixSuffix('~', 'ref', ''),\n  replacer({ ref }: RegexpGroups) {\n    return `data.refs.${ref}`\n  },\n}\n\nexport const CorePreprocessors: Preprocesser[] = [ActionProcessor, SignalProcessor, RefProcessor]\n\n// Setup the global store\nconst MergeStoreAttributePlugin: AttributePlugin = {\n  prefix: 'mergeStore',\n  preprocessors: {\n    pre: [\n      {\n        // Replacing whole with JSONStringify(whole)\n        regexp: /(?<whole>.+)/g,\n        replacer: (groups: RegexpGroups) => {\n          const { whole } = groups\n\n          return `ctx.JSONParse('${whole.replace(/'/g, `\\\\'`)}')`\n        },\n      },\n    ],\n  },\n  onLoad: (ctx: AttributeContext) => {\n    const bodyStore = ctx.expressionFn(ctx)\n    ctx.mergeStore(bodyStore)\n  },\n}\n\n// Sets the value of the element\nconst RefPlugin: AttributePlugin = {\n  prefix: 'ref',\n  mustHaveEmptyKey: true,\n  mustNotEmptyExpression: true,\n  bypassExpressionFunctionCreation: () => true,\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expression } = ctx\n    ctx.refs[expression] = el\n    return () => delete ctx.refs[expression]\n  },\n}\n\nexport const CorePlugins: AttributePlugin[] = [MergeStoreAttributePlugin, RefPlugin]\n","import { toHTMLorSVGElement } from './dom'\nimport { DeepSignal, DeepState, deepSignal } from './external/deepsignal'\nimport { JSONParse, JSONStringify } from './external/json-bigint'\nimport { Signal, computed, effect, signal } from './external/preact-core'\nimport { apply } from './external/ts-merge-patch'\nimport { CorePlugins, CorePreprocessors } from './plugins/core'\nimport {\n  Actions,\n  AttributeContext,\n  AttributePlugin,\n  ExpressionFunction,\n  HTMLorSVGElement,\n  OnRemovalFn,\n  Preprocesser,\n  Reactivity,\n} from './types'\n\nexport class Datastar {\n  plugins: AttributePlugin[] = []\n  store: DeepSignal<any> = deepSignal({})\n  actions: Actions = {}\n  refs: Record<string, HTMLElement> = {}\n  reactivity: Reactivity = {\n    signal,\n    computed,\n    effect,\n  }\n  parentID = ''\n  missingIDNext = 0\n  removals = new Map<Element, Set<OnRemovalFn>>()\n\n  constructor(actions: Actions = {}, ...plugins: AttributePlugin[]) {\n    this.actions = Object.assign(this.actions, actions)\n    plugins = [...CorePlugins, ...plugins]\n    if (!plugins.length) throw new Error('no plugins')\n\n    const allPluginPrefixes = new Set<string>()\n    for (const p of plugins) {\n      if (p.requiredPluginPrefixes) {\n        for (const requiredPluginType of p.requiredPluginPrefixes) {\n          if (!allPluginPrefixes.has(requiredPluginType)) {\n            throw new Error(`${p.prefix} requires ${requiredPluginType}`)\n          }\n        }\n      }\n\n      this.plugins.push(p)\n      allPluginPrefixes.add(p.prefix)\n    }\n  }\n\n  run() {\n    this.plugins.forEach((p) => {\n      if (p.onGlobalInit) {\n        p.onGlobalInit({\n          actions: this.actions,\n          refs: this.refs,\n          reactivity: this.reactivity,\n          mergeStore: this.mergeStore.bind(this),\n          store: this.store,\n        })\n      }\n    })\n    this.applyPlugins(document.body)\n  }\n\n  public JSONStringify<T>(data: T): string {\n    return JSONStringify(data)\n  }\n\n  public JSONParse<T>(json: string): T {\n    return JSONParse(json)\n  }\n\n  private cleanupElementRemovals(element: Element) {\n    const removalSet = this.removals.get(element)\n    if (removalSet) {\n      for (const removal of removalSet) {\n        removal()\n      }\n      this.removals.delete(element)\n    }\n  }\n\n  private mergeStore<T extends object>(patchStore: T) {\n    const revisedStore = apply(this.store.value, patchStore) as DeepState\n    this.store = deepSignal(revisedStore)\n  }\n\n  public signalByName<T>(name: string) {\n    return (this.store as any)[name] as Signal<T>\n  }\n\n  private applyPlugins(rootElement: Element) {\n    const appliedProcessors = new Set<Preprocesser>()\n\n    this.plugins.forEach((p, pi) => {\n      this.walkDownDOM(rootElement, (el) => {\n        if (pi === 0) this.cleanupElementRemovals(el)\n\n        for (const dsKey in el.dataset) {\n          let expression = el.dataset[dsKey] || ''\n\n          if (!dsKey.startsWith(p.prefix)) continue\n\n          if (el.id.length === 0) {\n            el.id = `ds-${this.parentID}-${this.missingIDNext++}`\n          }\n\n          appliedProcessors.clear()\n\n          if (p.allowedTagRegexps) {\n            const lowerCaseTag = el.tagName.toLowerCase()\n            const allowed = [...p.allowedTagRegexps].some((r) => lowerCaseTag.match(r))\n            if (!allowed) {\n              throw new Error(\n                `'${el.tagName}' not allowed for '${dsKey}', allowed ${[\n                  [...p.allowedTagRegexps].map((t) => `'${t}'`),\n                ].join(', ')}`,\n              )\n            }\n            // console.log(`Tag '${el.tagName}' is allowed for plugin '${dsKey}'`)\n          }\n\n          let keyRaw = dsKey.slice(p.prefix.length)\n          let [key, ...modifiersWithArgsArr] = keyRaw.split('.')\n          if (p.mustHaveEmptyKey && key.length > 0) {\n            throw new Error(`'${dsKey}' must have empty key`)\n          }\n          if (p.mustNotEmptyKey && key.length === 0) {\n            throw new Error(`'${dsKey}' must have non-empty key`)\n          }\n          if (key.length) {\n            key = key[0].toLowerCase() + key.slice(1)\n          }\n\n          const modifiersArr = modifiersWithArgsArr.map((m) => {\n            const [label, ...args] = m.split('_')\n            return { label, args }\n          })\n          if (p.allowedModifiers) {\n            for (const modifier of modifiersArr) {\n              if (!p.allowedModifiers.has(modifier.label)) {\n                throw new Error(`'${modifier.label}' is not allowed`)\n              }\n            }\n          }\n          const modifiers = new Map<string, string[]>()\n          for (const modifier of modifiersArr) {\n            modifiers.set(modifier.label, modifier.args)\n          }\n\n          if (p.mustHaveEmptyExpression && expression.length) {\n            throw new Error(`'${dsKey}' must have empty expression`)\n          }\n          if (p.mustNotEmptyExpression && !expression.length) {\n            throw new Error(`'${dsKey}' must have non-empty expression`)\n          }\n\n          const processors = [...(p.preprocessors?.pre || []), ...CorePreprocessors, ...(p.preprocessors?.post || [])]\n          for (const processor of processors) {\n            if (appliedProcessors.has(processor)) continue\n            appliedProcessors.add(processor)\n\n            const expressionParts = expression.split(';')\n            const revisedParts: string[] = []\n\n            expressionParts.forEach((exp) => {\n              let revised = exp\n              const matches = [...revised.matchAll(processor.regexp)]\n              if (matches.length) {\n                for (const match of matches) {\n                  if (!match.groups) continue\n                  const { groups } = match\n                  const { whole } = groups\n                  revised = revised.replace(whole, processor.replacer(groups))\n                }\n              }\n              revisedParts.push(revised)\n            })\n            // })\n\n            expression = revisedParts.join('; ')\n          }\n\n          const ctx: AttributeContext = {\n            store: () => this.store,\n            mergeStore: this.mergeStore.bind(this),\n            applyPlugins: this.applyPlugins.bind(this),\n            cleanupElementRemovals: this.cleanupElementRemovals.bind(this),\n            walkSignals: this.walkSignals.bind(this),\n            actions: this.actions,\n            refs: this.refs,\n            reactivity: this.reactivity,\n            el,\n            key,\n            expression,\n            expressionFn: () => {\n              throw new Error('Expression function not created')\n            },\n            JSONParse: this.JSONParse,\n            JSONStringify: this.JSONStringify,\n            modifiers,\n          }\n\n          if (!p.bypassExpressionFunctionCreation?.(ctx) && !p.mustHaveEmptyExpression && expression.length) {\n            const statements = expression.split(';').map((s) => s.trim())\n            statements[statements.length - 1] = `return ${statements[statements.length - 1]}`\n            const fnContent = `\ntry {\n${statements.map((s) => `  ${s}`).join(';\\n')}\n} catch (e) {\n  throw e\n}\n            `\n            try {\n              const fn = new Function('ctx', fnContent) as ExpressionFunction\n              ctx.expressionFn = fn\n            } catch (e) {\n              throw new Error(`Error creating expression function for '${fnContent}'`)\n            }\n          }\n\n          const removal = p.onLoad(ctx)\n          if (removal) {\n            if (!this.removals.has(el)) {\n              this.removals.set(el, new Set())\n            }\n            this.removals.get(el)!.add(removal)\n          }\n        }\n      })\n    })\n  }\n\n  private walkSignalsStore(store: any, callback: (name: string, signal: Signal<any>) => void) {\n    const keys = Object.keys(store)\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const value = store[key]\n      const isSignal = value instanceof Signal\n      const hasChildren = typeof value === 'object' && Object.keys(value).length > 0\n\n      if (isSignal) {\n        callback(key, value)\n        continue\n      }\n\n      if (!hasChildren) continue\n\n      this.walkSignalsStore(value, callback)\n    }\n  }\n\n  private walkSignals(callback: (name: string, signal: Signal<any>) => void) {\n    this.walkSignalsStore(this.store, callback)\n  }\n\n  private walkDownDOM(element: Element | null, callback: (el: HTMLorSVGElement) => void, siblingOffset = 0) {\n    if (!element) return\n    const el = toHTMLorSVGElement(element)\n    if (!el) return\n\n    callback(el)\n\n    siblingOffset = 0\n    element = element.firstElementChild\n    while (element) {\n      this.walkDownDOM(element, callback, siblingOffset++)\n      element = element.nextElementSibling\n    }\n  }\n}\n","import { Signal } from '../external/preact-core'\nimport { AttributeContext, AttributePlugin, RegexpGroups } from '../types'\n\nconst kebabize = (str: string) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase())\n\n// Sets the value of the element\nexport const BindAttributePlugin: AttributePlugin = {\n  prefix: 'bind',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n\n  onLoad: (ctx: AttributeContext) => {\n    return ctx.reactivity.effect(() => {\n      const key = kebabize(ctx.key)\n      const value = ctx.expressionFn(ctx)\n      const v = `${value}`\n      if (!v || v === 'false' || v === 'null' || v === 'undefined') {\n        ctx.el.removeAttribute(key)\n      } else {\n        ctx.el.setAttribute(key, v)\n      }\n    })\n  },\n}\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst updateModelEvents = ['change', 'input', 'keydown']\n\n// Sets the value of the element\nexport const TwoWayBindingModelPlugin: AttributePlugin = {\n  prefix: 'model',\n  mustHaveEmptyKey: true,\n  preprocessors: {\n    post: [\n      {\n        regexp: /(?<whole>.+)/g,\n        replacer: (groups: RegexpGroups) => {\n          const { whole } = groups\n          return `ctx.store().${whole}`\n        },\n      },\n    ],\n  },\n  allowedTagRegexps: new Set(['input', 'textarea', 'select', 'checkbox', 'radio']),\n  // bypassExpressionFunctionCreation: () => true,\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expression: signalName } = ctx\n    const signal = ctx.expressionFn(ctx)\n    const tnl = el.tagName.toLowerCase()\n\n    const isInput = tnl.includes('input')\n    const isSelect = tnl.includes('select')\n    const isTextarea = tnl.includes('textarea')\n    const isRadio = tnl.includes('radio')\n    const type = el.getAttribute('type')\n    const isCheckbox = tnl.includes('checkbox') || (isInput && type === 'checkbox')\n    const isFile = isInput && type === 'file'\n\n    if (!isInput && !isSelect && !isTextarea && !isCheckbox && !isRadio) {\n      throw new Error('Element must be input, select, textarea, checkbox or radio')\n    }\n\n    const setInputFromSignal = () => {\n      if (!signal) throw new Error(`Signal ${signalName} not found`)\n      const hasValue = 'value' in el\n      const v = signal.value\n      if (isCheckbox) {\n        ;(el as HTMLInputElement).checked = v\n      } else if (isFile) {\n        // console.warn('File input reading is not supported yet')\n      } else if (hasValue) {\n        el.value = `${v}`\n      } else {\n        el.setAttribute('value', `${v}`)\n      }\n    }\n    const cleanupSetInputFromSignal = ctx.reactivity.effect(setInputFromSignal)\n\n    const setSignalFromInput = () => {\n      if (isFile) {\n        const [f] = (el as any)?.files || []\n        if (!f) {\n          signal.value = ''\n          return\n        }\n        const reader = new FileReader()\n        const s = ctx.store()\n        reader.onload = () => {\n          if (typeof reader.result !== 'string') throw new Error('Unsupported type')\n\n          const match = reader.result.match(dataURIRegex)\n          if (!match?.groups) throw new Error('Invalid data URI')\n          const { mime, contents } = match.groups\n          signal.value = contents\n\n          const mimeName = `${signalName}Mime`\n          if (mimeName in s) {\n            const mimeSignal = s[`${mimeName}`] as Signal<string>\n            mimeSignal.value = mime\n          }\n        }\n        reader.readAsDataURL(f)\n\n        const nameName = `${signalName}Name`\n        if (nameName in s) {\n          const nameSignal = s[`${nameName}`] as Signal<string>\n          nameSignal.value = f.name\n        }\n\n        return\n      }\n\n      const current = signal.value\n      const input = el as HTMLInputElement\n      if (typeof current === 'number') {\n        signal.value = Number(input.value)\n      } else if (typeof current === 'string') {\n        signal.value = input.value\n      } else if (typeof current === 'boolean') {\n        if (isCheckbox) {\n          signal.value = input.checked\n        } else {\n          signal.value = Boolean(input.value)\n        }\n      } else if (typeof current === 'undefined') {\n      } else if (typeof current === 'bigint') {\n        signal.value = BigInt(input.value)\n      } else {\n        console.log(typeof current)\n        throw new Error('Unsupported type')\n      }\n    }\n\n    const parts = el.tagName.split('-')\n    const isCustomElement = parts.length > 1\n    if (isCustomElement) {\n      const customElementPrefix = parts[0].toLowerCase()\n      updateModelEvents.forEach((eventType) => {\n        updateModelEvents.push(`${customElementPrefix}-${eventType}`)\n      })\n    }\n\n    updateModelEvents.forEach((eventType) => el.addEventListener(eventType, setSignalFromInput))\n\n    return () => {\n      cleanupSetInputFromSignal()\n      updateModelEvents.forEach((event) => el.removeEventListener(event, setSignalFromInput))\n    }\n  },\n}\n\n// Sets the textContent of the element\nexport const TextPlugin: AttributePlugin = {\n  prefix: 'text',\n  mustHaveEmptyKey: true,\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expressionFn } = ctx\n    if (!(el instanceof HTMLElement)) throw new Error('Element is not HTMLElement')\n    return ctx.reactivity.effect(() => {\n      const res = expressionFn(ctx)\n      el.textContent = `${res}`\n    })\n  },\n}\n\n// Sets the event listener of the element\nexport const EventPlugin: AttributePlugin = {\n  prefix: 'on',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n  allowedModifiers: new Set(['once', 'passive', 'capture', 'debounce', 'throttle']),\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, key, expressionFn } = ctx\n    let callback = () => {\n      expressionFn(ctx)\n    }\n\n    const debounceArgs = ctx.modifiers.get('debounce')\n    if (debounceArgs) {\n      const wait = argsToMs(debounceArgs)\n      const leading = argsHas(debounceArgs, 'leading', false)\n      const trailing = argsHas(debounceArgs, 'noTrail', true)\n      callback = debounce(callback, wait, leading, trailing)\n    }\n\n    const throttleArgs = ctx.modifiers.get('throttle')\n    if (throttleArgs) {\n      const wait = argsToMs(throttleArgs)\n      const leading = argsHas(throttleArgs, 'noLead', true)\n      const trailing = argsHas(throttleArgs, 'noTrail', true)\n      callback = throttle(callback, wait, leading, trailing)\n    }\n\n    const evtListOpts: AddEventListenerOptions = {\n      capture: true,\n      passive: false,\n      once: false,\n    }\n    if (!ctx.modifiers.has('capture')) evtListOpts.capture = false\n    if (ctx.modifiers.has('passive')) evtListOpts.passive = true\n    if (ctx.modifiers.has('once')) evtListOpts.once = true\n\n    const eventName = kebabize(key).toLowerCase()\n    if (eventName === 'load') {\n      callback()\n      return () => {}\n    }\n    el.addEventListener(eventName, callback, evtListOpts)\n    return () => el.removeEventListener(eventName, callback)\n  },\n}\n\n// Sets the focus of the element\nexport const FocusPlugin: AttributePlugin = {\n  prefix: 'focus',\n  mustHaveEmptyKey: true,\n  mustHaveEmptyExpression: true,\n\n  onLoad: (ctx: AttributeContext) => {\n    if (!ctx.el.tabIndex) {\n      ctx.el.setAttribute('tabindex', '0')\n    }\n    ctx.el.focus()\n    ctx.el.scrollIntoView({ block: 'center', inline: 'center' })\n    return () => ctx.el.blur()\n  },\n}\n\nexport const AttributePlugins: AttributePlugin[] = [\n  BindAttributePlugin,\n  TwoWayBindingModelPlugin,\n  TextPlugin,\n  FocusPlugin,\n  EventPlugin,\n]\n\nfunction argsToMs(args: string[] | undefined) {\n  if (!args || args?.length === 0) return 0\n\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return Number(arg.replace('ms', ''))\n    } else if (arg.endsWith('s')) {\n      return Number(arg.replace('s', '')) * 1000\n    }\n\n    try {\n      return parseFloat(arg)\n    } catch (e) {}\n  }\n\n  return 0\n}\n\nfunction argsHas(args: string[] | undefined, arg: string, defaultValue = false) {\n  if (!args) return false\n  return args.includes(arg) || defaultValue\n}\n\ntype TimerHandler = (...args: any[]) => void\n\nfunction debounce(callback: TimerHandler, wait: number, leading = false, trailing = true): TimerHandler {\n  let timer: NodeJS.Timeout | undefined\n\n  const resetTimer = () => timer && clearTimeout(timer)\n\n  return function wrapper(...args: any[]) {\n    resetTimer()\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      resetTimer()\n    }, wait)\n  }\n}\n\nfunction throttle(callback: TimerHandler, wait: number, leading = true, trailing = false): TimerHandler {\n  let waiting = false\n  let lastArgs: any[] | null = null\n\n  return function wrapper(...args: any[]) {\n    if (!waiting) {\n      waiting = true\n\n      if (leading) {\n        callback(...args)\n      } else {\n        lastArgs = args\n      }\n\n      setTimeout(() => {\n        if (trailing && lastArgs) {\n          callback(...lastArgs)\n          lastArgs = null\n        }\n        waiting = false\n      }, wait)\n    } else {\n      lastArgs = args\n    }\n  }\n}\n","// From https://github.com/Azure/fetch-event-source\n\nexport interface FetchEventSourceInit extends RequestInit {\n  /**\n   * The request headers. FetchEventSource only supports the Record<string,string> format.\n   */\n  headers?: Record<string, string>\n\n  /**\n   * Called when a response is received. Use this to validate that the response\n   * actually matches what you expect (and throw if it doesn't.) If not provided,\n   * will default to a basic validation to ensure the content-type is text/event-stream.\n   */\n  onopen?: (response: Response) => Promise<void>\n\n  /**\n   * Called when a message is received. NOTE: Unlike the default browser\n   * EventSource.onmessage, this callback is called for _all_ events,\n   * even ones with a custom `event` field.\n   */\n  onmessage?: (ev: EventSourceMessage) => void\n\n  /**\n   * Called when a response finishes. If you don't expect the server to kill\n   * the connection, you can throw an exception here and retry using onerror.\n   */\n  onclose?: () => void\n\n  /**\n   * Called when there is any error making the request / processing messages /\n   * handling callbacks etc. Use this to control the retry strategy: if the\n   * error is fatal, rethrow the error inside the callback to stop the entire\n   * operation. Otherwise, you can return an interval (in milliseconds) after\n   * which the request will automatically retry (with the last-event-id).\n   * If this callback is not specified, or it returns undefined, fetchEventSource\n   * will treat every error as retriable and will try again after 1 second.\n   */\n  onerror?: (err: any) => number | null | undefined | void\n\n  /**\n   * If true, will keep the request open even if the document is hidden.\n   * By default, fetchEventSource will close the request and reopen it\n   * automatically when the document becomes visible again.\n   */\n  openWhenHidden?: boolean\n}\n\nexport function fetchEventSource(\n  url: URL,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders }\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) {\n        create() // page is now visible again, recreate request.\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryInterval = DefaultRetryInterval\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n    const onopen = inputOnOpen ?? defaultOnOpen\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(url, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        await onopen(response)\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // store the id and send it back on the next retry:\n                  headers[LastEventId] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId]\n                }\n              },\n              (retry) => {\n                retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) ?? retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string\n  /** A string identifying the type of event described. */\n  event: string\n  /** The event data */\n  data: string\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number\n}\n\nconst EventStreamContentType = 'text/event-stream'\nconst DefaultRetryInterval = 1000\nconst LastEventId = 'last-event-id'\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\nfunction defaultOnOpen(response: Response) {\n  const contentType = response.headers.get('content-type')\n  if (!contentType?.startsWith(EventStreamContentType)) {\n    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`)\n  }\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(stream: ReadableStream<Uint8Array>, onChunk: (arr: Uint8Array) => void) {\n  const reader = stream.getReader()\n  while (true) {\n    const result = await reader.read()\n    if (result.done) {\n      break\n    }\n    onChunk(result.value)\n  }\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position // skip to next char\n        }\n\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true\n          case ControlChars.NewLine:\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + '\\n' + value : value // otherwise,\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry':\n          const retry = parseInt(value, 10)\n          if (!isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n      }\n    }\n  }\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined,\n  }\n}\n","const generatedByIdiomorphId = new WeakSet()\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function idiomorph(oldNode: Document | Element, newContent: string | Element, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement\n  }\n\n  let parsedContent: Element\n  if (typeof newContent === 'string') {\n    parsedContent = parseContent(newContent) as Element\n  } else {\n    parsedContent = newContent\n  }\n\n  const normalizedContent = normalizeContent(parsedContent)\n  const ctx = createMorphContext(oldNode, normalizedContent, config)\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx)\n}\n\nfunction morphNormalizedContent(oldNode: Element, normalizedNewContent: Element, ctx: any) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector('head')\n    const newHead = normalizedNewContent.querySelector('head')\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx)\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(() => {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        )\n      })\n      return\n    }\n  }\n\n  if (ctx.morphStyle === 'innerHTML') {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx)\n    return oldNode.children\n  } else if (ctx.morphStyle === 'outerHTML' || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx)\n    if (!bestMatch) throw new Error('Could not find best match')\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling as Element\n    const nextSibling = bestMatch?.nextSibling as Element\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx)\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling)\n    } else {\n      // otherwise nothing was added to the DOM\n      return []\n    }\n  } else {\n    throw 'Do not understand how to morph style ' + ctx.morphStyle\n  }\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode: Element, newContent: Element, ctx: any) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n\n    oldNode.remove()\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return\n\n    if (!oldNode.parentElement) throw new Error('oldNode has no parentElement')\n    oldNode.parentElement.replaceChild(newContent, oldNode)\n    ctx.callbacks.afterNodeAdded(newContent)\n    ctx.callbacks.afterNodeRemoved(oldNode)\n    return newContent\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      newContent instanceof HTMLHeadElement &&\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== 'morph'\n    ) {\n      handleHeadElement(newContent, oldNode, ctx)\n    } else {\n      syncNodeFrom(newContent, oldNode)\n      morphChildren(newContent, oldNode, ctx)\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent)\n    return oldNode\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent: Element, oldParent: Element, ctx: any) {\n  let nextNewChild = newParent.firstChild as Element | null\n  let insertionPoint = oldParent.firstChild as Element | null\n  let newChild\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild\n    nextNewChild = newChild.nextSibling as Element | null\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n      oldParent.appendChild(newChild)\n      ctx.callbacks.afterNodeAdded(newChild)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx)\n      insertionPoint = insertionPoint.nextSibling as Element | null\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx)\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx)\n      morphOldNodeTo(idSetMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(newParent, newChild, insertionPoint, ctx)\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx)\n      morphOldNodeTo(softMatch, newChild, ctx)\n      removeIdsFromConsideration(ctx, newChild)\n      continue\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return\n\n    oldParent.insertBefore(newChild, insertionPoint)\n    ctx.callbacks.afterNodeAdded(newChild)\n    removeIdsFromConsideration(ctx, newChild)\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling as Element | null\n    removeNode(tempNode, ctx)\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n */\nfunction syncNodeFrom(from: Element, to: Element) {\n  let type = from.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    for (const fromAttribute of from.attributes) {\n      const toAttribute = to.getAttribute(fromAttribute.name)\n      if (toAttribute !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value)\n      }\n    }\n    for (const toAttribute of to.attributes) {\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name)\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === Node.COMMENT_NODE || type === Node.TEXT_NODE) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue\n    }\n  }\n\n  // NB: many bothans died to bring us information:\n  //\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  // https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n\n  // sync input value\n  if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n    to.value = from.value || ''\n    syncAttribute(from, to, 'value')\n\n    // sync boolean attributes\n    syncAttribute(from, to, 'checked')\n    syncAttribute(from, to, 'disabled')\n  } else if (from instanceof HTMLOptionElement) {\n    syncAttribute(from, to, 'selected')\n  } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n    const fromValue = from.value\n    const toValue = to.value\n    if (fromValue !== toValue) {\n      to.value = fromValue\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue\n    }\n  }\n}\n\nfunction syncAttribute(from: Element, to: Element, attributeName: string) {\n  const fAttr = from.getAttribute(attributeName)\n  const tAttr = to.getAttribute(attributeName)\n\n  if (fAttr !== tAttr) {\n    if (fAttr) {\n      to.setAttribute(attributeName, fAttr)\n    } else {\n      to.removeAttribute(attributeName)\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag: HTMLHeadElement, currentHead: HTMLHeadElement, ctx: any) {\n  const added = []\n  const removed = []\n  const preserved = []\n  const nodesToAppend = []\n\n  const headMergeStyle = ctx.head.style\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map()\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild)\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML)\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt)\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt)\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt)\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML)\n        preserved.push(currentHeadElt)\n      }\n    } else {\n      if (headMergeStyle === 'append') {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt)\n          nodesToAppend.push(currentHeadElt)\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt)\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values())\n  // console.log('to append: ', nodesToAppend)\n\n  const promises = []\n  for (const newNode of nodesToAppend) {\n    // console.log('adding: ', newNode)\n    const newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild as Element | null\n    if (!newElt) throw new Error('could not create new element from: ' + newNode.outerHTML)\n    // console.log(newElt)\n    if (!!ctx.callbacks.beforeNodeAdded(newElt)) {\n      if (newElt.hasAttribute('href') || newElt.hasAttribute('src')) {\n        let resolver: (value: unknown) => void\n        const promise = new Promise((resolve) => {\n          resolver = resolve\n        })\n        newElt.addEventListener('load', function () {\n          resolver(undefined)\n        })\n        promises.push(promise)\n      }\n      currentHead.appendChild(newElt)\n      ctx.callbacks.afterNodeAdded(newElt)\n      added.push(newElt)\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement)\n      ctx.callbacks.afterNodeRemoved(removedElement)\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  })\n  return promises\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\nfunction noOp() {}\n\nfunction createMorphContext(oldNode: Element, newContent: Element, config: any) {\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: Object.assign(\n      {\n        beforeNodeAdded: noOp,\n        afterNodeAdded: noOp,\n        beforeNodeMorphed: noOp,\n        afterNodeMorphed: noOp,\n        beforeNodeRemoved: noOp,\n        afterNodeRemoved: noOp,\n      },\n      config.callbacks,\n    ),\n    head: Object.assign(\n      {\n        style: 'merge',\n        shouldPreserve: (elt: Element) => elt.getAttribute('im-preserve') === 'true',\n        shouldReAppend: (elt: Element) => elt.getAttribute('im-re-append') === 'true',\n        shouldRemove: noOp,\n        afterHeadMorphed: noOp,\n      },\n      config.head,\n    ),\n  }\n}\n\nfunction isIdSetMatch(node1: Element, node2: Element, ctx: any) {\n  if (!node1 || !node2) return false\n\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1?.id?.length && node1.id === node2.id) return true\n\n    return getIdIntersectionCount(ctx, node1, node2) > 0\n  }\n  return false\n}\n\nfunction isSoftMatch(node1: Element, node2: Element) {\n  if (!node1 || !node2) return false\n\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n}\n\nfunction removeNodesBetween(startInclusive: Element, endExclusive: Element, ctx: any) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive\n    startInclusive = startInclusive?.nextSibling as Element\n    if (!tempNode) throw new Error('tempNode is null')\n    removeNode(tempNode, ctx)\n  }\n  removeIdsFromConsideration(ctx, endExclusive)\n  return endExclusive.nextSibling as Element | null\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent: Element, oldParent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent)\n\n  let potentialMatch: Element | null = null\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    potentialMatch = insertionPoint\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent)\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as Element | null\n    }\n  }\n  return potentialMatch\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent: Element, newChild: Element, insertionPoint: Element, ctx: any) {\n  let potentialSoftMatch = insertionPoint as Element | null\n  let nextSibling = newChild.nextSibling as Element | null\n\n  let siblingSoftMatchCount = 0\n\n  while (potentialSoftMatch && nextSibling) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling as Element | null\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as Element | null\n  }\n\n  return potentialSoftMatch\n}\n\nconst parser = new DOMParser()\nfunction parseContent(newContent: string) {\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '')\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, 'text/html')\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      generatedByIdiomorphId.add(content)\n      return content\n    } else {\n      // otherwise return the html element as the parent container\n      let Element = content.firstChild\n      if (Element) {\n        generatedByIdiomorphId.add(Element)\n        return Element as Element\n      } else {\n        return null\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(`<body><template>${newContent}</template></body>`, 'text/html')\n    const content = responseDoc.body.querySelector('template')?.content\n    if (!content) throw new Error('content is null')\n    generatedByIdiomorphId.add(content)\n    return content\n  }\n}\n\nfunction normalizeContent(newContent: Element) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement('div')\n    return dummyParent\n  } else if (generatedByIdiomorphId.has(newContent)) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement('div')\n    dummyParent.append(newContent)\n    return dummyParent\n  } else {\n    // all nodes in the array or Element collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement('div')\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt)\n    }\n    return dummyParent\n  }\n}\n\nfunction insertSiblings(previousSibling?: Element, morphedNode?: Element, nextSibling?: Element) {\n  const stack = []\n  const added = []\n  while (previousSibling) {\n    stack.push(previousSibling)\n    previousSibling = previousSibling.previousSibling as Element\n  }\n  while (stack.length > 0) {\n    const node = stack.pop()!\n    added.push(node) // push added preceding siblings on in order and insert\n    morphedNode?.parentElement?.insertBefore(node, morphedNode)\n  }\n  added.push(morphedNode)\n  while (nextSibling) {\n    stack.push(nextSibling)\n    added.push(nextSibling) // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as Element\n  }\n  while (stack.length) {\n    morphedNode?.parentElement?.insertBefore(stack.pop()!, morphedNode.nextSibling)\n  }\n  return added\n}\n\nfunction findBestNodeMatch(newContent: Element, oldNode: Element, ctx: any) {\n  let currentElement = newContent.firstChild as Element | null\n  let bestElement = currentElement\n  let score = 0\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx)\n    if (newScore > score) {\n      bestElement = currentElement\n      score = newScore\n    }\n    currentElement = currentElement.nextSibling as Element | null\n  }\n  return bestElement\n}\n\nfunction scoreElement(node1: Element, node2: Element, ctx: any) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2)\n  }\n  return 0\n}\n\nfunction removeNode(tempNode: Element, ctx: any) {\n  removeIdsFromConsideration(ctx, tempNode)\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return\n\n  tempNode.remove()\n  ctx.callbacks.afterNodeRemoved(tempNode)\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: any, id: string) {\n  return !ctx.deadIds.has(id)\n}\n\nfunction idIsWithinNode(ctx: any, id: string, targetNode: Element) {\n  return ctx.idMap.get(targetNode)?.has(id) || false\n}\n\nfunction removeIdsFromConsideration(ctx: any, node: Element) {\n  const idSet = ctx.idMap.get(node)\n  if (!idSet) return\n  for (const id of idSet) {\n    ctx.deadIds.add(id)\n  }\n}\n\nfunction getIdIntersectionCount(ctx: any, node1: Element, node2: Element) {\n  const sourceSet = ctx.idMap.get(node1)\n  if (!sourceSet) return 0\n\n  let matchCount = 0\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount\n    }\n  }\n  return matchCount\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node: Element, idMap: Map<Element, Set<string>>) {\n  const nodeParent = node.parentElement\n  // find all elements with an id property\n  const idElements = node.querySelectorAll('[id]')\n  for (const elt of idElements) {\n    let current = elt as Element | null\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && !!current) {\n      let idSet = idMap.get(current)\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set()\n        idMap.set(current, idSet)\n      }\n      idSet.add(elt.id)\n      current = current.parentElement\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent: Element, newContent: Element) {\n  const idMap = new Map()\n  populateIdMapForNode(oldContent, idMap)\n  populateIdMapForNode(newContent, idMap)\n  return idMap\n}\n","import { fetchEventSource, FetchEventSourceInit } from '../external/fetch-event-source'\nimport { idiomorph } from '../external/idiomorph'\nimport { JSONStringify } from '../external/json-bigint'\nimport { Actions, AttributeContext, AttributePlugin } from '../types'\n\nconst GET = 'get',\n  POST = 'post',\n  PUT = 'put',\n  PATCH = 'patch',\n  DELETE = 'delete'\n\nexport const BackendActions: Actions = [GET, POST, PUT, PATCH, DELETE].reduce((acc, method) => {\n  acc[method] = async (ctx, urlExpression) => {\n    const da = Document as any\n    if (!da.startViewTransition) {\n      await fetcher(method, urlExpression, ctx)\n      return\n    }\n\n    new Promise((resolve) => {\n      da.startViewTransition(async () => {\n        await fetcher(method, urlExpression, ctx)\n        resolve(void 0)\n      })\n    })\n  }\n  return acc\n}, {} as Actions)\n\nconst CONTENT_TYPE = 'Content-Type'\nconst DATASTAR_REQUEST = 'datastar-request'\nconst APPLICATION_JSON = 'application/json'\nconst TRUE_STRING = 'true'\nconst DATASTAR_CLASS_PREFIX = 'datastar-'\nconst INDICATOR_CLASS = `${DATASTAR_CLASS_PREFIX}indicator`\nconst INDICATOR_LOADING_CLASS = `${INDICATOR_CLASS}-loading`\nconst SETTLING_CLASS = `${DATASTAR_CLASS_PREFIX}settling`\nconst SWAPPING_CLASS = `${DATASTAR_CLASS_PREFIX}swapping`\nconst SELECTOR_SELF_SELECTOR = 'self'\n\nconst MergeOptions = {\n  MorphElement: 'morph_element',\n  InnerElement: 'inner_element',\n  OuterElement: 'outer_element',\n  PrependElement: 'prepend_element',\n  AppendElement: 'append_element',\n  BeforeElement: 'before_element',\n  AfterElement: 'after_element',\n  DeleteElement: 'delete_element',\n  UpsertAttributes: 'upsert_attributes',\n} as const\ntype MergeOption = (typeof MergeOptions)[keyof typeof MergeOptions]\n\n// Sets the header of the fetch request\nexport const HeadersPlugin: AttributePlugin = {\n  prefix: 'header',\n  mustNotEmptyKey: true,\n  mustNotEmptyExpression: true,\n\n  onLoad: (ctx) => {\n    const headers = ctx.store().fetch.headers\n    const key = ctx.key[0].toUpperCase() + ctx.key.slice(1)\n    headers[key] = ctx.reactivity.computed(() => ctx.expressionFn(ctx))\n    return () => {\n      delete headers[key]\n    }\n  },\n}\n\n// Sets the fetch indicator selector\nexport const FetchIndicatorPlugin: AttributePlugin = {\n  prefix: 'fetchIndicator',\n  mustHaveEmptyKey: true,\n  mustNotEmptyExpression: true,\n  onGlobalInit: () => {\n    const style = document.createElement('style')\n    style.innerHTML = `\n.${INDICATOR_CLASS}{\n opacity:0;\n transition: opacity 300ms ease-out;\n}\n.${INDICATOR_LOADING_CLASS} {\n opacity:1;\n transition: opacity 300ms ease-in;\n}\n`\n    document.head.appendChild(style)\n  },\n  onLoad: (ctx) => {\n    return ctx.reactivity.effect(() => {\n      const c = ctx.reactivity.computed(() => `${ctx.expressionFn(ctx)}`)\n      const s = ctx.store()\n      s.fetch.indicatorSelectors[ctx.el.id] = c\n\n      const indicator = document.querySelector(c.value)\n      if (!indicator) throw new Error(`No indicator found`)\n      indicator.classList.add(INDICATOR_CLASS)\n\n      return () => {\n        delete s.fetch.indicatorSelectors[ctx.el.id]\n      }\n    })\n  },\n}\n\nexport const BackendPlugins: AttributePlugin[] = [HeadersPlugin, FetchIndicatorPlugin]\n\nasync function fetcher(method: string, urlExpression: string, ctx: AttributeContext) {\n  const s = ctx.store()\n\n  if (!urlExpression) {\n    throw new Error(`No signal for ${method} on ${urlExpression}`)\n  }\n\n  const storeWithoutFetch = { ...s.value }\n  delete storeWithoutFetch.fetch\n  const storeJSON = JSONStringify(storeWithoutFetch)\n\n  // console.log(`Adding ${LOADING_CLASS} to ${el.id}`)\n  let hasIndicator = false,\n    loadingTarget = ctx.el\n  const url = new URL(urlExpression, window.location.origin)\n  method = method.toUpperCase()\n  const req: FetchEventSourceInit = {\n    method,\n    headers: {\n      [CONTENT_TYPE]: APPLICATION_JSON,\n      [DATASTAR_REQUEST]: TRUE_STRING,\n    },\n    onopen: async () => {\n      const indicatorSelector = s.fetch?.indicatorSelectors?.[loadingTarget.id] || null\n      if (indicatorSelector) {\n        const indicator = document.querySelector(indicatorSelector.value)\n        if (indicator) {\n          loadingTarget = indicator\n          loadingTarget.classList.remove(INDICATOR_CLASS)\n          loadingTarget.classList.add(INDICATOR_LOADING_CLASS)\n          hasIndicator = true\n        }\n      }\n    },\n    onmessage: (evt) => {\n      if (!evt.event) return\n      let fragment = '',\n        merge: MergeOption = 'morph_element',\n        selector = '',\n        settleTime = 500,\n        isRedirect = false,\n        redirectURL = '',\n        error: Error | undefined = undefined,\n        isError = false,\n        isFragment = false\n      if (!evt.event.startsWith(DATASTAR_CLASS_PREFIX)) throw new Error(`Unknown event: ${evt.event}`)\n      const eventType = evt.event.slice(DATASTAR_CLASS_PREFIX.length)\n      switch (eventType) {\n        case 'redirect':\n          isRedirect = true\n          break\n        case 'fragment':\n          isFragment = true\n          break\n        case 'error':\n          isError = true\n          break\n        default:\n          throw `Unknown event: ${evt}`\n      }\n\n      evt.data.split('\\n').forEach((dataLine) => {\n        const offset = dataLine.indexOf(' ')\n        if (offset === -1) {\n          throw new Error(`Missing space in data`)\n        }\n\n        const type = dataLine.slice(0, offset)\n        const contents = dataLine.slice(offset + 1)\n\n        switch (type) {\n          case 'selector':\n            selector = contents\n            break\n          case 'merge':\n            const vmo = contents as MergeOption\n            const exists = Object.values(MergeOptions).includes(vmo)\n            if (!exists) {\n              throw new Error(`Unknown merge option: ${vmo}`)\n            }\n            merge = vmo\n            break\n          case 'settle':\n            settleTime = parseInt(contents)\n            break\n          case 'fragment':\n          case 'html':\n            fragment = contents\n            break\n          case 'redirect':\n            redirectURL = contents\n            break\n          case 'error':\n            error = new Error(contents)\n            break\n          default:\n            throw new Error(`Unknown data type`)\n        }\n      })\n\n      if (isError && error) {\n        throw error\n      } else if (isRedirect && redirectURL) {\n        window.location.href = redirectURL\n      } else if (isFragment && fragment) {\n        mergeHTMLFragment(ctx, selector, merge, fragment, settleTime)\n      } else {\n        throw new Error(`Unknown event: ${evt}`)\n      }\n    },\n    onclose: () => {\n      if (hasIndicator) {\n        loadingTarget.classList.remove(INDICATOR_LOADING_CLASS)\n        loadingTarget.classList.add(INDICATOR_CLASS)\n      }\n    },\n  }\n\n  if (s.fetch?.headers.value && req.headers) {\n    for (const key in s.fetch.headers.value) {\n      const value = s.fetch.headers.value[key]\n      req.headers[key] = value\n    }\n  }\n\n  if (method === 'GET') {\n    const queryParams = new URLSearchParams(url.search)\n    queryParams.append('datastar', storeJSON)\n    url.search = queryParams.toString()\n  } else {\n    req.body = storeJSON\n  }\n\n  await fetchEventSource(url, req)\n}\n\nconst fragContainer = document.createElement('template')\nexport function mergeHTMLFragment(\n  ctx: AttributeContext,\n  selector: string,\n  merge: MergeOption,\n  fragment: string,\n  settleTime: number,\n) {\n  const { el } = ctx\n\n  fragContainer.innerHTML = fragment\n  const frag = fragContainer.content.firstChild\n  if (!(frag instanceof Element)) {\n    throw new Error(`No fragment found`)\n  }\n\n  const useElAsTarget = selector === SELECTOR_SELF_SELECTOR\n\n  let targets: Iterable<Element>\n  if (useElAsTarget) {\n    targets = [el]\n  } else {\n    const selectorOrID = selector || `#${frag.getAttribute('id')}`\n    targets = document.querySelectorAll(selectorOrID) || []\n    if (!!!targets) throw new Error(`No targets found for ${selectorOrID}`)\n  }\n\n  for (const initialTarget of targets) {\n    initialTarget.classList.add(SWAPPING_CLASS)\n\n    const originalHTML = initialTarget.outerHTML\n\n    let modifiedTarget = initialTarget\n\n    switch (merge) {\n      case MergeOptions.MorphElement:\n        const result = idiomorph(modifiedTarget, frag)\n        if (!result?.length) throw new Error(`No morph result`)\n        const first = result[0] as Element\n        modifiedTarget = first\n        break\n      case MergeOptions.InnerElement:\n        // Replace the contents of the target element with the response\n        modifiedTarget.innerHTML = frag.innerHTML\n        break\n      case MergeOptions.OuterElement:\n        // Replace the entire target element with the response\n        modifiedTarget.replaceWith(frag)\n        break\n      case MergeOptions.PrependElement:\n        modifiedTarget.prepend(frag) //  Insert the response before the first child of the target element\n        break\n      case MergeOptions.AppendElement:\n        modifiedTarget.append(frag) //  Insert the response after the last child of the target element\n        break\n      case MergeOptions.BeforeElement:\n        modifiedTarget.before(frag) //  Insert the response before the target element\n        break\n      case MergeOptions.AfterElement:\n        modifiedTarget.after(frag) //  Insert the response after the target element\n        break\n      case MergeOptions.DeleteElement:\n        //  Deletes the target element regardless of the response\n        setTimeout(() => modifiedTarget.remove(), settleTime)\n        break\n      case MergeOptions.UpsertAttributes:\n        //  Upsert the attributes of the target element\n        frag.getAttributeNames().forEach((attrName) => {\n          const value = frag.getAttribute(attrName)!\n          modifiedTarget.setAttribute(attrName, value)\n        })\n        break\n      default:\n        throw new Error(`Unknown merge type: ${merge}`)\n    }\n    modifiedTarget.classList.add(SWAPPING_CLASS)\n\n    ctx.cleanupElementRemovals(initialTarget)\n    ctx.applyPlugins(modifiedTarget)\n\n    setTimeout(() => {\n      initialTarget.classList.remove(SWAPPING_CLASS)\n      modifiedTarget.classList.remove(SWAPPING_CLASS)\n    }, 1000)\n\n    const revisedHTML = modifiedTarget.outerHTML\n\n    if (originalHTML !== revisedHTML) {\n      modifiedTarget.classList.add(SETTLING_CLASS)\n      setTimeout(() => {\n        modifiedTarget.classList.remove(SETTLING_CLASS)\n      }, settleTime)\n    }\n  }\n}\n","import { toHTMLorSVGElement } from '../dom'\nimport { effect } from '../external/preact-core'\nimport { AttributeContext, AttributePlugin } from '../types'\n\nconst DISPLAY = 'display'\nconst NONE = 'none'\nconst IMPORTANT = 'important'\n\n// Sets the display of the element\nexport const ShowPlugin: AttributePlugin = {\n  prefix: 'show',\n  allowedModifiers: new Set([IMPORTANT]),\n\n  onLoad: (ctx: AttributeContext) => {\n    const { el, modifiers, expressionFn } = ctx\n\n    return effect(() => {\n      const expressionEvaluated = expressionFn(ctx)\n      const shouldShow = !!expressionEvaluated\n\n      const isImportant = modifiers.has(IMPORTANT)\n      const priority = isImportant ? IMPORTANT : undefined\n\n      if (shouldShow) {\n        if (el.style.length === 1 && el.style.display === NONE) {\n          el.style.removeProperty(DISPLAY)\n        } else {\n          el.style.setProperty(DISPLAY, '', priority)\n        }\n      } else {\n        el.style.setProperty(DISPLAY, NONE, priority)\n      }\n    })\n  },\n}\n\nconst INTERSECTS = 'intersects'\nconst ONCE = 'once'\nconst HALF = 'half'\nconst FULL = 'full'\n\n// Run expression when element intersects with viewport\nexport const IntersectionPlugin: AttributePlugin = {\n  prefix: INTERSECTS,\n  allowedModifiers: new Set([ONCE, HALF, FULL]),\n  mustHaveEmptyKey: true,\n  onLoad: (ctx: AttributeContext) => {\n    const { modifiers } = ctx\n    const options = { threshold: 0 }\n    if (modifiers.has(FULL)) options.threshold = 1\n    else if (modifiers.has(HALF)) options.threshold = 0.5\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          ctx.expressionFn(ctx)\n          if (modifiers.has(ONCE)) {\n            observer.disconnect()\n          }\n        }\n      })\n    }, options)\n\n    observer.observe(ctx.el)\n    return () => observer.disconnect()\n  },\n}\n\nconst PREPEND = 'prepend'\nconst APPEND = 'append'\nconst teleportParentErr = new Error('Target element must have a parent if using prepend or append')\n// Teleports the element to another element\nexport const TeleportPlugin: AttributePlugin = {\n  prefix: 'teleport',\n  allowedModifiers: new Set([PREPEND, APPEND]),\n  allowedTagRegexps: new Set(['template']),\n  bypassExpressionFunctionCreation: () => true,\n  onLoad: (ctx: AttributeContext) => {\n    const { el, modifiers, expression } = ctx\n    if (!(el instanceof HTMLTemplateElement)) throw new Error() // type guard\n\n    const target = document.querySelector(expression)\n    if (!target) throw new Error(`Target element not found: ${expression}`)\n\n    if (!el.content) {\n      throw new Error('Template element must have content')\n    }\n\n    const n = el.content.cloneNode(true)\n    const nEl = toHTMLorSVGElement(n as Element)\n    if (nEl?.firstElementChild) throw new Error('Empty template')\n\n    if (modifiers.has(PREPEND)) {\n      if (!target.parentNode) throw teleportParentErr\n      target.parentNode.insertBefore(n, target)\n    } else if (modifiers.has(APPEND)) {\n      if (!target.parentNode) throw teleportParentErr\n      target.parentNode.insertBefore(n, target.nextSibling)\n    } else {\n      target.appendChild(n)\n    }\n  },\n}\n\n// Scrolls the element into view\nexport const ScrollIntoViewPlugin: AttributePlugin = {\n  prefix: 'scrollIntoView',\n  onLoad: (ctx: AttributeContext) => {\n    const { el } = ctx\n    el.scrollIntoView({\n      behavior: 'smooth',\n      block: 'center',\n      inline: 'center',\n    })\n  },\n}\n\nconst viewTransitionID = 'ds-view-transition-stylesheet'\n// Setup view transition api\nexport const ViewTransitionPlugin: AttributePlugin = {\n  prefix: 'viewTransition',\n  onGlobalInit(ctx) {\n    const viewTransitionStylesheet = document.createElement('style')\n    viewTransitionStylesheet.id = viewTransitionID\n    document.head.appendChild(viewTransitionStylesheet)\n\n    let hasViewTransitionMeta = false\n    document.head.childNodes.forEach((node) => {\n      if (node instanceof HTMLMetaElement && node.name === 'view-transition') {\n        hasViewTransitionMeta = true\n      }\n    })\n\n    if (!hasViewTransitionMeta) {\n      const meta = document.createElement('meta')\n      meta.name = 'view-transition'\n      meta.content = 'same-origin'\n      document.head.appendChild(meta)\n    }\n\n    ctx.mergeStore({\n      viewTransitionRefCounts: {},\n    })\n  },\n  onLoad: (ctx: AttributeContext) => {\n    const { el, expressionFn } = ctx\n    let name = expressionFn(ctx)\n    if (!name) {\n      if (!el.id) throw new Error('Element must have an id if no name is provided')\n      name = el.id\n    }\n\n    const stylesheet = document.getElementById(viewTransitionID) as HTMLStyleElement\n    if (!stylesheet) throw new Error('View transition stylesheet not found')\n\n    const clsName = `ds-vt-${name}`\n    // add view transition class\n    const vtCls = `\n.${clsName} {\n  view-transition: ${name};\n}\n\n`\n    stylesheet.innerHTML += vtCls\n    const s = ctx.store()\n    let count = s.viewTransitionRefCounts[name]\n    if (!count) {\n      count = ctx.reactivity.signal(0)\n      s.viewTransitionRefCounts[name] = count\n    }\n    count.value++\n\n    // add class to element\n    el.classList.add(clsName)\n\n    return () => {\n      count.value--\n      if (count.value === 0) {\n        delete s.viewTransitionRefCounts[name]\n        stylesheet.innerHTML = stylesheet.innerHTML.replace(vtCls, '')\n      }\n    }\n  },\n}\n\nexport const VisibilityPlugins: AttributePlugin[] = [\n  ShowPlugin,\n  IntersectionPlugin,\n  TeleportPlugin,\n  ScrollIntoViewPlugin,\n  ViewTransitionPlugin,\n]\n","import { Actions } from '..'\n\nexport const HelperActions: Actions = {\n  setAll: async (ctx, regexp, newValue) => {\n    const re = new RegExp(regexp)\n    ctx.walkSignals((name, signal) => re.test(name) && (signal.value = newValue))\n  },\n  toggleAll: async (ctx, regexp) => {\n    const re = new RegExp(regexp)\n    ctx.walkSignals((name, signal) => re.test(name) && (signal.value = !signal.value))\n  },\n}\n","export * from './core'\nexport * from './dom'\nexport * from './types'\n\nimport { Datastar } from './core'\nimport { AttributePlugins, BackendActions, BackendPlugins, VisibilityPlugins } from './plugins'\nimport { HelperActions } from './plugins/helpers'\nimport { Actions, AttributePlugin } from './types'\n\nexport function runDatastarWith(actions: Actions = {}, ...plugins: AttributePlugin[]) {\n  const start = performance.now()\n  const ds = new Datastar(actions, ...plugins)\n  ds.run()\n  const end = performance.now()\n  console.log(`Datastar loaded and attached to all DOM elements in ${end - start}ms`)\n  return ds\n}\n\nexport function runDatastarWithAllPlugins(addedActions: Actions = {}, ...addedPlugins: AttributePlugin[]) {\n  const actions: Actions = Object.assign({}, HelperActions, BackendActions, addedActions)\n  const allPlugins = [...BackendPlugins, ...VisibilityPlugins, ...AttributePlugins, ...addedPlugins]\n  return runDatastarWith(actions, ...allPlugins)\n}\n\nconst winAny = window as any\nwinAny.ds = runDatastarWithAllPlugins()\nwinAny.dispatchEvent(new CustomEvent('datastar-ready'))\n"],"names":["toHTMLorSVGElement","node","cycleDetected","mutationDetected","identifier","RUNNING","NOTIFIED","OUTDATED","DISPOSED","HAS_ERROR","TRACKING","startBatch","batchDepth","endBatch","error","hasError","batchedEffect","effect","batchIteration","next","needsToRecompute","err","batch","callback","evalContext","globalVersion","addDependency","signal","Signal","value","prev","fn","flag","Computed","target","prepareSources","rollbackNode","cleanupSources","head","compute","prevContext","computed","cleanupEffect","cleanup","disposeEffect","endEffect","Effect","finish","DeepSignal","getValue","payload","setValue","deepSignal","initialValue","acc","key","iKey","peek","numbersBiggerThanMaxInt","JSONStringify","data","space","_","JSONParse","json","serializedData","apply","patchItem","targetResult","k","validNestedJSIdentifier","wholePrefixSuffix","rune","prefix","suffix","SignalProcessor","groups","ActionProcessor","action","args","withCtx","x","argsJoined","RefProcessor","ref","CorePreprocessors","CorePlugins","whole","ctx","bodyStore","el","expression","Datastar","actions","plugins","allPluginPrefixes","p","requiredPluginType","element","removalSet","removal","patchStore","revisedStore","name","rootElement","appliedProcessors","pi","dsKey","lowerCaseTag","r","t","keyRaw","modifiersWithArgsArr","modifiersArr","m","label","modifier","modifiers","processors","processor","expressionParts","revisedParts","exp","revised","matches","match","statements","s","fnContent","store","keys","i","isSignal","hasChildren","siblingOffset","kebabize","str","$","ofs","BindAttributePlugin","v","dataURIRegex","updateModelEvents","AttributePlugins","signalName","tnl","isInput","isSelect","isTextarea","isRadio","type","isCheckbox","isFile","setInputFromSignal","hasValue","cleanupSetInputFromSignal","setSignalFromInput","f","reader","mime","contents","mimeName","mimeSignal","nameName","nameSignal","current","input","parts","customElementPrefix","eventType","event","expressionFn","res","debounceArgs","wait","argsToMs","leading","argsHas","trailing","debounce","throttleArgs","throttle","evtListOpts","eventName","arg","defaultValue","timer","resetTimer","waiting","lastArgs","fetchEventSource","url","inputSignal","inputHeaders","inputOnOpen","onmessage","onclose","onerror","openWhenHidden","rest","resolve","reject","headers","EventStreamContentType","curRequestController","onVisibilityChange","create","retryInterval","DefaultRetryInterval","retryTimer","dispose","onopen","defaultOnOpen","response","getBytes","getLines","getMessages","id","LastEventId","retry","interval","innerErr","contentType","stream","onChunk","result","onLine","buffer","position","fieldLength","discardTrailingNewline","arr","concat","bufLength","lineStart","lineEnd","onId","onRetry","onMessage","message","newMessage","decoder","line","field","valueOffset","a","b","generatedByIdiomorphId","idiomorph","oldNode","newContent","config","parsedContent","parseContent","normalizedContent","normalizeContent","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","morphChildren","bestMatch","findBestNodeMatch","previousSibling","nextSibling","morphedNode","morphOldNodeTo","insertSiblings","isSoftMatch","syncNodeFrom","newParent","oldParent","nextNewChild","insertionPoint","newChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","from","to","fromAttribute","toAttribute","syncAttribute","fromValue","toValue","attributeName","fAttr","tAttr","newHeadTag","currentHead","added","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","newHeadChild","currentHeadElt","inNewContent","isReAppended","isPreserved","newNode","newElt","resolver","promise","removedElement","noOp","createIdMap","elt","node1","node2","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","parser","contentWithSvgsRemoved","content","Element","dummyParent","stack","currentElement","bestElement","score","newScore","scoreElement","isIdInConsideration","idIsWithinNode","targetNode","idSet","sourceSet","matchCount","populateIdMapForNode","idMap","nodeParent","idElements","oldContent","BackendActions","method","urlExpression","da","fetcher","CONTENT_TYPE","DATASTAR_REQUEST","APPLICATION_JSON","TRUE_STRING","DATASTAR_CLASS_PREFIX","INDICATOR_CLASS","INDICATOR_LOADING_CLASS","SETTLING_CLASS","SWAPPING_CLASS","SELECTOR_SELF_SELECTOR","MergeOptions","BackendPlugins","style","c","indicator","storeWithoutFetch","storeJSON","hasIndicator","loadingTarget","req","indicatorSelector","evt","fragment","merge","selector","settleTime","isRedirect","redirectURL","isError","isFragment","dataLine","offset","vmo","mergeHTMLFragment","queryParams","fragContainer","frag","useElAsTarget","targets","selectorOrID","initialTarget","originalHTML","modifiedTarget","attrName","revisedHTML","DISPLAY","NONE","IMPORTANT","ShowPlugin","shouldShow","priority","INTERSECTS","ONCE","HALF","FULL","IntersectionPlugin","options","observer","entries","entry","PREPEND","APPEND","teleportParentErr","TeleportPlugin","n","ScrollIntoViewPlugin","viewTransitionID","VisibilityPlugins","viewTransitionStylesheet","hasViewTransitionMeta","meta","stylesheet","clsName","vtCls","count","HelperActions","regexp","newValue","re","runDatastarWith","start","ds","end","runDatastarWithAllPlugins","addedActions","addedPlugins","allPlugins","winAny"],"mappings":"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"}